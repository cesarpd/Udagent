Directory structure:
└── uda-ejie-udalib/
    ├── README.md
    ├── LICENSE
    ├── NOTICE
    ├── SECURITY.md
    ├── doc/
    │   ├── architecture/
    │   └── guides/
    └── x38ShLibClasses/
        ├── pom.xml
        ├── .classpath
        ├── .gitignore
        ├── .project
        ├── x38ShLibClasses/
        │   ├── LICENSE.txt
        │   ├── NOTICE.txt
        │   ├── pom.xml
        │   ├── .classpath
        │   ├── .gitignore
        │   ├── .project
        │   ├── bin/
        │   │   └── .gitignore
        │   ├── src/
        │   │   └── main/
        │   │       └── java/
        │   │           ├── META-INF/
        │   │           │   └── MANIFEST.MF
        │   │           └── com/
        │   │               └── ejie/
        │   │                   └── x38/
        │   │                       ├── HtmlResponseWrapper.java
        │   │                       ├── IframeXHREmulationFilter.java
        │   │                       ├── UdaFilter.java
        │   │                       ├── UdaListener.java
        │   │                       ├── aop/
        │   │                       │   └── MainAdvice.java
        │   │                       ├── control/
        │   │                       │   ├── MvcInterceptor.java
        │   │                       │   ├── bind/
        │   │                       │   │   └── annotation/
        │   │                       │   │       ├── Json.java
        │   │                       │   │       └── RequestJsonBody.java
        │   │                       │   ├── exception/
        │   │                       │   │   ├── FileExceedsFileSizeLimitHandler.java
        │   │                       │   │   ├── IframeXHREmulationException.java
        │   │                       │   │   ├── MvcExceptionResolver.java
        │   │                       │   │   ├── MvcExceptionResolverConfig.java
        │   │                       │   │   └── handler/
        │   │                       │   │       ├── MvcAccessDeniedExceptionHandler.java
        │   │                       │   │       ├── MvcExceptionHandler.java
        │   │                       │   │       ├── MvcExceptionHandlerHelper.java
        │   │                       │   │       └── MvcValidationExceptionHandler.java
        │   │                       │   ├── method/
        │   │                       │   │   └── annotation/
        │   │                       │   │       ├── JsonMethodArgumentResolver.java
        │   │                       │   │       ├── JsonMethodReturnValueHandler.java
        │   │                       │   │       ├── RequestJsonBodyMethodArgumentResolver.java
        │   │                       │   │       └── RequestJsonBodyMethodProcessor.java
        │   │                       │   └── view/
        │   │                       │       ├── JsonViewSupportFactoryBean.java
        │   │                       │       ├── UdaTilesView.java
        │   │                       │       └── UdaViewResolver.java
        │   │                       ├── converter/
        │   │                       │   └── DateConverter.java
        │   │                       ├── dao/
        │   │                       │   ├── GenericDao.java
        │   │                       │   ├── GenericDaoImpl.java
        │   │                       │   ├── RowNumResultSetExtractor.java
        │   │                       │   └── sql/
        │   │                       │       ├── NlsLangControl.java
        │   │                       │       ├── OracleEncoder.java
        │   │                       │       ├── SqlEncoder.java
        │   │                       │       ├── codecs/
        │   │                       │       │   ├── Codec.java
        │   │                       │       │   ├── OracleCodec.java
        │   │                       │       │   └── PushbackString.java
        │   │                       │       └── error/
        │   │                       │           ├── EncodingException.java
        │   │                       │           └── SqlInjectionException.java
        │   │                       ├── dto/
        │   │                       │   ├── SearchDto.java
        │   │                       │   ├── SearchModelMapDto.java
        │   │                       │   ├── TableDto.java
        │   │                       │   ├── TableJerarquiaDto.java
        │   │                       │   ├── TableManager.java
        │   │                       │   ├── TableManagerJerarquia.java
        │   │                       │   ├── TableManagerJerarquiaGrid.java
        │   │                       │   ├── TableRequestDto.java
        │   │                       │   ├── TableResponseDto.java
        │   │                       │   └── TableRowDto.java
        │   │                       ├── generic/
        │   │                       │   └── model/
        │   │                       │       └── SelectGeneric.java
        │   │                       ├── json/
        │   │                       │   ├── CDL.java
        │   │                       │   ├── Cookie.java
        │   │                       │   ├── CookieList.java
        │   │                       │   ├── HTTP.java
        │   │                       │   ├── HTTPTokener.java
        │   │                       │   ├── JSONArray.java
        │   │                       │   ├── JSONException.java
        │   │                       │   ├── JSONML.java
        │   │                       │   ├── JSONObject.java
        │   │                       │   ├── JSONString.java
        │   │                       │   ├── JSONStringer.java
        │   │                       │   ├── JSONTokener.java
        │   │                       │   ├── JSONWriter.java
        │   │                       │   ├── JsonMixin.java
        │   │                       │   ├── MessageWriter.java
        │   │                       │   ├── XML.java
        │   │                       │   └── XMLTokener.java
        │   │                       ├── log/
        │   │                       │   ├── DaoLoggingAdviceImpl.java
        │   │                       │   ├── FilterLoggingAdviceImpl.java
        │   │                       │   ├── IncidenceLoggingAdvice.java
        │   │                       │   ├── IncidenceLoggingAdviceImpl.java
        │   │                       │   ├── LogConstants.java
        │   │                       │   ├── LogLayout.java
        │   │                       │   ├── LogbackConfigurer.java
        │   │                       │   ├── LoggingAdvice.java
        │   │                       │   ├── LoggingAdviceImpl.java
        │   │                       │   ├── LoggingEditor.java
        │   │                       │   ├── LoggingManager.java
        │   │                       │   ├── LoggingManagerImpl.java
        │   │                       │   ├── SLF4JLogger.java
        │   │                       │   ├── ServiceLoggingAdviceImpl.java
        │   │                       │   ├── UdaLogFilter.java
        │   │                       │   ├── UdaLogStatusListener.java
        │   │                       │   ├── model/
        │   │                       │   │   └── LogModel.java
        │   │                       │   └── security/
        │   │                       │       └── CurrentUserManager.java
        │   │                       ├── remote/
        │   │                       │   ├── RemoteEJBFactory.java
        │   │                       │   ├── RemoteEJBFactoryImpl.java
        │   │                       │   ├── TransactionMetadata.java
        │   │                       │   ├── TransactionMetadataSkeletonInterceptor.java
        │   │                       │   └── TransactionMetadataStubInterceptor.java
        │   │                       ├── security/
        │   │                       │   ├── AlternativeOriginCredentialsApp.java
        │   │                       │   ├── AlternativeOriginCredentialsAppImp.java
        │   │                       │   ├── Credentials.java
        │   │                       │   ├── ExcludeFilter.java
        │   │                       │   ├── MyAccessDeniedHandler.java
        │   │                       │   ├── MyAuthenticatedUserDetailsService.java
        │   │                       │   ├── MyAuthenticationEntryPoint.java
        │   │                       │   ├── MyLogoutHandler.java
        │   │                       │   ├── MyUserDetails.java
        │   │                       │   ├── PerimetralSecurityWrapper.java
        │   │                       │   ├── PerimetralSecurityWrapperMockImpl.java
        │   │                       │   ├── PerimetralSecurityWrapperN38Impl.java
        │   │                       │   ├── PerimetralSecurityWrapperOAMImpl.java
        │   │                       │   ├── PreAuthenticateProcessingFilter.java
        │   │                       │   ├── StockUdaSecurityPadlocks.java
        │   │                       │   ├── StockUdaSecurityPadlocksImpl.java
        │   │                       │   ├── UdaAuthenticationProvider.java
        │   │                       │   ├── UdaCustomJdbcDaoImpl.java
        │   │                       │   ├── UdaSecurityPadlock.java
        │   │                       │   ├── UserCredentials.java
        │   │                       │   ├── XlnetCore.java
        │   │                       │   └── XlnetGrantedAuthority.java
        │   │                       ├── serialization/
        │   │                       │   ├── CustomSerializer.java
        │   │                       │   ├── JsonBigDecimalDeserializer.java
        │   │                       │   ├── JsonBigDecimalSerializer.java
        │   │                       │   ├── JsonDateDeserializer.java
        │   │                       │   ├── JsonDateSerializer.java
        │   │                       │   ├── JsonDateTimeDeserializer.java
        │   │                       │   ├── JsonDateTimeSerializer.java
        │   │                       │   ├── JsonNumberDeserializer.java
        │   │                       │   ├── JsonNumberSerializer.java
        │   │                       │   ├── JsonTimeDeserializer.java
        │   │                       │   ├── JsonTimeSerializer.java
        │   │                       │   ├── MultiModelDeserializer.java
        │   │                       │   ├── ThreadSafeCache.java
        │   │                       │   ├── UdaMappingJackson2HttpMessageConverter.java
        │   │                       │   └── UdaModule.java
        │   │                       ├── spring/
        │   │                       │   └── context/
        │   │                       │       ├── AbstractUrlMethodNameResolver.java
        │   │                       │       ├── AnnotationMethodHandlerAdapter.java
        │   │                       │       ├── BeanFactoryLocator.java
        │   │                       │       ├── BeanFactoryReference.java
        │   │                       │       ├── BootstrapException.java
        │   │                       │       ├── ContextSingletonBeanFactoryLocator.java
        │   │                       │       ├── DefaultAnnotationHandlerMapping.java
        │   │                       │       ├── HandlerMethodInvocationException.java
        │   │                       │       ├── HandlerMethodInvoker.java
        │   │                       │       ├── HandlerMethodResolver.java
        │   │                       │       ├── InternalPathMethodNameResolver.java
        │   │                       │       ├── MethodNameResolver.java
        │   │                       │       ├── NoSuchRequestHandlingMethodException.java
        │   │                       │       ├── ServletAnnotationMappingUtils.java
        │   │                       │       ├── SingletonBeanFactoryLocator.java
        │   │                       │       ├── SourceHttpMessageConverter.java
        │   │                       │       ├── UdaContextLoaderListener.java
        │   │                       │       ├── WebUtils.java
        │   │                       │       └── XmlAwareFormHttpMessageConverter.java
        │   │                       ├── util/
        │   │                       │   ├── Constants.java
        │   │                       │   ├── DateTimeManager.java
        │   │                       │   ├── IframeXHREmulationUtils.java
        │   │                       │   ├── ManagementUrl.java
        │   │                       │   ├── MiscUtilitiesManager.java
        │   │                       │   ├── ObjectConversionManager.java
        │   │                       │   ├── StackTraceManager.java
        │   │                       │   ├── StaticsContainer.java
        │   │                       │   ├── TableManager.java
        │   │                       │   ├── ThreadStorageManager.java
        │   │                       │   ├── UdaMultipartResolver.java
        │   │                       │   ├── WebContextParameterManager.java
        │   │                       │   ├── WrappedRequest.java
        │   │                       │   └── XmlManager.java
        │   │                       └── validation/
        │   │                           ├── ValidationController.java
        │   │                           └── ValidationManager.java
        │   └── .settings/
        │       ├── org.eclipse.core.resources.prefs
        │       ├── org.eclipse.jdt.core.prefs
        │       ├── org.eclipse.m2e.core.prefs
        │       ├── org.eclipse.wst.common.component
        │       ├── org.eclipse.wst.common.project.facet.core.xml
        │       ├── org.eclipse.wst.validation.prefs
        │       └── org.hibernate.eclipse.console.prefs
        ├── x38ShLibClasses-dav/
        │   ├── LICENSE.txt
        │   ├── NOTICE.txt
        │   ├── pom.xml
        │   ├── .classpath
        │   ├── .gitignore
        │   ├── .project
        │   ├── src/
        │   │   └── main/
        │   │       └── java/
        │   │           ├── META-INF/
        │   │           │   └── MANIFEST.MF
        │   │           └── com/
        │   │               └── ejie/
        │   │                   └── x38/
        │   │                       └── webdav/
        │   │                           ├── IMethodExecutor.java
        │   │                           ├── IMimeTyper.java
        │   │                           ├── ITransaction.java
        │   │                           ├── IWebdavStore.java
        │   │                           ├── LocalFileSystemStore.java
        │   │                           ├── StoredObject.java
        │   │                           ├── WebDavServletBean.java
        │   │                           ├── WebDavServletHelper.java
        │   │                           ├── WebdavServlet.java
        │   │                           ├── WebdavSpringServlet.java
        │   │                           ├── WebdavStatus.java
        │   │                           ├── exceptions/
        │   │                           │   ├── AccessDeniedException.java
        │   │                           │   ├── LockFailedException.java
        │   │                           │   ├── ObjectAlreadyExistsException.java
        │   │                           │   ├── ObjectNotFoundException.java
        │   │                           │   ├── UnauthenticatedException.java
        │   │                           │   └── WebdavException.java
        │   │                           ├── fromcatalina/
        │   │                           │   ├── RequestUtil.java
        │   │                           │   ├── URLEncoder.java
        │   │                           │   ├── XMLHelper.java
        │   │                           │   └── XMLWriter.java
        │   │                           ├── locking/
        │   │                           │   ├── DataBaseLockDao.java
        │   │                           │   ├── DataBaseLockDaoImpl.java
        │   │                           │   ├── DataBaseLockService.java
        │   │                           │   ├── DataBaseLockServiceImpl.java
        │   │                           │   ├── DataBaseLockedObject.java
        │   │                           │   ├── DataBaseModel.java
        │   │                           │   ├── DataBaseResourceLocks.java
        │   │                           │   ├── IResourceLocks.java
        │   │                           │   ├── LockedObject.java
        │   │                           │   ├── MemoryLockedObject.java
        │   │                           │   └── MemoryResourceLocks.java
        │   │                           ├── methods/
        │   │                           │   ├── AbstractMethod.java
        │   │                           │   ├── DeterminableMethod.java
        │   │                           │   ├── DoCopy.java
        │   │                           │   ├── DoDelete.java
        │   │                           │   ├── DoGet.java
        │   │                           │   ├── DoHead.java
        │   │                           │   ├── DoLock.java
        │   │                           │   ├── DoMkcol.java
        │   │                           │   ├── DoMove.java
        │   │                           │   ├── DoNotImplemented.java
        │   │                           │   ├── DoOptions.java
        │   │                           │   ├── DoPropfind.java
        │   │                           │   ├── DoProppatch.java
        │   │                           │   ├── DoPut.java
        │   │                           │   └── DoUnlock.java
        │   │                           └── security/
        │   │                               ├── WebDAVHttpServletRequestWrapper.java
        │   │                               └── WebDAVXLNetsAuthenticationFilter.java
        │   └── .settings/
        │       ├── org.eclipse.core.resources.prefs
        │       ├── org.eclipse.jdt.core.prefs
        │       ├── org.eclipse.m2e.core.prefs
        │       ├── org.eclipse.wst.common.component
        │       ├── org.eclipse.wst.common.project.facet.core.xml
        │       ├── org.eclipse.wst.validation.prefs
        │       └── org.hibernate.eclipse.console.prefs
        ├── x38ShLibClasses-pif/
        │   ├── LICENSE.txt
        │   ├── NOTICE.txt
        │   ├── pom.xml
        │   ├── .classpath
        │   ├── .gitignore
        │   ├── .project
        │   ├── bin/
        │   │   └── .gitignore
        │   ├── src/
        │   │   └── main/
        │   │       └── java/
        │   │           ├── META-INF/
        │   │           │   └── MANIFEST.MF
        │   │           └── com/
        │   │               └── ejie/
        │   │                   └── x38/
        │   │                       └── pif/
        │   │                           ├── PifServletHelper.java
        │   │                           └── PifSpringServlet.java
        │   └── .settings/
        │       ├── org.eclipse.core.resources.prefs
        │       ├── org.eclipse.jdt.core.prefs
        │       ├── org.eclipse.m2e.core.prefs
        │       ├── org.eclipse.wst.common.component
        │       ├── org.eclipse.wst.common.project.facet.core.xml
        │       ├── org.eclipse.wst.validation.prefs
        │       └── org.hibernate.eclipse.console.prefs
        ├── x38ShLibClasses-rup/
        │   ├── LICENSE.txt
        │   ├── NOTICE.txt
        │   ├── pom.xml
        │   ├── .classpath
        │   ├── .gitignore
        │   ├── .project
        │   ├── bin/
        │   │   └── .gitignore
        │   ├── src/
        │   │   └── main/
        │   │       └── java/
        │   │           ├── META-INF/
        │   │           │   └── MANIFEST.MF
        │   │           └── com/
        │   │               └── ejie/
        │   │                   └── x38/
        │   │                       └── rup/
        │   │                           └── table/
        │   │                               └── filter/
        │   │                                   ├── dao/
        │   │                                   │   ├── FilterDao.java
        │   │                                   │   └── FilterDaoImpl.java
        │   │                                   ├── model/
        │   │                                   │   └── Filter.java
        │   │                                   └── service/
        │   │                                       ├── FilterService.java
        │   │                                       └── FilterServiceImpl.java
        │   └── .settings/
        │       ├── org.eclipse.core.resources.prefs
        │       ├── org.eclipse.jdt.core.prefs
        │       ├── org.eclipse.m2e.core.prefs
        │       ├── org.eclipse.wst.common.component
        │       ├── org.eclipse.wst.common.project.facet.core.xml
        │       ├── org.eclipse.wst.validation.prefs
        │       └── org.hibernate.eclipse.console.prefs
        └── .settings/
            ├── oracle.eclipse.tools.weblogic.syslib.xml
            ├── org.eclipse.core.resources.prefs
            ├── org.eclipse.jdt.core.prefs
            ├── org.eclipse.m2e.core.prefs
            ├── org.eclipse.wst.common.component
            ├── org.eclipse.wst.common.project.facet.core.xml
            ├── org.eclipse.wst.validation.prefs
            └── org.hibernate.eclipse.console.prefs

================================================
File: README.md
================================================
# udaLib
Utility library for UDA plugin generated source

Licensed under European Union Public Licence - EUPL v.1.1 (2007)
http://ec.europa.eu/idabc/eupl.html



================================================
File: LICENSE
================================================
                    Licencia Pública de la Unión Europea
                                 Versión 1.1
                        EUPL © Comunidad Europea 2007
                     http://ec.europa.eu/idabc/eupl.html


   La presente Licencia Pública de la Unión Europea («EUPL»), se aplica a la 
   obra o al programa de ordenador (definidos a continuación) suministrados en
   las condiciones fijadas en la presente licencia. Queda prohibido cualquier
   uso de la obra distinto del autorizado por la presente licencia (en la 
   medida en que tal uso esté protegido por un derecho del titular de los 
   derechos de autor de la obra). 
   
   La obra original se suministrará en las condiciones fijadas en la presente 
   licencia cuando el licenciante (definido a continuación) haya colocado la 
   siguiente advertencia inmediatamente después de la mención a los derechos 
   de autor de la obra original: 
   
   			Licencia cedida con arreglo a la EUPL V.1.1 
   
   o haya expresado por otro procedimiento su voluntad de conceder una 
   licencia con arreglo a la EUPL. 
   
   
   1. Definiciones 
      En la presente licencia, se entenderá por: 
      – licencia: la presente licencia. 
      – obra original o programa de ordenador: el programa de ordenador 
        distribuido o comunicado por el licenciante con arreglo a la presente 
        licencia en forma de código fuente o, en su caso, de código ejecutable;
      – obras derivadas: las obras o el programa de ordenador que pudiera crear
        el licenciatario sobre la base de la obra original o de alguna de las 
        modificaciones de ésta. La presente licencia no define el grado de 
        modificación o dependencia de la obra original necesario para 
        clasificar una obra como derivada; dicho grado se determinará de 
        acuerdo con la legislación sobre derechos de autor aplicable en el país
        contemplado en el artículo 15;
      – obra: la obra original o sus obras derivadas; 
      – código fuente: la forma de la obra legible por seres humanos que pueda 
        ser estudiada y modificada más fácilmente; 
      – código ejecutable: cualquier código, en general compilado, destinado a 
        ser ejecutado como programa por un ordenador; 
      – licenciante: la persona física o jurídica que distribuye o comunica la 
        obra con arreglo a la licencia; 
      – colaborador: la persona física o jurídica que modifica la obra con 
        arreglo a la licencia o contribuye de cualquier otra manera a crear una
        obra derivada; 
      – licenciatario: la persona física o jurídica que hace un uso cualquiera 
        del programa de ordenador en las condiciones fijadas en la licencia; 
      – distribución o comunicación: cualquier acto de venta, donación,
        préstamo, alquiler, distribución, comunicación, transmisión o cualquier
        otro acto de puesta a disposición, en línea o fuera de línea, de copias
        de la obra o de acceso a sus funcionalidades esenciales a otra persona 
        física o jurídica.
   
   2. Ámbito de los derechos otorgados por la Licencia 
      El licenciante concede al licenciatario una licencia de ámbito mundial, a
      título gratuito, no exclusiva y que el licenciatario puede subcontratar 
      mientras sigan vigentes los derechos de autor sobre la obra original, y 
      lo autoriza a: 
      
      – utilizar la obra en cualquier circunstancia y para cualquier uso; 
      – reproducir la obra; 
      – modificar la obra original y realizar obras derivadas de la misma; 
      – comunicar al público la obra o copias de la misma, poner a su 
        disposición o exhibir la obra o las copias y, en su caso, ejecutar 
        públicamente la Obra; 
      – distribuir la obra o copias de la misma; 
      – prestar y alquilar la obra o copias de la misma; 
      – subcontratar los derechos relativos a la obra o a las copias de la
        misma. 
      
      Dichos derechos se podrán ejercer a través de cualquier medio, soporte y 
      formato, conocido en el presente o que pueda inventarse en el futuro, en 
      la medida en que así lo permita la legislación aplicable. 
      
      En los países cuyo ordenamiento contemple los derechos morales, el 
      Licenciante renunciará al ejercicio de los mismos en la medida en que lo 
      permita la legislación, a fin de hacer efectiva la licencia de los 
      derechos patrimoniales anteriormente enumerados. 
      
      El licenciante cede al licenciatario, libre de cánones, los derechos de 
      uso no exclusivos sobre cualquier patente de que sea titular, en la 
      medida necesaria para que el licenciatario haga uso de los derechos sobre
      la obra otorgados por la presente licencia. 
   
   3. Comunicación del Código Fuente 
      El licenciante podrá suministrar la obra en forma de código fuente o 
      código ejecutable. Si la suministrara en forma de código ejecutable, 
      deberá facilitar además una copia legible automáticamente del código 
      fuente de la obra junto con cada copia de la obra que distribuya, o bien 
      indicar, en una advertencia inserta a continuación de la mención a los 
      derechos de autor adjunta a la obra, un repositorio en el que se pueda 
      acceder al código fuente fácilmente y de manera gratuita durante el 
      período en que el licenciante siga distribuyendo o comunicando la obra. 
   
   4. Limitaciones a los derechos de autor 
      En ningún caso podrá interpretarse la presente licencia de modo que prive
      al licenciatario de los beneficios de los que pudiera disfrutar como 
      consecuencia de las excepciones o limitaciones a los derechos exclusivos 
      de los titulares de los derechos de la obra original o del programa de 
      ordenador, de la extinción de dichos derechos o de cualquier otra 
      limitación aplicable. 
   
   5. Obligaciones del licenciatario 
      La cesión de los derechos en virtud de la presente licencia queda 
      supeditada a ciertas restricciones u obligaciones que habrá de respetar 
      el licenciatario. Dichas obligaciones son: 
      
      Derecho de atribución: El licenciatario deberá mantener íntegramente 
      todas las advertencias y menciones a los derechos de autor, patentes o 
      marcas registradas, así como las que se refieran a la licencia y a la 
      exención de responsabilidad. El licenciatario deberá adjuntar copias de 
      dichas advertencias y menciones y de la Licencia con cada copia de la 
      obra que distribuya o comunique. El licenciatario se responsabilizará de 
      que sus modificaciones u obras derivadas incluyan una advertencia bien 
      destacada declarando que ha modificado la obra, y la fecha de 
      modificación.
      
      Cláusula de «izquierdo de copia» (copyleft): Si el licenciatario 
      distribuyera o comunicara copias de la obra original o de obras derivadas
      basadas en la obra original, dicha distribución o comunicación deberá 
      hacerse en las condiciones fijadas en la presente licencia o de una 
      versión posterior de la presente licencia, salvo si la obra original se 
      distribuye expresamente solo en la presente versión de la licencia. El 
      licenciatario (ahora en su calidad de licenciante) no podrá ofrecer ni 
      imponer condiciones adicionales sobre la obra o las obras derivadas que 
      modifiquen o limiten las condiciones de la licencia. 
      
      Cláusula de compatibilidad: Si el licenciatario distribuyera o comunicara
      obras derivadas o copias de estas últimas basadas a su vez en la obra 
      original y en otra obra licenciada bajo una licencia compatible, la 
      distribución o comunicación podrán efectuarse con arreglo a las 
      condiciones de dicha licencia compatible. A efectos de la presente 
      cláusula, se entenderá por «licencia compatible» cualquiera de las 
      licencias enumeradas en el apéndice adjunto a la presente licencia. En 
      caso de que las obligaciones del licenciatario con arreglo a la licencia 
      compatible estén en colisión con las derivadas de la presente licencia, 
      prevalecerán las obligaciones de la licencia compatible. 
      
      Suministro del código fuente: Cuando distribuya o comunique copias de la 
      obra, el licenciatario deberá facilitar una copia del código fuente 
      legible automáticamente o indicar un repositorio en que se pueda acceder 
      al código fuente fácilmente y de manera gratuita durante el período en 
      que siga distribuyendo o comunicando la obra. 
      
      Salvaguardia de otros derechos: La presente licencia no faculta para 
      utilizar los nombres comerciales, marcas de producto o de servicio o 
      nombres del licenciante, excepto cuando ello, realizado en la medida de 
      lo razonable y conforme a los usos habituales, sea necesario para indicar
      el origen de la obra y reproducir el contenido de la mención a los 
      derechos de autor. 
   
   6. Secuencia de autoría 
      El licenciante original garantiza ser titular originario de los derechos 
      de autor sobre la obra original objeto de la presente licencia o haberlos
      adquirido mediante la licencia correspondiente y estar facultado para 
      otorgar licencias sobre tales derechos.
      
      Cada colaborador garantiza ser titular de los derechos de autor sobre las
      modificaciones que aporta a la obra o haberlos adquirido mediante la 
      correspondiente licencia y estar facultado para otorgar licencias sobre 
      tales derechos.
      
      Cada vez que el licenciatario acepta la licencia, el licenciante original
      y los colaboradores posteriores le otorgan una licencia sobre sus propias
      contribuciones a la obra en las condiciones fijadas en la presente
      licencia.
   
   7. Exclusión de garantía 
      La obra se encuentra en proceso de elaboración, siendo objeto de 
      continuas mejoras por parte de numerosos colaboradores. No es una obra 
      acabada y por tanto puede contener defectos o fallos inherentes al 
      desarrollo de este tipo de programas. 
      
      Por este motivo, la obra, en virtud de la licencia, se suministra «tal 
      cual», sin garantías de ningún tipo, en particular, en una enumeración no
      exhaustiva, en cuanto a su comercialización, adecuación a un propósito 
      determinado, ausencia de defectos 
      
      o errores, exactitud y ausencia de infracción de los derechos de 
      propiedad intelectual distintos de los derechos de autor según se afirma
      en el artículo 6 de la presente licencia. 
      Esta exclusión de garantía forma parte esencial de la licencia y es 
      condición para la cesión de cualquier derecho con respecto a la obra. 
   
   8. Exclusión de responsabilidad 
      Excepto en casos de dolo o de daños ocasionados directamente a personas 
      físicas, el licenciante no será responsable de los daños y perjuicios de 
      cualquier clase, directos o indirectos, materiales o morales, que 
      pudieran derivarse de la licencia o del uso de la obra, en particular, en
      una enumeración no exhaustiva, de los daños y perjuicios por pérdida de 
      buena reputación, paro técnico, avería o mal funcionamiento de equipos 
      informáticos, pérdida de datos o cualquier perjuicio comercial, incluso 
      si el licenciante conocía la posibilidad de dichos daños. No obstante, el
      licenciante será responsable, de acuerdo con las normas legales que 
      regulen la responsabilidad por los daños causados por productos, en la 
      medida en que dichas normas sean aplicables a la obra. 
   
   9. Acuerdos adicionales 
      Al distribuir la obra original o las obras derivadas, el licenciatario 
      podrá suscribir un acuerdo adicional, y cobrar una remuneración para 
      ofrecer asistencia y proporcionar garantías o asumir indemnizaciones u 
      otras obligaciones en materia de responsabilidad o proporcionar servicios
      compatibles con la presente licencia. No obstante, al aceptar tales 
      obligaciones, el licenciatario actuará únicamente en nombre propio y bajo
      su exclusiva responsabilidad, y nunca en nombre del licenciante original
      ni de ningún otro colaborador, y ello a condición de que acceda a 
      indemnizar, defender y amparar a todo colaborador frente a cualquier 
      responsabilidad en que éste pudiera incurrir y frente a las reclamaciones
      que pudieran presentarse contra él por haber aceptado el licenciatario la
      mencionada garantía o responsabilidad adicional.
   
   10. Aceptación de la licencia 
      Lo dispuesto en la presente licencia puede aceptarse haciendo clic en el 
      icono «Aceptar» situado en la parte inferior de la ventana en que aparece
      el texto de la presente licencia o manifestando el consentimiento de 
      cualquier otra forma similar, de conformidad con lo previsto en la 
      legislación aplicable. Haciendo clic en dicho icono, se expresa la 
      aceptación inequívoca e irrevocable de la presente licencia y de todo su 
      contenido. 
      
      Asimismo, el licenciatario acepta irrevocablemente la presente licencia y
      todas sus condiciones por el mero hecho de ejercer cualquiera de los 
      derechos que le otorga el artículo 2 de la presente licencia, tales como
      el uso de la obra, la creación de una obra derivada o la distribución o 
      comunicación de la obra o de copias de la misma. 
   
   11. Información al público 
      En caso de que el licenciatario proceda a la distribución o comunicación
      de la obra por medios electrónicos (por ejemplo, ofreciendo la descarga 
      de la obra a distancia), el canal o medio de distribución (por ejemplo, 
      un sitio web) deberá facilitar al público, como mínimo, la información 
      exigida por la legislación aplicable acerca del licenciante, la licencia 
      y la manera en que el licenciatario puede acceder a dichos datos, 
      aceptarlos, conservarlos y reproducirlos. 
   
   12. Extinción de la licencia 
      La licencia y los derechos otorgados a su amparo se extinguirán 
      automáticamente si el licenciatario incumple alguna de las condiciones de
      la licencia.
      
      Tal extinción no supondrá, sin embargo, la de las licencias de que 
      disfruten las personas que hayan recibido la obra del licenciatario en
      virtud de la licencia, siempre que dichas personas sigan cumpliendo 
      plenamente las condiciones de la licencia. 
   
   13. Varios 
      No obstante lo dispuesto en el artículo 9, la licencia representará la 
      totalidad del acuerdo entre las partes en cuanto a la obra objeto de la 
      misma. 
      
      La eventual invalidez o ineficacia de alguna disposición de la presente 
      licencia con arreglo a la legislación vigente no afectará a la validez o 
      eficacia general de la licencia. En tales casos, la disposición se 
      interpretará o reformulará según proceda para hacerla válida y eficaz. 
      
      La Comisión Europea podrá publicar otras versiones lingüísticas o nuevas 
      versiones de la presente licencia en la medida en que resulte necesario y
      razonable y sin reducir el ámbito de los derechos concedidos por la 
      licencia. Las nuevas versiones de la licencia se publicarán con un número
      de versión único. 
      
      Todas las versiones lingüísticas de la presente licencia aprobadas por la
      Comisión European tienen idéntico valor. Las partes pueden utilizar la
      versión lingüística de su preferencia. 
   
   14. Tribunales competentes 
      Los litigios relativos a la interpretación de la presente licencia que se
      planteen entre la Comisión Europea, en calidad de licenciante, y un 
      licenciatario, se someterán a la jurisdicción del Tribunal de Justicia de
      las Comunidades Europeas, con arreglo al artículo 238 del Tratado
      constitutivo de la Comunidad Europea. 
      
      Los litigios relativos la interpretación de la presente licencia que se
      planteen entre partes distintas de la Comisión Europea, se someterán a la
      jurisdicción exclusiva del tribunal que sea competente en el lugar en que
      resida o ejerza su actividad principal el licenciante. 
   
   15. Legislación aplicable 
      La presente Licencia se regirá por la legislación del país de la Unión 
      Europea en el que resida o tenga su domicilio social el licenciante. 
      
      La presente licencia se regirá por la legislación belga si: 
      
      – se planteara un litigio entre la Comisión Europea, en calidad de 
        licenciante, y un licenciatario; 
      – el licenciante, distinto de la Comisión Europea, no residiera o no 
        tuviera su domicilio social en un Estado miembro de la Unión Europea. 
   
   Apéndice 
   
   Son «licencias compatibles» con la EUPL con arreglo al artículo 5: 
   
   – GNU General Public License (GNU GPL) v. 2 
   – Open Software License (OSL) v. 2.1, v. 3.0 
   – Common Public License v. 1.0 
   – Eclipse Public License v. 1.0 
   – Cecill v. 2.0 
   


================================================
File: NOTICE
================================================
NOTICE.txt - UDA copyright notices

UDA is Copyright 2012 by E.J.I.E., S.A.
	
	* The plug-in and RUP components are licensed under the EUPL, Version 1.1 only 
	(the "Licence");
	* Documentation is licensed under the Creative Commons Attribution-NonCommercial-
	ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) 
	
THIRD PARTY COMPONENTS

	The UDA plug-in includes software developed by:
	
		* Enterprise JavaBeans 3.0
			http://www.oracle.com/technetwork/java/javaee/ejb/index.html
			Sun Microsystems, Inc.
			License: COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0

		* Oracle JDBC Drivers 
			http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html
			Oracle Corporation
			License: OTN (http://www.oracle.com/technetwork/licenses/standard-license-152015.html)

		* The JBoss Community
			Hibernate Tools (http://www.hibernate.org/subprojects/tools.html)
			Copyright (c) 2010 JBoss by Red Hat and others.
			License: FSF Lesser Gnu Public License (LGPL v2.1) (http://www.hibernate.org/license)

		* Eclipse
			Eclipse Platform (http://www.eclipse.org/platform)
			Copyright (c) Eclipse contributors and others 2000, 2011.  All rights reserved.
			License: Eclipse Foundation Software User Agreement
						
		* Oracle Enterprise Pack for Eclipse (OEPE)
			http://www.oracle.com/technetwork/developer-tools/eclipse/overview/index.html
			Copyright © 2008, 2011, Oracle and/or its affiliates. All rights reserved.
			License: ORACLE ENTERPRISE PACK FOR ECLIPSE LICENSE AGREEMENT
						
		* PMD (http://pmd.sourceforge.net)
			PMD plugin For Eclipse
			Copyright (c) 1997-2009, PMD for Eclipse Development Team
			License: "BSD-style" license (http://pmd.sourceforge.net/license.html)									

		* Eclipse Checkstyle Plugin (http://eclipse-cs.sf.net/)
			Checkstyle integration plugin for Eclipse
			(c) Copyright David Schneider, Lars Koedderitzsch and others, 2002-2010
			License: GNU Lesser General Public License Version 2.1 
						
		* FindBugs (http://findbugs.sourceforge.net)
			FindBugs plugin for Eclipse
			(c) Trademark and Copyright 2003-2008 by the University of Maryland.
			License: GNU Lesser General Public License (LGPL) (http://findbugs.sourceforge.net/manual/license.html)
			
		* Eclipse Subversive - SVN Team Provider Project
			The Eclipse Team Provider for the Subversion version control system.
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement 
			
		* Polarion Subversive SVN Connectors (http://www.polarion.org and http://www.polarion.com)
			Set of the SVN connectors for the Eclipse Subversive - SVN Team Provider. 
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement
			
		* Resource Bundle Editor (http://sourceforge.net/projects/eclipse-rbe/)
			Essiembre ResourceBundle Editor
			Copyright (C) 2003, 2004  Pascal Essiembre, Essiembre Consultant Inc.
			License: GNU Lesser General Public License Version 2.1

		* FreeMarker IDE (http://www.jboss.org/tools)
			FreeMarkerIDE provides editor for FreeMarker templates
			Copyright (c) 2008-2011 Red Hat, Inc. and others.
			License: Eclipse Public License - v 1.0 (http://www.eclipse.org/legal/epl-v10.html)


			
	The RUP (Rich UDA Patterns) components includes software developed by:

		* The jQuery Project
			jQuery core (http://jquery.com/)
			Copyright 2011, John Resig
			License: Gnu Public License v2 (GPLv2), MIT license
			
		* The jQueryUI Team
			jQueryUI (http://jqueryui.com/)
			Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
			License: Gnu Public License v2 (GPLv2), MIT license

		* The jQuery Grid Plugin
			jQuery Grid Plugin (http://www.trirand.com/blog/)
			Copyright (c) 2007-2011 jQuery Grid Plugin 
			License: Gnu Public License v2 (GPLv2), MIT license

		* ajaxBlender.com
			xBreadcrumbs (Extended Breadcrums) jQuery Plugin (http://www.ajaxblender.com/xbreadcrumbs.html)
			Copyright 2009 ajaxBlender.com 
			
		* form2object			
			form2object (https://github.com/maxatwork/form2js)
			Copyright (c) 2010 Maxim Vasiliev
			License: (https://github.com/maxatwork/form2js/blob/master/license.txt)
			
		* jQuery File Upload Plugin 5.5.1			
			jQuery File Upload (https://github.com/blueimp/jQuery-File-Upload)
			Copyright 2010, Sebastian Tschan
			License: MIT license (https://github.com/blueimp/jQuery-File-Upload)
			
			

================================================
File: SECURITY.md
================================================
# Política de seguridad

## Versiones soportadas

| Versión | Soportada          |
| ------- | ------------------ |
| 6.1.x   | :white_check_mark: |
| 5.4.x   | :white_check_mark: |
| 4.5.x   | :white_check_mark: |
| 3.x.x   | :x:                |
| 2.x.x   | :x:                |
| 1.x.x   | :x:                |

## Reportar vulnerabilidades

Los reportes de vulnerabilidades pueden hacerse a través de la sección de incidencias de GitHub. Si la incidencia es aceptada, será etiquetada como *vulnerability* para poder distinguirla mejor del resto de incidencias.


================================================
File: x38ShLibClasses/pom.xml
================================================
<project xmlns="http://maven.apache.org/POM/4.0.0"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<groupId>com.ejie.x38</groupId>
	<artifactId>x38</artifactId>
	<packaging>pom</packaging>
	<version>6.1.0-RELEASE</version>
	<name>x38</name>
	<url>http://www.ejie.eus</url>

	<modules>
		<module>x38ShLibClasses</module>
		<module>x38ShLibClasses-dav</module>
		<module>x38ShLibClasses-pif</module>
		<module>x38ShLibClasses-rup</module>
	</modules>

	<properties>
		<maven.compiler.source>11</maven.compiler.source>
		<maven.compiler.target>11</maven.compiler.target>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<org.springframework.version>5.3.39</org.springframework.version>
		<org.springframework.security.version>5.8.15</org.springframework.security.version>
		<org.logback.version>1.2.13</org.logback.version>
		<org.slf4j.version>1.7.30</org.slf4j.version>
		<org.apache.tiles.version>3.0.8</org.apache.tiles.version>
		<org.jackson.version>2.12.7.1</org.jackson.version>
		<eclipselink.version>2.4.2</eclipselink.version>
	</properties>

	<dependencies>
		<!-- Spring -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context</artifactId>
			<version>${org.springframework.version}</version>
			<exclusions>
				<!-- Exclude Commons Logging in favor of logback -->
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webmvc</artifactId>
			<version>${org.springframework.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-orm</artifactId>
			<version>${org.springframework.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-context-support</artifactId>
			<version>${org.springframework.version}</version>
		</dependency>

		<!-- Spring Security -->
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-core</artifactId>
			<version>${org.springframework.security.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-config</artifactId>
			<version>${org.springframework.security.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-acl</artifactId>
			<version>${org.springframework.security.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-web</artifactId>
			<version>${org.springframework.security.version}</version>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-taglibs</artifactId>
			<version>${org.springframework.security.version}</version>
		</dependency>

		<!-- Spring Test -->
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-test</artifactId>
			<version>${org.springframework.version}</version>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>javax.servlet</groupId>
			<artifactId>javax.servlet-api</artifactId>
			<version>4.0.1</version>
			<scope>provided</scope>
		</dependency>
		
		<!-- JAVAX -->
		<dependency>
			<groupId>javax.annotation</groupId>
			<artifactId>javax.annotation-api</artifactId>
			<version>1.3.2</version>
		</dependency>
		<dependency>
		    <groupId>javax.xml.bind</groupId>
		    <artifactId>jaxb-api</artifactId>
		    <version>2.3.1</version>
		</dependency>
		<dependency>
		    <groupId>com.sun.mail</groupId>
		    <artifactId>javax.mail</artifactId>
		    <version>1.6.2</version>
		</dependency>

		<!-- TILES -->
		<dependency>
			<groupId>org.apache.tiles</groupId>
			<artifactId>tiles-api</artifactId>
			<version>${org.apache.tiles.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.tiles</groupId>
			<artifactId>tiles-core</artifactId>
			<version>${org.apache.tiles.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.tiles</groupId>
			<artifactId>tiles-jsp</artifactId>
			<version>${org.apache.tiles.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.tiles</groupId>
			<artifactId>tiles-servlet</artifactId>
			<version>${org.apache.tiles.version}</version>
		</dependency>
		<dependency>
			<groupId>org.apache.tiles</groupId>
			<artifactId>tiles-template</artifactId>
			<version>${org.apache.tiles.version}</version>
		</dependency>

		<!-- HAMCREST -->
		<dependency>
      		<groupId>org.hamcrest</groupId>
      		<artifactId>hamcrest-core</artifactId>
      		<version>1.3</version>
    	</dependency>
		<!-- Logging -->
		<dependency>
			<groupId>org.jboss.logging</groupId>
			<artifactId>jboss-logging</artifactId>
			<version>3.3.0.Final</version>
		</dependency>
		<!-- SLF4J -->
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>jcl-over-slf4j</artifactId>
			<version>${org.slf4j.version}</version>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-api</artifactId>
			<version>${org.slf4j.version}</version>
		</dependency>
		<dependency>
			<groupId>org.slf4j</groupId>
			<artifactId>slf4j-ext</artifactId>
			<version>${org.slf4j.version}</version>
			<exclusions>
				<!-- Exclude Compiler assisted localization library (CAL10N) -->
				<exclusion>
					<groupId>ch.qos.cal10n</groupId>
					<artifactId>cal10n-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- Logback -->
		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-core</artifactId>
			<version>${org.logback.version}</version>
		</dependency>
		<dependency>
			<groupId>ch.qos.logback</groupId>
			<artifactId>logback-classic</artifactId>
			<version>${org.logback.version}</version>
		</dependency>
		<!-- Jdbcdslog -->
		<dependency>
		    <groupId>com.googlecode.usc</groupId>
		    <artifactId>jdbcdslog</artifactId>
		    <version>1.0.5</version>
		    <exclusions>
				<exclusion>
					<groupId>slf4j</groupId>
					<artifactId>slf4j-api</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<!-- Hibernate Validator -->
		<dependency>
			<groupId>org.hibernate</groupId>
			<artifactId>hibernate-validator</artifactId>
			<version>5.4.3.Final</version>
			<exclusions>
				<exclusion>
					<groupId>org.jboss.logging</groupId>
					<artifactId>jboss-logging</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<!-- AspectJ -->
		<dependency>
			<groupId>org.aspectj</groupId>
			<artifactId>aspectjweaver</artifactId>
			<version>1.8.13</version>
		</dependency>

		<!-- Apache commons -->
		<dependency>
			<groupId>commons-fileupload</groupId>
			<artifactId>commons-fileupload</artifactId>
			<version>1.5</version>
		</dependency>
		<dependency>
			<groupId>commons-beanutils</groupId>
			<artifactId>commons-beanutils</artifactId>
			<version>1.9.4</version>
			<exclusions>
				<!-- Exclude Commons Logging in favor of logback -->
				<exclusion>
					<groupId>commons-logging</groupId>
					<artifactId>commons-logging</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<!-- EclipseLink -->
		<dependency>
			<groupId>org.eclipse.persistence</groupId>
			<artifactId>eclipselink</artifactId>
			<version>${eclipselink.version}</version>
			<exclusions>
				<exclusion>
					<groupId>org.eclipse.persistence</groupId>
					<artifactId>javax.persistence</artifactId>
				</exclusion>
			</exclusions>
		</dependency>

		<!-- Jackson JSON Mapper -->
		<dependency>
			<groupId>com.fasterxml.jackson.core</groupId>
			<artifactId>jackson-databind</artifactId>
			<version>${org.jackson.version}</version>
		</dependency>

		<!-- Reports -->
		<!-- ODF Toolkit -->
		<dependency>
			<groupId>org.odftoolkit</groupId>
			<artifactId>odfdom-java</artifactId>
			<version>0.8.7</version>
			<exclusions>
				<exclusion>
					<groupId>xerces</groupId>
					<artifactId>xercesImpl</artifactId>
				</exclusion>
				<exclusion>
					<groupId>xml-apis</groupId>
					<artifactId>xml-apis</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.codehaus.jackson</groupId>
					<artifactId>jackson-core-asl</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.codehaus.jackson</groupId>
					<artifactId>jackson-mapper-asl</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- Fin Reports -->

		<!-- INI:HADOOP EN APLICACION UDA -->
		<dependency>
			<groupId>org.apache.hadoop</groupId>
			<artifactId>hadoop-client</artifactId>
			<version>1.0.3</version>
			<exclusions>
				<exclusion>
					<groupId>commons-cli</groupId>
					<artifactId>commons-cli</artifactId>
				</exclusion>
				<exclusion>
					<groupId>xmlenc</groupId>
					<artifactId>xmlenc</artifactId>
				</exclusion>
				<exclusion>
					<groupId>commons-codec</groupId>
					<artifactId>commons-codec</artifactId>
				</exclusion>
				<exclusion>
					<groupId>xmlenc</groupId>
					<artifactId>xmlenc</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.apache.commons</groupId>
					<artifactId>commons-math</artifactId>
				</exclusion>
				<exclusion>
					<groupId>commons-configuration</groupId>
					<artifactId>commons-configuration</artifactId>
				</exclusion>
				<exclusion>
					<groupId>commons-net</groupId>
					<artifactId>commons-net</artifactId>
				</exclusion>
				<exclusion>
					<groupId>commons-el</groupId>
					<artifactId>commons-el</artifactId>
				</exclusion>
				<exclusion>
					<groupId>hsqldb</groupId>
					<artifactId>hsqldb</artifactId>
				</exclusion>
				<exclusion>
					<groupId>oro</groupId>
					<artifactId>oro</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.codehaus.jackson</groupId>
					<artifactId>jackson-core-asl</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.codehaus.jackson</groupId>
					<artifactId>jackson-mapper-asl</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>net.sf.flexjson</groupId>
			<artifactId>flexjson</artifactId>
			<version>2.1</version>
		</dependency>
		<dependency>
			<groupId>org.mongodb</groupId>
			<artifactId>mongo-java-driver</artifactId>
			<version>2.6.3</version>
		</dependency>
		<dependency>
			<groupId>eu.medsea.mimeutil</groupId>
			<artifactId>mime-util</artifactId>
			<version>2.1.3</version>
			<exclusions>
				<exclusion>
					<groupId>log4j</groupId>
					<artifactId>log4j</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.slf4j</groupId>
					<artifactId>slf4j-api</artifactId>
				</exclusion>
				<exclusion>
					<groupId>org.slf4j</groupId>
					<artifactId>slf4j-log4j12</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<!-- FIN:HADOOP EN APLICACION UDA -->

		<!-- PIF 1.4 -->
		<dependency>
			<groupId>com.ejie</groupId>
			<artifactId>y31b</artifactId>
			<version>1.4</version>
			<classifier>ifaz</classifier>
		</dependency>
		<dependency>
			<groupId>com.ejie</groupId>
			<artifactId>y31c</artifactId>
			<version>1.5</version>
			<classifier>impl</classifier>
		</dependency>
		<dependency>
			<groupId>commons-codec</groupId>
			<artifactId>commons-codec</artifactId>
			<version>1.6</version>
		</dependency>
		<dependency>
			<groupId>net.sf.ezmorph</groupId>
			<artifactId>ezmorph</artifactId>
			<version>1.0.2</version>
			<exclusions>
				<exclusion>
					<groupId>commons-lang</groupId>
					<artifactId>commons-lang</artifactId>
				</exclusion>
			</exclusions>
		</dependency>
		<dependency>
			<groupId>net.sf.json-lib</groupId>
			<artifactId>json-lib</artifactId>
			<version>2.3</version>
			<classifier>jdk15</classifier>
		</dependency>
		<dependency>
			<groupId>org.mortbay.jetty</groupId>
			<artifactId>jetty-util</artifactId>
			<version>6.1.26</version>
		</dependency>
		<dependency>
			<groupId>javax.ws.rs</groupId>
			<artifactId>javax.ws.rs-api</artifactId>
			<version>2.0.1</version>
		</dependency>
		<dependency>
			<groupId>org.apache.hadoop</groupId>
			<artifactId>hadoop-core-without-webhdfs</artifactId>
			<version>1.0.3</version>
		</dependency>
		<dependency>
			<groupId>org.apache.avro</groupId>
			<artifactId>avro</artifactId>
			<version>1.7.7</version>
			<!-- <exclusions> -->
			<!-- <exclusion> -->
			<!-- <groupId>org.codehaus.jackson</groupId> -->
			<!-- <artifactId>jackson-core-asl</artifactId> -->
			<!-- </exclusion> -->
			<!-- <exclusion> -->
			<!-- <groupId>org.codehaus.jackson</groupId> -->
			<!-- <artifactId>jackson-mapper-asl</artifactId> -->
			<!-- </exclusion> -->
			<!-- </exclusions> -->
		</dependency>
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpclient</artifactId>
			<version>4.3.3</version>
		</dependency>
		<dependency>
			<groupId>org.apache.httpcomponents</groupId>
			<artifactId>httpcore</artifactId>
			<version>4.3.3</version>
		</dependency>
		<dependency>
			<groupId>io.dropwizard.metrics</groupId>
			<artifactId>metrics-core</artifactId>
			<version>3.1.2</version>
		</dependency>
		<dependency>
			<groupId>commons-collections</groupId>
			<artifactId>commons-collections</artifactId>
			<version>3.2.2</version>
		</dependency>
		<dependency>
			<groupId>commons-configuration</groupId>
			<artifactId>commons-configuration</artifactId>
			<version>1.6</version>
		</dependency>
		<!-- FIN PIF 1.4 -->

		<!-- Dependencias para que funcione sin WebLogic en local -->
		<dependency>
  			<groupId>ejie.xlnets</groupId>
  			<artifactId>n38</artifactId>
  			<version>1.0</version>
			<scope>provided</scope>
		</dependency>

		<!-- 
		<dependency>
			<groupId>com.oracle.weblogic</groupId>
			<artifactId>weblogic-server-pom</artifactId>
			<version>12.2.1-4-0</version>
			<type>pom</type>
			<scope>provided</scope>
		</dependency>	
		-->

		<dependency>
			<groupId>com.oracle.weblogic</groupId>
			<artifactId>com.oracle.weblogic.jndi</artifactId>
			<version>12.2.1-4-0</version>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>com.oracle.weblogic</groupId>
			<artifactId>com.oracle.weblogic.jndi.api</artifactId>
			<version>12.2.1-4-0</version>
			<scope>provided</scope>
		</dependency>

		<dependency>
  			<groupId>javax.mail</groupId>
  			<artifactId>javax.mail-api</artifactId>
  			<version>1.6.2</version>
			<scope>provided</scope>
		</dependency>

		<dependency>
  			<groupId>javax.interceptor</groupId>
			<artifactId>javax.interceptor-api</artifactId>
  			<version>1.2</version>
			<scope>provided</scope>
		</dependency>

		<dependency>
			<groupId>javax.persistence</groupId>
			<artifactId>javax.persistence-api</artifactId>
			<version>2.2</version>
			<scope>provided</scope>
		</dependency>

		<dependency>
  			<groupId>junit</groupId>
  			<artifactId>junit</artifactId>
  			<version>4.13.2</version>
  			<scope>test</scope>
		</dependency>
		<!-- FIN Dependencias para que funcione sin WebLogic en local -->

	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-dependency-plugin</artifactId>
			</plugin>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.12.1</version>
				<configuration>
					<source>11</source>
					<target>11</target>
				</configuration>
			</plugin>
		</plugins>
	</build>

    <distributionManagement>
        <repository>
            <id>in-house-app-releases</id>
            <name>in-house-app-releases</name>
            <layout>default</layout>
            <url>https://bin.alm02.itbatera.euskadi.eus/repository/in-house-app-releases/</url>
        </repository>
        <snapshotRepository>
            <id>in-house-app-snapshots</id>
            <name>in-house-app-snapshots</name>
            <layout>default</layout>
            <url>https://bin.alm02.itbatera.euskadi.eus/repository/in-house-app-snapshots/</url>
        </snapshotRepository>		
    </distributionManagement>

</project>


================================================
File: x38ShLibClasses/.classpath
================================================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
		<attributes>
			<attribute name="owner.project.facets" value="java"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="oracle.eclipse.tools.weblogic.lib.system"/>
	<classpathentry kind="output" path="target/classes"/>
</classpath>


================================================
File: x38ShLibClasses/.gitignore
================================================
/bin/
/lib/**
/target/**
.svn
**/.metadata/**
/target/


================================================
File: x38ShLibClasses/.project
================================================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>x38_v6</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.m2e.core.maven2Builder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.m2e.core.maven2Nature</nature>
	</natures>
</projectDescription>


================================================
File: x38ShLibClasses/x38ShLibClasses/LICENSE.txt
================================================
                    Licencia Pública de la Unión Europea
                                 Versión 1.1
                        EUPL © Comunidad Europea 2007
                     http://ec.europa.eu/idabc/eupl.html


   La presente Licencia Pública de la Unión Europea («EUPL»), se aplica a la 
   obra o al programa de ordenador (definidos a continuación) suministrados en
   las condiciones fijadas en la presente licencia. Queda prohibido cualquier
   uso de la obra distinto del autorizado por la presente licencia (en la 
   medida en que tal uso esté protegido por un derecho del titular de los 
   derechos de autor de la obra). 
   
   La obra original se suministrará en las condiciones fijadas en la presente 
   licencia cuando el licenciante (definido a continuación) haya colocado la 
   siguiente advertencia inmediatamente después de la mención a los derechos 
   de autor de la obra original: 
   
   			Licencia cedida con arreglo a la EUPL V.1.1 
   
   o haya expresado por otro procedimiento su voluntad de conceder una 
   licencia con arreglo a la EUPL. 
   
   
   1. Definiciones 
      En la presente licencia, se entenderá por: 
      – licencia: la presente licencia. 
      – obra original o programa de ordenador: el programa de ordenador 
        distribuido o comunicado por el licenciante con arreglo a la presente 
        licencia en forma de código fuente o, en su caso, de código ejecutable;
      – obras derivadas: las obras o el programa de ordenador que pudiera crear
        el licenciatario sobre la base de la obra original o de alguna de las 
        modificaciones de ésta. La presente licencia no define el grado de 
        modificación o dependencia de la obra original necesario para 
        clasificar una obra como derivada; dicho grado se determinará de 
        acuerdo con la legislación sobre derechos de autor aplicable en el país
        contemplado en el artículo 15;
      – obra: la obra original o sus obras derivadas; 
      – código fuente: la forma de la obra legible por seres humanos que pueda 
        ser estudiada y modificada más fácilmente; 
      – código ejecutable: cualquier código, en general compilado, destinado a 
        ser ejecutado como programa por un ordenador; 
      – licenciante: la persona física o jurídica que distribuye o comunica la 
        obra con arreglo a la licencia; 
      – colaborador: la persona física o jurídica que modifica la obra con 
        arreglo a la licencia o contribuye de cualquier otra manera a crear una
        obra derivada; 
      – licenciatario: la persona física o jurídica que hace un uso cualquiera 
        del programa de ordenador en las condiciones fijadas en la licencia; 
      – distribución o comunicación: cualquier acto de venta, donación,
        préstamo, alquiler, distribución, comunicación, transmisión o cualquier
        otro acto de puesta a disposición, en línea o fuera de línea, de copias
        de la obra o de acceso a sus funcionalidades esenciales a otra persona 
        física o jurídica.
   
   2. Ámbito de los derechos otorgados por la Licencia 
      El licenciante concede al licenciatario una licencia de ámbito mundial, a
      título gratuito, no exclusiva y que el licenciatario puede subcontratar 
      mientras sigan vigentes los derechos de autor sobre la obra original, y 
      lo autoriza a: 
      
      – utilizar la obra en cualquier circunstancia y para cualquier uso; 
      – reproducir la obra; 
      – modificar la obra original y realizar obras derivadas de la misma; 
      – comunicar al público la obra o copias de la misma, poner a su 
        disposición o exhibir la obra o las copias y, en su caso, ejecutar 
        públicamente la Obra; 
      – distribuir la obra o copias de la misma; 
      – prestar y alquilar la obra o copias de la misma; 
      – subcontratar los derechos relativos a la obra o a las copias de la
        misma. 
      
      Dichos derechos se podrán ejercer a través de cualquier medio, soporte y 
      formato, conocido en el presente o que pueda inventarse en el futuro, en 
      la medida en que así lo permita la legislación aplicable. 
      
      En los países cuyo ordenamiento contemple los derechos morales, el 
      Licenciante renunciará al ejercicio de los mismos en la medida en que lo 
      permita la legislación, a fin de hacer efectiva la licencia de los 
      derechos patrimoniales anteriormente enumerados. 
      
      El licenciante cede al licenciatario, libre de cánones, los derechos de 
      uso no exclusivos sobre cualquier patente de que sea titular, en la 
      medida necesaria para que el licenciatario haga uso de los derechos sobre
      la obra otorgados por la presente licencia. 
   
   3. Comunicación del Código Fuente 
      El licenciante podrá suministrar la obra en forma de código fuente o 
      código ejecutable. Si la suministrara en forma de código ejecutable, 
      deberá facilitar además una copia legible automáticamente del código 
      fuente de la obra junto con cada copia de la obra que distribuya, o bien 
      indicar, en una advertencia inserta a continuación de la mención a los 
      derechos de autor adjunta a la obra, un repositorio en el que se pueda 
      acceder al código fuente fácilmente y de manera gratuita durante el 
      período en que el licenciante siga distribuyendo o comunicando la obra. 
   
   4. Limitaciones a los derechos de autor 
      En ningún caso podrá interpretarse la presente licencia de modo que prive
      al licenciatario de los beneficios de los que pudiera disfrutar como 
      consecuencia de las excepciones o limitaciones a los derechos exclusivos 
      de los titulares de los derechos de la obra original o del programa de 
      ordenador, de la extinción de dichos derechos o de cualquier otra 
      limitación aplicable. 
   
   5. Obligaciones del licenciatario 
      La cesión de los derechos en virtud de la presente licencia queda 
      supeditada a ciertas restricciones u obligaciones que habrá de respetar 
      el licenciatario. Dichas obligaciones son: 
      
      Derecho de atribución: El licenciatario deberá mantener íntegramente 
      todas las advertencias y menciones a los derechos de autor, patentes o 
      marcas registradas, así como las que se refieran a la licencia y a la 
      exención de responsabilidad. El licenciatario deberá adjuntar copias de 
      dichas advertencias y menciones y de la Licencia con cada copia de la 
      obra que distribuya o comunique. El licenciatario se responsabilizará de 
      que sus modificaciones u obras derivadas incluyan una advertencia bien 
      destacada declarando que ha modificado la obra, y la fecha de 
      modificación.
      
      Cláusula de «izquierdo de copia» (copyleft): Si el licenciatario 
      distribuyera o comunicara copias de la obra original o de obras derivadas
      basadas en la obra original, dicha distribución o comunicación deberá 
      hacerse en las condiciones fijadas en la presente licencia o de una 
      versión posterior de la presente licencia, salvo si la obra original se 
      distribuye expresamente solo en la presente versión de la licencia. El 
      licenciatario (ahora en su calidad de licenciante) no podrá ofrecer ni 
      imponer condiciones adicionales sobre la obra o las obras derivadas que 
      modifiquen o limiten las condiciones de la licencia. 
      
      Cláusula de compatibilidad: Si el licenciatario distribuyera o comunicara
      obras derivadas o copias de estas últimas basadas a su vez en la obra 
      original y en otra obra licenciada bajo una licencia compatible, la 
      distribución o comunicación podrán efectuarse con arreglo a las 
      condiciones de dicha licencia compatible. A efectos de la presente 
      cláusula, se entenderá por «licencia compatible» cualquiera de las 
      licencias enumeradas en el apéndice adjunto a la presente licencia. En 
      caso de que las obligaciones del licenciatario con arreglo a la licencia 
      compatible estén en colisión con las derivadas de la presente licencia, 
      prevalecerán las obligaciones de la licencia compatible. 
      
      Suministro del código fuente: Cuando distribuya o comunique copias de la 
      obra, el licenciatario deberá facilitar una copia del código fuente 
      legible automáticamente o indicar un repositorio en que se pueda acceder 
      al código fuente fácilmente y de manera gratuita durante el período en 
      que siga distribuyendo o comunicando la obra. 
      
      Salvaguardia de otros derechos: La presente licencia no faculta para 
      utilizar los nombres comerciales, marcas de producto o de servicio o 
      nombres del licenciante, excepto cuando ello, realizado en la medida de 
      lo razonable y conforme a los usos habituales, sea necesario para indicar
      el origen de la obra y reproducir el contenido de la mención a los 
      derechos de autor. 
   
   6. Secuencia de autoría 
      El licenciante original garantiza ser titular originario de los derechos 
      de autor sobre la obra original objeto de la presente licencia o haberlos
      adquirido mediante la licencia correspondiente y estar facultado para 
      otorgar licencias sobre tales derechos.
      
      Cada colaborador garantiza ser titular de los derechos de autor sobre las
      modificaciones que aporta a la obra o haberlos adquirido mediante la 
      correspondiente licencia y estar facultado para otorgar licencias sobre 
      tales derechos.
      
      Cada vez que el licenciatario acepta la licencia, el licenciante original
      y los colaboradores posteriores le otorgan una licencia sobre sus propias
      contribuciones a la obra en las condiciones fijadas en la presente
      licencia.
   
   7. Exclusión de garantía 
      La obra se encuentra en proceso de elaboración, siendo objeto de 
      continuas mejoras por parte de numerosos colaboradores. No es una obra 
      acabada y por tanto puede contener defectos o fallos inherentes al 
      desarrollo de este tipo de programas. 
      
      Por este motivo, la obra, en virtud de la licencia, se suministra «tal 
      cual», sin garantías de ningún tipo, en particular, en una enumeración no
      exhaustiva, en cuanto a su comercialización, adecuación a un propósito 
      determinado, ausencia de defectos 
      
      o errores, exactitud y ausencia de infracción de los derechos de 
      propiedad intelectual distintos de los derechos de autor según se afirma
      en el artículo 6 de la presente licencia. 
      Esta exclusión de garantía forma parte esencial de la licencia y es 
      condición para la cesión de cualquier derecho con respecto a la obra. 
   
   8. Exclusión de responsabilidad 
      Excepto en casos de dolo o de daños ocasionados directamente a personas 
      físicas, el licenciante no será responsable de los daños y perjuicios de 
      cualquier clase, directos o indirectos, materiales o morales, que 
      pudieran derivarse de la licencia o del uso de la obra, en particular, en
      una enumeración no exhaustiva, de los daños y perjuicios por pérdida de 
      buena reputación, paro técnico, avería o mal funcionamiento de equipos 
      informáticos, pérdida de datos o cualquier perjuicio comercial, incluso 
      si el licenciante conocía la posibilidad de dichos daños. No obstante, el
      licenciante será responsable, de acuerdo con las normas legales que 
      regulen la responsabilidad por los daños causados por productos, en la 
      medida en que dichas normas sean aplicables a la obra. 
   
   9. Acuerdos adicionales 
      Al distribuir la obra original o las obras derivadas, el licenciatario 
      podrá suscribir un acuerdo adicional, y cobrar una remuneración para 
      ofrecer asistencia y proporcionar garantías o asumir indemnizaciones u 
      otras obligaciones en materia de responsabilidad o proporcionar servicios
      compatibles con la presente licencia. No obstante, al aceptar tales 
      obligaciones, el licenciatario actuará únicamente en nombre propio y bajo
      su exclusiva responsabilidad, y nunca en nombre del licenciante original
      ni de ningún otro colaborador, y ello a condición de que acceda a 
      indemnizar, defender y amparar a todo colaborador frente a cualquier 
      responsabilidad en que éste pudiera incurrir y frente a las reclamaciones
      que pudieran presentarse contra él por haber aceptado el licenciatario la
      mencionada garantía o responsabilidad adicional.
   
   10. Aceptación de la licencia 
      Lo dispuesto en la presente licencia puede aceptarse haciendo clic en el 
      icono «Aceptar» situado en la parte inferior de la ventana en que aparece
      el texto de la presente licencia o manifestando el consentimiento de 
      cualquier otra forma similar, de conformidad con lo previsto en la 
      legislación aplicable. Haciendo clic en dicho icono, se expresa la 
      aceptación inequívoca e irrevocable de la presente licencia y de todo su 
      contenido. 
      
      Asimismo, el licenciatario acepta irrevocablemente la presente licencia y
      todas sus condiciones por el mero hecho de ejercer cualquiera de los 
      derechos que le otorga el artículo 2 de la presente licencia, tales como
      el uso de la obra, la creación de una obra derivada o la distribución o 
      comunicación de la obra o de copias de la misma. 
   
   11. Información al público 
      En caso de que el licenciatario proceda a la distribución o comunicación
      de la obra por medios electrónicos (por ejemplo, ofreciendo la descarga 
      de la obra a distancia), el canal o medio de distribución (por ejemplo, 
      un sitio web) deberá facilitar al público, como mínimo, la información 
      exigida por la legislación aplicable acerca del licenciante, la licencia 
      y la manera en que el licenciatario puede acceder a dichos datos, 
      aceptarlos, conservarlos y reproducirlos. 
   
   12. Extinción de la licencia 
      La licencia y los derechos otorgados a su amparo se extinguirán 
      automáticamente si el licenciatario incumple alguna de las condiciones de
      la licencia.
      
      Tal extinción no supondrá, sin embargo, la de las licencias de que 
      disfruten las personas que hayan recibido la obra del licenciatario en
      virtud de la licencia, siempre que dichas personas sigan cumpliendo 
      plenamente las condiciones de la licencia. 
   
   13. Varios 
      No obstante lo dispuesto en el artículo 9, la licencia representará la 
      totalidad del acuerdo entre las partes en cuanto a la obra objeto de la 
      misma. 
      
      La eventual invalidez o ineficacia de alguna disposición de la presente 
      licencia con arreglo a la legislación vigente no afectará a la validez o 
      eficacia general de la licencia. En tales casos, la disposición se 
      interpretará o reformulará según proceda para hacerla válida y eficaz. 
      
      La Comisión Europea podrá publicar otras versiones lingüísticas o nuevas 
      versiones de la presente licencia en la medida en que resulte necesario y
      razonable y sin reducir el ámbito de los derechos concedidos por la 
      licencia. Las nuevas versiones de la licencia se publicarán con un número
      de versión único. 
      
      Todas las versiones lingüísticas de la presente licencia aprobadas por la
      Comisión European tienen idéntico valor. Las partes pueden utilizar la
      versión lingüística de su preferencia. 
   
   14. Tribunales competentes 
      Los litigios relativos a la interpretación de la presente licencia que se
      planteen entre la Comisión Europea, en calidad de licenciante, y un 
      licenciatario, se someterán a la jurisdicción del Tribunal de Justicia de
      las Comunidades Europeas, con arreglo al artículo 238 del Tratado
      constitutivo de la Comunidad Europea. 
      
      Los litigios relativos la interpretación de la presente licencia que se
      planteen entre partes distintas de la Comisión Europea, se someterán a la
      jurisdicción exclusiva del tribunal que sea competente en el lugar en que
      resida o ejerza su actividad principal el licenciante. 
   
   15. Legislación aplicable 
      La presente Licencia se regirá por la legislación del país de la Unión 
      Europea en el que resida o tenga su domicilio social el licenciante. 
      
      La presente licencia se regirá por la legislación belga si: 
      
      – se planteara un litigio entre la Comisión Europea, en calidad de 
        licenciante, y un licenciatario; 
      – el licenciante, distinto de la Comisión Europea, no residiera o no 
        tuviera su domicilio social en un Estado miembro de la Unión Europea. 
   
   Apéndice 
   
   Son «licencias compatibles» con la EUPL con arreglo al artículo 5: 
   
   – GNU General Public License (GNU GPL) v. 2 
   – Open Software License (OSL) v. 2.1, v. 3.0 
   – Common Public License v. 1.0 
   – Eclipse Public License v. 1.0 
   – Cecill v. 2.0 
   


================================================
File: x38ShLibClasses/x38ShLibClasses/NOTICE.txt
================================================
NOTICE.txt - UDA copyright notices

UDA is Copyright 2011 by E.J.I.E., S.A.
	
	* The plug-in and RUP components are licensed under the EUPL, Version 1.1 only 
	(the "Licence");
	* Documentation is licensed under the Creative Commons Attribution-NonCommercial-
	ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) 
	
THIRD PARTY COMPONENTS

	The UDA plug-in includes software developed by:
	
		* Enterprise JavaBeans 3.0
			http://www.oracle.com/technetwork/java/javaee/ejb/index.html
			Sun Microsystems, Inc.
			License: COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0

		* Oracle JDBC Drivers 
			http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html
			Oracle Corporation
			License: OTN (http://www.oracle.com/technetwork/licenses/standard-license-152015.html)

		* The JBoss Community
			Hibernate Tools (http://www.hibernate.org/subprojects/tools.html)
			Copyright (c) 2010 JBoss by Red Hat and others.
			License: FSF Lesser Gnu Public License (LGPL v2.1) (http://www.hibernate.org/license)

		* Eclipse
			Eclipse Platform (http://www.eclipse.org/platform)
			Copyright (c) Eclipse contributors and others 2000, 2011.  All rights reserved.
			License: Eclipse Foundation Software User Agreement
						
		* Oracle Enterprise Pack for Eclipse (OEPE)
			http://www.oracle.com/technetwork/developer-tools/eclipse/overview/index.html
			Copyright © 2008, 2011, Oracle and/or its affiliates. All rights reserved.
			License: ORACLE ENTERPRISE PACK FOR ECLIPSE LICENSE AGREEMENT
						
		* PMD (http://pmd.sourceforge.net)
			PMD plugin For Eclipse
			Copyright (c) 1997-2009, PMD for Eclipse Development Team
			License: "BSD-style" license (http://pmd.sourceforge.net/license.html)									

		* Eclipse Checkstyle Plugin (http://eclipse-cs.sf.net/)
			Checkstyle integration plugin for Eclipse
			(c) Copyright David Schneider, Lars Koedderitzsch and others, 2002-2010
			License: GNU Lesser General Public License Version 2.1 
						
		* FindBugs (http://findbugs.sourceforge.net)
			FindBugs plugin for Eclipse
			(c) Trademark and Copyright 2003-2008 by the University of Maryland.
			License: GNU Lesser General Public License (LGPL) (http://findbugs.sourceforge.net/manual/license.html)
			
		* Eclipse Subversive - SVN Team Provider Project
			The Eclipse Team Provider for the Subversion version control system.
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement 
			
		* Polarion Subversive SVN Connectors (http://www.polarion.org and http://www.polarion.com)
			Set of the SVN connectors for the Eclipse Subversive - SVN Team Provider. 
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement
			
		* Resource Bundle Editor (http://sourceforge.net/projects/eclipse-rbe/)
			Essiembre ResourceBundle Editor
			Copyright (C) 2003, 2004  Pascal Essiembre, Essiembre Consultant Inc.
			License: GNU Lesser General Public License Version 2.1

		* FreeMarker IDE (http://www.jboss.org/tools)
			FreeMarkerIDE provides editor for FreeMarker templates
			Copyright (c) 2008-2011 Red Hat, Inc. and others.
			License: Eclipse Public License - v 1.0 (http://www.eclipse.org/legal/epl-v10.html)


			
	The RUP (Rich UDA Patterns) components includes software developed by:

		* The jQuery Project
			jQuery core (http://jquery.com/)
			Copyright 2011, John Resig
			License: Gnu Public License v2 (GPLv2), MIT license
			
		* The jQueryUI Team
			jQueryUI (http://jqueryui.com/)
			Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
			License: Gnu Public License v2 (GPLv2), MIT license

		* The jQuery Grid Plugin
			jQuery Grid Plugin (http://www.trirand.com/blog/)
			Copyright (c) 2007-2011 jQuery Grid Plugin 
			License: Gnu Public License v2 (GPLv2), MIT license

		* ajaxBlender.com
			xBreadcrumbs (Extended Breadcrums) jQuery Plugin (http://www.ajaxblender.com/xbreadcrumbs.html)
			Copyright 2009 ajaxBlender.com 
			
		* form2object			
			form2object (https://github.com/maxatwork/form2js)
			Copyright (c) 2010 Maxim Vasiliev
			License: (https://github.com/maxatwork/form2js/blob/master/license.txt)
			
			

================================================
File: x38ShLibClasses/x38ShLibClasses/pom.xml
================================================
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<parent>
		<groupId>com.ejie.x38</groupId>
		<artifactId>x38</artifactId>
		<version>6.1.0-RELEASE</version>
	</parent>
	<modelVersion>4.0.0</modelVersion>
	<artifactId>x38ShLibClasses</artifactId>
	<packaging>jar</packaging>
	<name>x38ShLibClasses</name>
	<url>http://www.ejie.eus</url>
	<dependencies>
		<dependency>
			<groupId>ejie.xlnets</groupId>
			<artifactId>n38</artifactId>
			<version>1.0</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>javax.mail</groupId>
			<artifactId>mail</artifactId>
			<version>1.4.7</version>
			<scope>test</scope>
		</dependency>
	</dependencies>
</project>


================================================
File: x38ShLibClasses/x38ShLibClasses/.classpath
================================================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" output="target/classes" path="src/main/java">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="org.eclipse.jst.component.nondependency" value=""/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-11">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="output" path="target/classes"/>
</classpath>


================================================
File: x38ShLibClasses/x38ShLibClasses/.gitignore
================================================
/target/


================================================
File: x38ShLibClasses/x38ShLibClasses/.project
================================================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>x38ShLibClasses_v6</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.wst.common.project.facet.core.builder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.hibernate.eclipse.console.hibernateBuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.wst.validation.validationbuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.m2e.core.maven2Builder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jdt.core.javanature</nature>
		<nature>org.eclipse.m2e.core.maven2Nature</nature>
		<nature>org.hibernate.eclipse.console.hibernateNature</nature>
		<nature>org.eclipse.wst.common.project.facet.core.nature</nature>
		<nature>org.eclipse.wst.common.modulecore.ModuleCoreNature</nature>
		<nature>org.eclipse.jem.workbench.JavaEMFNature</nature>
	</natures>
</projectDescription>


================================================
File: x38ShLibClasses/x38ShLibClasses/bin/.gitignore
================================================
/bin/
/target/


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/META-INF/MANIFEST.MF
================================================
Manifest-Version: 1.0
Class-Path: 



================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/HtmlResponseWrapper.java
================================================
package com.ejie.x38;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintWriter;

import javax.servlet.ServletOutputStream;
import javax.servlet.WriteListener;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpServletResponseWrapper;

public class HtmlResponseWrapper extends HttpServletResponseWrapper {

    private final ByteArrayOutputStream capture;
    private ServletOutputStream output;
    private PrintWriter writer;
    
    private int httpStatus;

    public HtmlResponseWrapper(HttpServletResponse response) {
        super(response);
        this.capture = new ByteArrayOutputStream(response.getBufferSize());
        this.httpStatus = HttpServletResponse.SC_OK;
        
    }

    @Override
    public ServletOutputStream getOutputStream() {
        if (writer != null) {
            throw new IllegalStateException(
                    "getWriter() has already been called on this response.");
        }

        if (output == null) {
            output = new ServletOutputStream() {
                @Override
                public void write(int b) throws IOException {
                    capture.write(b);
                }

                @Override
                public void flush() throws IOException {
                    capture.flush();
                }

                @Override
                public void close() throws IOException {
                    capture.close();
                }

				@Override
				public boolean isReady() {
					// TODO Auto-generated method stub
					return false;
				}

				@Override
				public void setWriteListener(WriteListener writeListener) {
					// TODO Auto-generated method stub
					
				}

            };
        }

        return output;
    }

    @Override
    public PrintWriter getWriter() throws IOException {
        if (output != null) {
            throw new IllegalStateException(
                    "getOutputStream() has already been called on this response.");
        }

        if (writer == null) {
            writer = new PrintWriter(new OutputStreamWriter(capture,
                    getCharacterEncoding()));
        }

        return writer;
    }

    @Override
    public void flushBuffer() throws IOException {
        super.flushBuffer();

        if (writer != null) {
            writer.flush();
        } else if (output != null) {
            output.flush();
        }
    }
    
    @Override
	public void setStatus(int sc) {
		httpStatus = sc;
	}
	
	/**
	 * Getter de la propiedad httpStatus.
	 * 
	 * @return Código de estado http.
	 */
	public int getStatus() {
		return httpStatus;
	}
	

    public byte[] getCaptureAsBytes() throws IOException {
        if (writer != null) {
            writer.close();
        } else if (output != null) {
            output.close();
        }

        return capture.toByteArray();
    }

    public String getCaptureAsString() throws IOException {
        return new String(getCaptureAsBytes(), getCharacterEncoding());
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/IframeXHREmulationFilter.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.filter.DelegatingFilterProxy;

import com.ejie.x38.util.IframeXHREmulationUtils;

/**
 * Filtro encargado de modificar la request en caso de que sea necesaria emular
 * el comportamiento de la gestión de errores HTTP al utilizar iframes.
 * 
 * @author UDA
 * 
 */
public class IframeXHREmulationFilter extends DelegatingFilterProxy {

	@Override
	public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)
			throws ServletException, IOException {

		
		// Se comprueba si es necesario realizar la emulación.
		if (IframeXHREmulationUtils.isIframeEmulationRequired(request)) {
			// Se genera un wrapper de la response para poder insertar la
			// respuesta indicada en la response dentro de la estructura
			// necesaria.
			
			HttpServletResponse httpServletResponse = (HttpServletResponse) response;
			
			HtmlResponseWrapper capturingResponseWrapper = new HtmlResponseWrapper((HttpServletResponse) response);
			
			try {

				// Se continúa con la ejecución de la petición.
				filterChain.doFilter(request, capturingResponseWrapper);

				String content = capturingResponseWrapper.getCaptureAsString();

				IframeXHREmulationUtils.writeIframeHttpStatus(httpServletResponse, content,
						capturingResponseWrapper.getStatus());

			} catch (Exception e) {

				String content = capturingResponseWrapper.getCaptureAsString();

				IframeXHREmulationUtils.writeIframeHttpStatus(httpServletResponse, content,
						capturingResponseWrapper.getStatus());
			}
		} else {
			// En caso de no ser necesaria la emulación se continua con la
			// ejecución.
			filterChain.doFilter(request, response);
		}
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/UdaFilter.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Pattern;

import javax.servlet.FilterChain;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.DelegatingFilterProxy;
import org.springframework.web.util.UriComponentsBuilder;

import com.ejie.x38.serialization.ThreadSafeCache;
import com.ejie.x38.util.StackTraceManager;
import com.ejie.x38.util.ThreadStorageManager;
import com.ejie.x38.util.WrappedRequest;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Filtro principal que cumple las siguientes funciones:
 * 1- Inicializa la variable de ThreadLocal que asigna un identificador a cada hilo.
 * 2- Verifica si la petición lleva la cabecera RUP, para activar el mecanismo de serialización a través del UdaMappingJackson2HttpMessageConverter.
 * 3- Si llevan excepciones no capturadas por los desarrolladores, redirige a la página de error.
 * 4- Limpia el ThreadLocal.
 * 
 * @author UDA
 */
public class UdaFilter extends DelegatingFilterProxy {

	private static final Logger logger = LoggerFactory.getLogger(UdaFilter.class);
	private static final String validationPattern = "[\\p{L}0-9\\.,\\-\\+_:~\\(\\)\\\\/¿\\?@&%#\\$\\* ]*$";

	public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) {

		HttpServletRequest httpServletRequest = (HttpServletRequest) request;
		HttpServletResponse httpServletResponse = (HttpServletResponse) response;

		// Comprueba si ha sido referido por algún sistema de seguridad de EJIE.
		final boolean refersFromSecuritySystem;
		if (httpServletRequest.getHeader("referer") != null) {
			// Soporta XLNetS (tanto Linux como Windows) y OAM.
			refersFromSecuritySystem = Pattern.compile(
					"xlnets\\.servicios(?:\\.des|\\.pru)?\\.(?:ejgv(?:\\.euskalsarea\\.eus|\\.jaso)?|jakina\\.ejie(?:des|pru)?\\.net)?"
							+ "|(?:desant01\\.|pruebasnt01\\.)?jakina.ejgvdns"
							+ "|sargune(?:\\.sb|\\.des|\\.pru)?\\.(?:euskadi|ejgv\\.euskalsarea)?\\.eus",
					Pattern.CASE_INSENSITIVE).matcher(httpServletRequest.getHeader("referer")).find();
			logger.debug("Referer is {} and the pattern result is {}", httpServletRequest.getHeader("referer"), refersFromSecuritySystem);
		} else {
			refersFromSecuritySystem = false;
			logger.debug("Referer is null. If a value was expected, check if the protocol is still the same.");
		}

		try {
			logger.debug("New request with UDA identificator {} has started", ThreadStorageManager.getCurrentThreadId());

			if (httpServletRequest.getHeader("RUP") != null) {
				ThreadSafeCache.addValue("RUP", "RUP");
				HashMap<?, ?> map = new ObjectMapper().readValue(httpServletRequest.getHeader("RUP"), HashMap.class);
				for (Entry<?, ?> entry : map.entrySet()) {
					ThreadSafeCache.addValue((String) entry.getKey(), (String) entry.getValue());
				}
			}

			if (httpServletRequest.getHeader("RUP_MULTI_ENTITY") != null) {
				ThreadSafeCache.addValue("RUP_MULTI_ENTITY", "RUP_MULTI_ENTITY");
			}

			// Determina si la sesión tiene parámetros.
			final boolean sessionHasParams;
			if (httpServletRequest.getParameterMap().isEmpty() || (httpServletRequest.getParameterMap().size() == 1)) {
				sessionHasParams = false;
			} else {
				sessionHasParams = true;
			}

			if (sessionHasParams) {
				// Si se cumplen las condiciones, se procederá a validar y almacenar en sesión los parámetros recibidos.
				// Esta gestión es necesaria para disponer de los datos una vez se obtenga una credencial válida a través del sistema de seguridad.
				if (SecurityContextHolder.getContext().getAuthentication() == null && !refersFromSecuritySystem) {
					Map<String, String[]> extraParams = new HashMap<String, String[]>();

					// Validar parámetros recibidos para evitar un "Trust boundary".
					for (Map.Entry<String, String[]> entry : ((Map<String, String[]>) httpServletRequest.getParameterMap()).entrySet()) {
						if (entry.getValue().length > 1) {
							List<String> values = new ArrayList<String>();
							for (int index = 0; index < entry.getValue().length; index++) {
								if (entry.getValue()[index].matches(validationPattern)) {
									values.add(entry.getValue()[index]);
									logger.debug("Added parameter with key {} and value {} from index {}", entry.getKey(), entry.getValue()[index], index);
								} else {
									logger.debug(
											"Parameter with key {} and value {} in index {} does not match the pattern",
											entry.getKey(), entry.getValue()[index], index);
								}
							}
							extraParams.put(entry.getKey(), values.toArray(new String[0]));
						} else {
							if (entry.getValue()[0].matches(validationPattern)) {
								extraParams.put(entry.getKey(), entry.getValue());
								logger.debug("Added parameter with key {} and value {}", entry.getKey(), entry.getValue()[0]);
							} else {
								logger.debug("Parameter with key {} and value {} does not match the pattern", entry.getKey(), entry.getValue()[0]);
							}
						}
					}

					// Se guardan los parámetros en sesión para disponer de ellos una vez se obtenga la credencial.
					httpServletRequest.getSession().setAttribute("REQUESTED_PARAMS", extraParams);
					httpServletRequest.getSession().setAttribute("REQUEST_METHOD", httpServletRequest.getMethod());
				}
			}

			// Cuando la sesión contenga los parámetros que se guardaron al llegar a la aplicación y el referido sea el sistema de seguridad,
			// se procederá a insertar esos datos en la petición o en caso de ser una petición de tipo GET, en el query string de la misma.
			if (httpServletRequest.getSession().getAttribute("REQUESTED_PARAMS") != null
					&& httpServletRequest.getSession().getAttribute("REQUEST_METHOD") != null
					&& refersFromSecuritySystem) {
				if (httpServletRequest.getSession().getAttribute("REQUEST_METHOD").equals("GET")) {
					UriComponentsBuilder url = UriComponentsBuilder.fromUriString(httpServletRequest.getRequestURL().toString());

					for (Entry<String, String[]> entry : ((Map<String, String[]>) httpServletRequest.getSession().getAttribute("REQUESTED_PARAMS")).entrySet()) {
						if (entry.getValue().length > 1) {
							for (String entryValue : entry.getValue()) {
								url.queryParam(entry.getKey(), entryValue);
							}
						} else {
							url.queryParam(entry.getKey(), entry.getValue()[0]);
						}
					}

					logger.debug("A redirection will happen because both REQUESTED_PARAMS and REQUEST_METHOD (with GET value) exist in session");
					httpServletResponse.sendRedirect(url.build().toUriString());
				} else {
					logger.debug(
							"Request will be wrapped using WrappedRequest because both REQUESTED_PARAMS and REQUEST_METHOD (with {} value) exist in session",
							httpServletRequest.getSession().getAttribute("REQUEST_METHOD"));
					filterChain.doFilter(
							new WrappedRequest(httpServletRequest,
									(Map<String, String[]>) httpServletRequest.getSession()
											.getAttribute("REQUESTED_PARAMS"),
									httpServletRequest.getSession().getAttribute("REQUEST_METHOD").toString()),
							response);
				}
			} else {
				logger.debug("Request won't be wrapped");
				filterChain.doFilter(request, response);
			}

			logger.debug("Request with UDA identificator {} has ended", ThreadStorageManager.getCurrentThreadId());
		} catch (Exception exception) {
			logger.error(StackTraceManager.getStackTrace(exception));

			try {
				if (!response.isCommitted()) {
					StringBuilder error = new StringBuilder(httpServletRequest.getContextPath());
					error.append("/error?exception_name=").append(exception.getClass().getName());
					error.append("&exception_message=").append(exception.getMessage());
					error.append("&exception_trace=");
					int outLength = error.length();

					for (StackTraceElement trace : exception.getStackTrace()) {
						outLength = outLength + 5 + trace.toString().length();
						// IE Query String limit
						if (outLength <= 2043) {
							error.append(trace.toString()).append("</br>");
						} else {
							break;
						}
					}

					httpServletResponse.sendRedirect(error.toString());
				}
			} catch (Exception exc) {
				logger.error("Problem with sending of the response", exc);
			}
		} finally {
			ThreadStorageManager.clearCurrentThreadId();
			ThreadSafeCache.clearCurrentThreadCache();

			// Eliminar los parámetros que se hayan podido ingresar en la sesión antes de la obtención de una credencial.
			if (refersFromSecuritySystem) {
				httpServletRequest.getSession().removeAttribute("REQUESTED_PARAMS");
				httpServletRequest.getSession().removeAttribute("REQUEST_METHOD");
				logger.debug("Eliminados los atributos REQUESTED_PARAMS y REQUEST_METHOD porque ya han sido usados.");
			}
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/UdaListener.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;
import javax.servlet.ServletRequest;
import javax.servlet.ServletRequestEvent;
import javax.servlet.ServletRequestListener;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;
import javax.servlet.http.HttpSessionEvent;
import javax.servlet.http.HttpSessionListener;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextImpl;

import com.ejie.x38.log.LogConstants;
import com.ejie.x38.security.Credentials;
import com.ejie.x38.util.ManagementUrl;

/**
 * 
 * Listener de UDA que se encarga de lo siguiente:
 * 1- Facilita la gestión de logs de las peticiones entrantes
 * 2- Gestiona el Timestamp que se vincula a las sesiones para gestionar el refresco de XLNetS
 *  
 * @author UDA
 * 
 */
public class UdaListener implements ServletContextListener, HttpSessionListener, ServletRequestListener{
	
	Logger logger =  LoggerFactory.getLogger(UdaListener.class);
	
	@Override
	public void contextDestroyed(ServletContextEvent arg0) {
		//logger.debug( "WAR Context is being destroyed");
	}

	@Override
	public void contextInitialized(ServletContextEvent servletContextEvent) {
		logger.debug("WAR Context is being initialized");
	}

	@Override
	public void sessionCreated(HttpSessionEvent sessionEvent) {
		logger.debug( "Session "+sessionEvent.getSession().getId()+" has been created");
		sessionEvent.getSession().setAttribute("udaTimeStamp", System.currentTimeMillis());
	}

	@Override
	public void sessionDestroyed(HttpSessionEvent sessionEvent) {
		logger.debug( "Session "+sessionEvent.getSession().getId()+" has been destroyed");
		
//		HttpSession session = sessionEvent.getSession();
//        ApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(session.getServletContext());
//        StockUdaSecurityPadlocksImpl stockUdaSecurityPadlocks = (StockUdaSecurityPadlocksImpl)ctx.getBean("stockUdaSecurityPadlocks");
//		stockUdaSecurityPadlocks.deleteCredentialLoadObject(sessionEvent.getSession().getId());
		
		sessionEvent.getSession().removeAttribute("udaTimeStamp");
	}
	
	@Override
	//Called when the servlet request is going of scope.
	public void requestInitialized(ServletRequestEvent sre){
		
		ServletRequest request = sre.getServletRequest();
		HttpServletRequest httpServletRequest = null;
		StringBuilder logMessage = new StringBuilder();
		HttpSession httpSession = null;
		
		SecurityContextImpl securityContext  = null;
		Credentials credentials = null; 
		Authentication authentication = null;
		
	    //Used to get the IP of the new request for the loggin System  
		MDC.put("IPClient", request.getRemoteAddr());
		//Flag to mark http acces
		MDC.put(LogConstants.NOINTERNALACCES, LogConstants.ACCESSTYPEHTTP);
		
		if (request instanceof HttpServletRequest){
			
			httpServletRequest =(HttpServletRequest) request;
			
			if (httpServletRequest.getSession(false) != null){
				httpSession = ((HttpServletRequest) request).getSession(false);
				
				//Getting Authentication credentials
				securityContext = ((SecurityContextImpl)httpSession.getAttribute("SPRING_SECURITY_CONTEXT"));
				
				if (securityContext != null){					
					authentication = securityContext.getAuthentication();
					if (authentication != null){
						credentials = (Credentials)authentication.getCredentials();
					}
				}				
				
				if(credentials != null){
					MDC.put(LogConstants.USER,credentials.getUserName());
					MDC.put(LogConstants.SESSION,credentials.getUidSession());
					MDC.put(LogConstants.POSITION,credentials.getPosition());
					
				} else if (httpSession.getAttribute("UserName") != null){
					MDC.put(LogConstants.USER,(String)httpSession.getAttribute("UserName"));
					MDC.put(LogConstants.SESSION,(String)httpSession.getAttribute("UidSession"));
					MDC.put(LogConstants.POSITION,(String)httpSession.getAttribute("Position"));
				}
			}
			
			//Compose the acceses trace logs
			logMessage.append("The application has just received a HTTP request from the IP ");
			logMessage.append(request.getRemoteAddr());
			logMessage.append(" to the URL ");
			logMessage.append(ManagementUrl.getUrl(httpServletRequest));
		} else {
			logMessage.append("The application has just received a non-HTTP request from the IP ");
			logMessage.append(request.getRemoteAddr());
		}
		logger.info(logMessage.toString());
	}
	
	@Override
	//Called when the servlet request is going out of scope.
	public void requestDestroyed(ServletRequestEvent sre){
		
		ServletRequest request = sre.getServletRequest();
		HttpServletRequest httpServletRequest = null;
		StringBuilder logMessage = new StringBuilder();
		
		if (request instanceof HttpServletRequest){
			
			httpServletRequest =(HttpServletRequest) request;
			
			//Compose the acceses trace logs
			logMessage.append("The application has responded a HTTP request from the IP ");
			logMessage.append(request.getRemoteAddr());
			logMessage.append(" to the URL ");
			logMessage.append(ManagementUrl.getUrl(httpServletRequest));
		} else {
			logMessage.append("The application has responded a non-HTTP request from the IP ");
			logMessage.append(request.getRemoteAddr());
		}
		
		logger.info(logMessage.toString());
		
		//Clear MDC log Context
		MDC.clear();	  
	}//requestDestroyed
	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/aop/MainAdvice.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.aop;

import org.aspectj.lang.ProceedingJoinPoint;

import com.ejie.x38.log.IncidenceLoggingAdvice;
import com.ejie.x38.log.LoggingAdvice;

/**
 * 
 * Advice principal que se encarga de gestionar toda la informacion interceptada por los PointCuts.
 * Actualmente solo se usa para el aspecto de Logging.
 * 
 * @author UDA
 * 
 */
public class MainAdvice {
		
		private LoggingAdvice filterLoggingAdvice;
		private LoggingAdvice serviceLoggingAdvice;
		private LoggingAdvice daoLoggingAdvice;
		private IncidenceLoggingAdvice incidenceLoggingAdvice;

		/**
		 * MainAdvice que se ejecuta alrededor de llamadas a un filtro, de tal manera que loguea 
		 * la peticion y la respuesta de este.
		 * @param call Llamada interceptada.
		 * @return Retorno de la llamada interceptada.
		 * @throws Throwable Throwable Excepcion que se deja pasar, en caso de que el Target la genere.
		 */
		public Object filterCall(ProceedingJoinPoint call) throws Throwable {
			filterLoggingAdvice.preLogging(call);
			Object ret = call.proceed();	
			filterLoggingAdvice.postLogging(call, ret);			
			return ret;
		}
		
		/**
		 * MainAdvice que se ejecuta alrededor de llamadas a servicios, de tal manera que loguea 
		 * la peticion y la respuesta de estas.
		 * 
		 * @param call Llamada interceptada.
		 * @return Retorno de la llamada interceptada.
		 * @throws Throwable Excepcion que se deja pasar, en caso de que el Target la genere.
		 */
		public Object serviceLogCall(ProceedingJoinPoint call) throws Throwable {
			serviceLoggingAdvice.preLogging(call);
			Object ret = call.proceed();	
			serviceLoggingAdvice.postLogging(call, ret);
			return ret;
		}			
		
		/**
		 * MainAdvice que loguea las llamadas a los DAOs, registrando los valores de entrada y salida.
		 * 
		 * @param call Llamada interceptada.
		 * @return Retorno de la llamada interceptada.
		 * @throws Throwable Throwable Excepcion que se deja pasar, en caso de que el Target la genere.
		 */
		public Object daoLogCall(ProceedingJoinPoint call) throws Throwable {
			daoLoggingAdvice.preLogging(call);
			Object ret = call.proceed();	
			daoLoggingAdvice.postLogging(call, ret);
			return ret;
		}
		
		/**
		 * Advice que se encarga de loguear las excepciones no controladas.
		 * 
		 * @param target Clase que lanza la excepcion no controlada.
		 * @param exception Excepcion capturada.
		 */
		public void logIncidence (Object target, Exception exception){
			incidenceLoggingAdvice.logIncidence(target, exception);
		}
		
		//Getters & Setters

		public void setFilterLoggingAdvice(LoggingAdvice filterLoggingAdvice) {
			this.filterLoggingAdvice = filterLoggingAdvice;
		}

		public LoggingAdvice getServiceLoggingAdvice() {
			return serviceLoggingAdvice;
		}

		public void setServiceLoggingAdvice(LoggingAdvice serviceLoggingAdvice) {
			this.serviceLoggingAdvice = serviceLoggingAdvice;
		}

		public LoggingAdvice getDaoLoggingAdvice() {
			return daoLoggingAdvice;
		}

		public void setDaoLoggingAdvice(LoggingAdvice daoLoggingAdvice) {
			this.daoLoggingAdvice = daoLoggingAdvice;
		}

		public IncidenceLoggingAdvice getIncidenceLoggingAdvice() {
			return incidenceLoggingAdvice;
		}

		public void setIncidenceLoggingAdvice(IncidenceLoggingAdvice incidenceLoggingAdvice) {
			this.incidenceLoggingAdvice = incidenceLoggingAdvice;
		}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/MvcInterceptor.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.control;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;

import javax.annotation.PostConstruct;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.handler.HandlerInterceptorAdapter;
import org.springframework.web.servlet.i18n.CookieLocaleResolver;
import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;
import org.springframework.web.servlet.support.RequestContextUtils;

import com.ejie.x38.util.StaticsContainer;

/**
 *
 * Interceptor de UDA que se encarga de lo siguiente:
 * 1- Gestiona las variables relativas a idioma por defecto, idiomas de la aplicación y layout. En caso de no
 * definir alguna de las variables se producirá un error en despliegue indicando la causa del error.
 * 2- En la invocación a un controller gestiona las cookie y el parámetro para la gestión del lenguage de la
 * aplicación
 * 3- En el retorno de un controller se gestiona la variable del modelo para el layout
 * 
 * @author UDA
 *
 */
public class MvcInterceptor extends HandlerInterceptorAdapter{
   
    @Autowired
    private WebApplicationContext webApplicationContext;

    /**
     * Comprobar que se han definido correctamente las variables necesarias para la aplicación:
     * - defaultLanguage : Idioma por defecto
     * - defaulLayout : Layout por defecto
     * - availableLangs: Idiomas permitidos en la aplicación
     */
    @PostConstruct
    public void postConstruct(){
        List<String> properties = new ArrayList<String>();
        if (this.defaultLanguage==null){
            properties.add("defaultLanguage");
        }
        if (this.defaultLayout==null){
            properties.add("defaultLayout");
        }
        if (this.availableLangs==null){
            properties.add("availableLangs");
        }
        if (!properties.isEmpty()){
            String war = webApplicationContext.getServletContext().getContextPath().substring(1);
            throw new IllegalStateException("No se ha definido correctamente el bean 'MvcInterceptor' en el fichero mvc-config.xml del proyecto <"+war+">. Revisar propiedad(es):"+properties.toString());
        }
    }

    /**
     * Método que se ejecuta antes del método del Controller
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
    	// Asignar valor por defecto.
    	Locale locale = new Locale(defaultLanguage);
    	// Obtener cookies de la sesión.
        Cookie[] cookies = request.getCookies();
        // Indica si se usará la cookie del portal.
        boolean usesPortalCookie = false;
        
        if (portalCookie != null && cookies != null) {
            // Idioma controlado por el portal.
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(portalCookie)){
                	String cookieValue = cookie.getValue();
                    // Comprobar si la variable cookieValue contiene algún valor, en caso negativo, se mantiene el valor por defecto.
                    if (cookieValue != null && !cookieValue.isEmpty()) {
                    	String portalCookieValue = cookieValue.substring((cookieValue.indexOf("_") + 1));
                    	// Verificar si el idioma obtenido está entre los soportados.
                    	if (availableLangs.contains(portalCookieValue)) {
                        	locale = new Locale(portalCookieValue);
                        	usesPortalCookie = true;                    		
                    	}
                    }
                    break;
                }
            }
        } 

        if (!usesPortalCookie) {
            // Obtención a partir del parámetro de cambio de idioma.
            String languageParam = request.getParameter(paramName);
            if (languageParam != null && availableLangs.contains(languageParam)){
                locale = new Locale(languageParam);
            } else {
            	// Obtención a partir de la cookie de idioma de la sesión.
                String cookieName = ((CookieLocaleResolver) RequestContextUtils.getLocaleResolver(request)).getCookieName();
                Cookie cookie = getLanguageCookie(request.getCookies(), cookieName, Arrays.asList(availableLangs.trim().split("\\s*,\\s*")));
                if (cookie != null){
                    locale = new Locale(cookie.getValue());
                }
            }
        }
       
        // Modificación de la Locale y Cookie.
        LocaleContextHolder.setLocale(locale, StaticsContainer.isInheritableLocalContext());
        // Sobrescribir cookie de idioma.
        CookieLocaleResolver cookieLanguage = (CookieLocaleResolver) RequestContextUtils.getLocaleResolver(request);
        cookieLanguage.setLocale(request, response, locale);
        // Permite su acceso desde JavaScript.
        cookieLanguage.setCookieHttpOnly(false);
        // Gestionar la securización.
        cookieLanguage.setCookieSecure(StaticsContainer.isCookieSecure());
        // Establecer política SameSite.
        cookieLanguage.setCookiePath(
        		(StaticsContainer.isCookiePathRoot() ? "/" : webApplicationContext.getServletContext().getContextPath())
					+ "; SameSite=Lax;");

        return true;
    }
       
    /**
     * Función que busca la cookie de idioma y determina si es idioma válido (devuelve la cookie)
     * @param cookies Conjunto de cookies de la request
     * @param cookieName Nombre de la cookie de idioma (default 'language')
     * @param availableLangs Lista con los idiomas posibles (es, eu, en, fr)
     * @return Si es un idioma válido devuelve la cookie, si no devuelve null
     */
    private Cookie getLanguageCookie(Cookie cookies[], String cookieName, List<String> availableLangs){
        if (cookies != null){
            for (Cookie cookie : cookies) {
                if (cookie.getName().equals(cookieName) && availableLangs.contains(cookie.getValue())){
                    return cookie;
                }
            }
        }
        return null;
    }
   
    //** SETTERs & GETTERs **//
    private String paramName = LocaleChangeInterceptor.DEFAULT_PARAM_NAME;
    public void setParamName(String paramName) {
        this.paramName = paramName;
    }
    public String getParamName(){
        return this.paramName;
    }
   
    private String defaultLanguage;
    public String getDefaultLanguage() {
        return defaultLanguage;
    }
    public void setDefaultLanguage(String defaultLanguage) {
        this.defaultLanguage = defaultLanguage;
    }
   
    private String defaultLayout;
    public String getDefaultLayout() {
        return defaultLayout;
    }
    public void setDefaultLayout(String defaultLayout) {
        this.defaultLayout = defaultLayout;
    }
   
    private String availableLangs;
    public String getAvailableLangs() {
        return availableLangs;
    }
    public void setAvailableLangs(String availableLangs) {
        this.availableLangs = availableLangs;
    }

    private String portalCookie;
    public String getPortalCookie() {
        return portalCookie;
    }
    public void setPortalCookie(String portalCookie) {
        this.portalCookie = portalCookie;
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/bind/annotation/Json.java
================================================
package com.ejie.x38.control.bind.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import com.ejie.x38.json.JsonMixin;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Json {

    /**
     * A list of Jackson Mixins.
     * <p>
     * {@link http://wiki.fasterxml.com/JacksonMixInAnnotations}
     */
    JsonMixin[] mixins() default {};

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/bind/annotation/RequestJsonBody.java
================================================
package com.ejie.x38.control.bind.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

import org.springframework.http.MediaType;

@Target(ElementType.PARAMETER)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RequestJsonBody {

	String param() default "param";
	
	Class<?> clazz() default Object.class;
	
	String value() default "args";
	
	String contentType() default MediaType.APPLICATION_JSON_VALUE;

	boolean required() default true;	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/FileExceedsFileSizeLimitHandler.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.control.exception;

import java.io.IOException;
import java.util.Locale;
import java.util.Map;

import javax.annotation.Resource;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.multipart.MaxUploadSizeExceededException;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.ModelAndView;

import com.ejie.x38.control.exception.handler.MvcExceptionHandlerHelper;
import com.ejie.x38.json.JSONObject;
import com.ejie.x38.validation.ValidationManager;

/**
 * Handler utilizado para gestionar la excepción producida por superar el tamaño
 * máximo de envío de un fichero.
 * 
 * @author UDA
 * 
 */
public class FileExceedsFileSizeLimitHandler implements HandlerExceptionResolver{
	
	private static final Logger logger = LoggerFactory.getLogger(FileExceedsFileSizeLimitHandler.class);
	
	@Resource
	private ReloadableResourceBundleMessageSource messageSource;
	
	@Autowired
	private ValidationManager validationManager;
	
	
	
	@Override
	
	@ExceptionHandler(value=MaxUploadSizeExceededException.class)
	public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response,
			Object handler, Exception ex) {
		if ( ex instanceof MaxUploadSizeExceededException ) {
			try {
				
				Locale locale = LocaleContextHolder.getLocale();
				String messageError = messageSource.getMessage(MaxUploadSizeExceededException.class.getSimpleName(), null, locale);
				Map<String, Object> rupFeedbackMsg = validationManager.getRupFeedbackMsg(messageError, "error");
				JSONObject messageJSON = validationManager.getMessageJSON(null, rupFeedbackMsg, "error");
				String content = messageJSON.toString();
				// Se comprueba si es necesario tratar el error de acuerdo a lo requerido por la emulación de iframe.
				
				return new MvcExceptionHandlerHelper().processException(ex, request, response, content, HttpServletResponse.SC_REQUEST_ENTITY_TOO_LARGE);
				
				
			} catch (IOException e) {
				logger.error(e.getMessage());
				throw new RuntimeException(e);
			}
		}
		return null;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/IframeXHREmulationException.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.control.exception;

/**
 * 
 * Excepción del componente IframeXHREmulation
 * 
 * @author UDA
*/
public class IframeXHREmulationException extends RuntimeException{
	protected Throwable throwable;
	private static final long serialVersionUID = 1L;

	public IframeXHREmulationException(String message) {
		super(message);
	}

	public IframeXHREmulationException(String message, Throwable throwable) {
		super(message);
		this.throwable = throwable;
	}

	public IframeXHREmulationException(Throwable cause) {
		super(cause);
	}

	public Throwable getCause() {
		return throwable;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/MvcExceptionResolver.java
================================================
package com.ejie.x38.control.exception;

import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;

import org.springframework.web.method.HandlerMethod;
import org.springframework.web.method.annotation.ExceptionHandlerMethodResolver;
import org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver;
import org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod;

/**
 * 
 * Clase encargada del sobreescribir la gestión de las excepciones permitiendo que estas puedan 
 * ser capturadas fuera del Controller (las gestionará MvcExceptionHandler) mediante la anotación
 * @ExceptionHandler
 * 
 * @author UDA
 *
 */
public class MvcExceptionResolver extends ExceptionHandlerExceptionResolver {

	private List<Object> handlers;
	private List<ExceptionHandlerMethodResolver> methodResolvers;

	/**
	 * Establecer el handler de la excepción (MvcExceptionHandler)
	 * @param handler 
	 */
	public void setExceptionHandlers(List<Object> handlers) {
		this.handlers = handlers;
		List<ExceptionHandlerMethodResolver> methodResolvers = new ArrayList<ExceptionHandlerMethodResolver>();
		for (Object object : handlers){
			methodResolvers.add(new ExceptionHandlerMethodResolver(object.getClass()));
		}
		this.methodResolvers = methodResolvers;
	}
	
	/**
	 * En caso de que el Controller no disponga de método para gestionar la excepción se cede el control
	 * al MvcExceptionHandler para que gestione él la excepción
	 */
	@Override
	protected ServletInvocableHandlerMethod getExceptionHandlerMethod(HandlerMethod handlerMethod, Exception exception) {
		ServletInvocableHandlerMethod result = super.getExceptionHandlerMethod(handlerMethod, exception);
		if (result != null) {
			return result;
		}
		int index = 0;
		for (ExceptionHandlerMethodResolver exceptionHandlerMethodResolver : this.methodResolvers){
			Method method = exceptionHandlerMethodResolver.resolveMethod(exception);
			if (method != null){
				return new ServletInvocableHandlerMethod(handlers.get(index), method);
			}
			index++;
		}
		return null;
		
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/MvcExceptionResolverConfig.java
================================================
package com.ejie.x38.control.exception;

import java.util.ArrayList;
import java.util.List;

import javax.annotation.PostConstruct;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.servlet.HandlerExceptionResolver;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;

import com.ejie.x38.control.exception.handler.MvcAccessDeniedExceptionHandler;
import com.ejie.x38.control.exception.handler.MvcExceptionHandler;
import com.ejie.x38.control.exception.handler.MvcValidationExceptionHandler;
import com.ejie.x38.validation.ValidationManager;

/**
 * 
 * Clase encargada del configurar el gestor general de excepciones (MvcExceptionResolver) para que 
 * redirija las excepciones no capturadas en el Controller a la clase MvcExceptionHandler
 * 
 * @author UDA
 *
 */
@Configuration
public class MvcExceptionResolverConfig extends WebMvcConfigurationSupport { 

	@Autowired
	private WebApplicationContext webApplicationContext;
	
	/**
	 * Lista de handlers definida por la aplicación
	 */
	 private List<Object> handlers = new ArrayList<Object>();
	 public void setHandlers(List<Object> handlers) {
		 this.handlers = handlers;
	 }
	 
	 /**
	  * Determina si debe aplicarse MvcAccessDeniedExceptionHandler
	  */
	private boolean disable_accessDenied;
	public void setDisable_accessDenied(boolean disable_accessDenied) {
		this.disable_accessDenied = disable_accessDenied;
	}


	/**
	 * Determina si debe aplicarse MvcValidationExceptionHandler 
	 */
	private boolean disable_validation;
	public void setDisable_validation(boolean disable_validation) {
		this.disable_validation = disable_validation;
	}
	

	 
	 
	/**
	 * Comprobar que se han definido correctamente las variables necesarias para el resolver:
	 */
	@PostConstruct
	public void postConstruct(){
		String war = webApplicationContext.getServletContext().getContextPath().substring(1);
		try {
			webApplicationContext.getBean("requestMappingHandlerAdapter");
		} catch (Exception e) {
			throw new IllegalStateException("No se puede crear el bean 'MvcExceptionResolverConfig' en el fichero mvc-config.xml del proyecto <"+war+">. Falta definir el bean 'requestMappingHandlerAdapter' de tipo 'RequestMappingHandlerAdapter'");
		}
		try {
			webApplicationContext.getBean("messageSource");
		} catch (Exception e) {
			throw new IllegalStateException("No se puede crear el bean 'MvcExceptionResolverConfig' en el fichero mvc-config.xml del proyecto <"+war+">. Falta definir el bean 'messageSource' de tipo 'ReloadableResourceBundleMessageSource'");
		}
		try {
			webApplicationContext.getBean("validationManager");
		} catch (Exception e) {
			throw new IllegalStateException("No se puede crear el bean 'MvcExceptionResolverConfig' en el fichero validation-config.xml del proyecto <"+war+">. Falta definir el bean 'validationManager' de tipo 'com.ejie.x38.validation.ValidationManager'");
		}
	}
	
	/**
	 * Se recuperan los messageConverters definidos para la aplicación y se asocian al MvcExceptionResolver
	 */
	 @Override
	 public void configureMessageConverters (List<HttpMessageConverter<?>> converters){
		 RequestMappingHandlerAdapter requestMethodHandlerAdapter = (RequestMappingHandlerAdapter)webApplicationContext.getBean(RequestMappingHandlerAdapter.class);
		 for (HttpMessageConverter<?> httpMessageConverter : requestMethodHandlerAdapter.getMessageConverters()) {
			 converters.add(httpMessageConverter);
		 }
	 }
	 
	/**
	 * Configura MvcExceptionHandler como un elemento para la resolución de excepciones
	 */
	@Override
	public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> exceptionResolvers) {
		MvcExceptionResolver customResolver = new MvcExceptionResolver();
		List<Object> exceptionHandlers = this.handlers;
		
		//Handlers de UDA
		if (!disable_validation){
			ValidationManager validationManager = (ValidationManager)webApplicationContext.getBean("validationManager");
			exceptionHandlers.add(0, new MvcValidationExceptionHandler(validationManager));
		}
		ReloadableResourceBundleMessageSource messageSource = (ReloadableResourceBundleMessageSource)webApplicationContext.getBean("messageSource");
		if (!disable_accessDenied){
			exceptionHandlers.add(0, new MvcAccessDeniedExceptionHandler(messageSource));
		}
		exceptionHandlers.add(new MvcExceptionHandler(messageSource));
		
		customResolver.setExceptionHandlers(exceptionHandlers);
		customResolver.setMessageConverters(getMessageConverters());
		customResolver.afterPropertiesSet();
		exceptionResolvers.add(customResolver);
	}

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/handler/MvcAccessDeniedExceptionHandler.java
================================================
package com.ejie.x38.control.exception.handler;

import java.io.IOException;
import java.util.Locale;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;

/**
 * 
 * Clase encargada del tratamiento por defecto de las excepciones propagadas por un Controller
 * relacionadas con problemas de acceso 
 * 
 * @author UDA
 *
 */
public class MvcAccessDeniedExceptionHandler {

	private ReloadableResourceBundleMessageSource messageSource;
	
	/**
	 * 
	 * @param messageSource
	 */
	public MvcAccessDeniedExceptionHandler(ReloadableResourceBundleMessageSource messageSource) {
		this.messageSource = messageSource;
	}
	
	/**
	 * Gestor por defecto de los errores de permisos de acceso
	 * @param accessDeniedException
	 * @param request
	 * @param response
	 * @return
	 * @throws IOException
	 */
	@ExceptionHandler(value=AccessDeniedException.class)
	public ModelAndView handleAccessDeniedException (AccessDeniedException accessDeniedException, HttpServletRequest request, HttpServletResponse response) throws IOException {
		Locale locale = LocaleContextHolder.getLocale();
		String exceptionClassName = accessDeniedException.getClass().getSimpleName();
		
		String content = messageSource.getMessage(exceptionClassName, null, accessDeniedException.getMessage(), locale);
		
		return new MvcExceptionHandlerHelper().processException(accessDeniedException, request, response, content, HttpServletResponse.SC_UNAUTHORIZED);
		
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/handler/MvcExceptionHandler.java
================================================
package com.ejie.x38.control.exception.handler;

import java.io.IOException;
import java.util.Locale;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;

/**
 * 
 * Clase encargada del tratamiento por defecto de las excepciones propagadas por un Controller
 * 
 * @author UDA
 *
 */
public class MvcExceptionHandler {

	private ReloadableResourceBundleMessageSource messageSource;
	
	/**
	 * 
	 * @param messageSource
	 */
	public MvcExceptionHandler(ReloadableResourceBundleMessageSource messageSource) {
		this.messageSource = messageSource;
	}
	
	/**
	 * Gestor por defecto de Excepciones
	 * @param exception
	 * @param request 
	 * @param response
	 * @return
	 * @throws IOException
	 */
	@ExceptionHandler
	public ModelAndView handleException (Exception exception, HttpServletRequest request, HttpServletResponse response) throws IOException {
		Locale locale = LocaleContextHolder.getLocale();
		String exceptionClassName = exception.getClass().getSimpleName();
		String content = messageSource.getMessage(exceptionClassName, null, exception.getMessage(), locale);
		
		return new MvcExceptionHandlerHelper().processException(exception, request, response, content, HttpServletResponse.SC_NOT_ACCEPTABLE);

	}
	
	/**
	 * Gestor de las excepciones NO-AJAX para los handlers
	 * @param exception
	 * @param request
	 * @param response
	 * @return
	 */
	public static ModelAndView handle(Exception exception, HttpServletRequest request, HttpServletResponse response){
		//Non-AJAX request
		ModelAndView modelAndView = new ModelAndView();
		modelAndView.setViewName("error");
		modelAndView.addObject("exception_name", exception.getClass().getName());
		modelAndView.addObject("exception_message", exception.getMessage());
		StringBuilder sbTrace = new StringBuilder();
		for (StackTraceElement trace : exception.getStackTrace()) {
			sbTrace.append(trace.toString()).append("</br>");
		}
		modelAndView.addObject("exception_trace", sbTrace);
		return modelAndView;
	}
	
	/**
	 * Gestor de las excepciones por acceso denegado.
	 * @param exception
	 * @param request
	 * @param response
	 * @return
	 */
	public static ModelAndView handleAccessDenied(Exception exception, HttpServletRequest request, HttpServletResponse response){
		request.setAttribute("SPRING_SECURITY_403_EXCEPTION", exception);
		response.setStatus(HttpServletResponse.SC_FORBIDDEN);
		
		ModelAndView modelAndView = new ModelAndView();
		modelAndView.setViewName("accessDenied");
		modelAndView.addObject("exception_name", exception.getClass().getName());
		modelAndView.addObject("exception_message", exception.getMessage());
		StringBuilder sbTrace = new StringBuilder();
		for (StackTraceElement trace : exception.getStackTrace()) {
			sbTrace.append(trace.toString()).append("</br>");
		}
		modelAndView.addObject("exception_trace", sbTrace);
		return modelAndView;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/handler/MvcExceptionHandlerHelper.java
================================================
package com.ejie.x38.control.exception.handler;

import java.io.IOException;
import java.nio.charset.Charset;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.servlet.ModelAndView;

import com.ejie.x38.util.IframeXHREmulationUtils;

public class MvcExceptionHandlerHelper {

	public ModelAndView processException(Exception ex, 
			HttpServletRequest request, HttpServletResponse response,
			String content, int statusCode) throws IOException {

		if (this.isIframeEmulated(request)){
//			response.setContentType("text/html");
//			response.setCharacterEncoding("UTF-8");
			this.writeToResponse(response, content, statusCode);
			
			return null;
			
		} else if (this.isAjax(request)) {
			//AJAX request;

			response.setContentLength(content.getBytes(Charset.forName(response.getCharacterEncoding())).length);
			this.writeToResponse(response, content, statusCode);
			
			return null;
		} else if(ex.getClass().equals(AccessDeniedException.class)) {
			return MvcExceptionHandler.handleAccessDenied(ex, request, response);
		} else{
			//Non-AJAX request
			return MvcExceptionHandler.handle(ex, request, response);
		}
		
	}
	
	protected boolean isIframeEmulated(HttpServletRequest request){
		
		return IframeXHREmulationUtils.isIframeEmulationRequired(request);
		
	}
	
	protected boolean isAjax(HttpServletRequest request){
		
		return request.getHeaders("X-Requested-With").hasMoreElements();
		
	}

	private void writeToResponse(HttpServletResponse response, String content, int statusCode) throws IOException{
		
		response.setStatus(statusCode);
		response.getWriter().write(content);
		response.flushBuffer();
		
	}
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/exception/handler/MvcValidationExceptionHandler.java
================================================
package com.ejie.x38.control.exception.handler;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.validation.BindException;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.servlet.ModelAndView;

import com.ejie.x38.validation.ValidationManager;

/**
 * 
 * Clase encargada del tratamiento por defecto de las excepciones propagadas por un Controller
 * relacionadas con problemas de validación
 * 
 * @author UDA
 *
 */
public class MvcValidationExceptionHandler {

	private ValidationManager validationManager;
	
	/**
	 * 
	 * @param validationManager
	 */
	public MvcValidationExceptionHandler(ValidationManager validationManager) {
		this.validationManager = validationManager;
	}
	
	/**
	 * Gestor por defecto de los errores en las validaciones mediante la anotacion Validated
	 * @param bindException
	 * @param request
	 * @param response
	 * @return
	 * @throws IOException
	 */
	@ExceptionHandler(value={MethodArgumentNotValidException.class})
	public ModelAndView handleMethodArgumentNotValidException (MethodArgumentNotValidException methodArgumentNotValidException, HttpServletRequest request, HttpServletResponse response) throws IOException {
		return this.processBindingResult(methodArgumentNotValidException, methodArgumentNotValidException.getBindingResult(), request, response);
	}
	
	@ExceptionHandler(value={BindException.class})
	public ModelAndView handleBindException (BindException bindException, HttpServletRequest request, HttpServletResponse response) throws IOException {
		return this.processBindingResult(bindException, bindException.getBindingResult(), request, response);
	}
	
	private ModelAndView processBindingResult (Exception exception, final BindingResult bindingResult, HttpServletRequest request, HttpServletResponse response) throws IOException {
		
		Map<String, List<String>> errorMap = validationManager.getErrorsAsMap(bindingResult);
		String content = validationManager.getMessageJSON(errorMap).toString();
		
		
		return new MvcExceptionHandlerHelper(){

			@Override
			protected boolean isAjax(HttpServletRequest request) {
				// TODO Auto-generated method stub
				return super.isAjax(request) && bindingResult.hasFieldErrors();
			}
			
		}.processException(exception, request, response, content, HttpServletResponse.SC_NOT_ACCEPTABLE);

	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/method/annotation/JsonMethodArgumentResolver.java
================================================
package com.ejie.x38.control.method.annotation;

import java.util.List;

import javax.validation.Validator;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.MethodParameter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;

import com.ejie.x38.control.bind.annotation.Json;

public class JsonMethodArgumentResolver implements HandlerMethodArgumentResolver {

    @Autowired
    private RequestMappingHandlerAdapter requestMappingHandlerAdapter;
    private RequestJsonBodyMethodProcessor requestFormEntityMethodProcessor = null;
    @Autowired
    private Validator validator;

    @Override
    public boolean supportsParameter(MethodParameter parameter) {

    	Class<?> paramType = parameter.getParameterType();
		if (parameter.hasParameterAnnotation(Json.class)) {
			return true;
		}
		
		return false;
    }

    private RequestResponseBodyMethodProcessor getRequestResponseBodyMethodProcessor() {

        if (requestFormEntityMethodProcessor == null) {
            List<HttpMessageConverter<?>> messageConverters = requestMappingHandlerAdapter.getMessageConverters();
            requestFormEntityMethodProcessor = new RequestJsonBodyMethodProcessor(messageConverters);
        }
        return requestFormEntityMethodProcessor;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
//    	MethodParameter methodParameter = new MethodParameter(parameter.getParameterAnnotation(RequestFormEntity.class).clazz().getDeclaredConstructor(),0);
    	
//    	Conventions.getVariableNameForParameter(parameter)
//    	webRequest.getParameterNames("usuario")
    	
//    	Object valueAux = getRequestResponseBodyMethodProcessor()
//                .resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    	
        Object value = getRequestResponseBodyMethodProcessor()
                .resolveArgument(parameter, mavContainer, webRequest, binderFactory);
        return value;
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/method/annotation/JsonMethodReturnValueHandler.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.control.method.annotation;

import java.io.IOException;
import java.nio.charset.Charset;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletResponse;


import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.springframework.core.MethodParameter;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.http.server.ServletServerHttpResponse;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.method.support.ModelAndViewContainer;

import com.ejie.x38.control.bind.annotation.Json;
import com.ejie.x38.json.JsonMixin;

/**
 *
 * Clase que permite la resolución de vistas en UDA sobreescribiendo la clase de Spring UrlBasedViewResolver
 * para incluir las siguientes propiedades para el acceso a beans mediante Expression Language ${...}.
 * - exposeContextBeansAsAttributes : Permite exponer todos los beans del contexto de Spring 
 * - exposedContextBeanNames : Permite exponer los beans del contexto de Spring definidos como parámetros
 * 
 * @author UDA
 * 
 */
public class JsonMethodReturnValueHandler implements HandlerMethodReturnValueHandler {

    public static final Charset DEFAULT_CHARSET = Charset.forName("UTF-8");

    public static final MediaType DEFAULT_MEDIA_TYPE = new MediaType("application", "json", DEFAULT_CHARSET);

    private boolean prefixJson = false;

    public void setPrefixJson(boolean prefixJson) {
        this.prefixJson = prefixJson;
    }

    /**
     * Converts Json.mixins() to a Map<Class, Class>
     *
     * @param jsonFilter Json annotation
     * @return Map of Target -> Mixin classes
     */
    protected Map<Class<?>, Class<?>> getMixins(Json jsonFilter) {

        Map<Class<?>, Class<?>> mixins = new HashMap<Class<?>, Class<?>>();

        if(jsonFilter != null) {
            for(JsonMixin jsonMixin : jsonFilter.mixins()) {
                mixins.put(jsonMixin.target(), jsonMixin.mixin());
            }
        }

        return mixins;
    }

    
    
    @Override
	public void handleReturnValue(Object arg0, MethodParameter methodParameter,
			ModelAndViewContainer mavContainer, NativeWebRequest nativeWebRequest) throws Exception {
		// TODO Auto-generated method stub
    	if (methodParameter.getMethod().getAnnotation(Json.class) != null ) {
    		mavContainer.setRequestHandled(true);
    		HttpOutputMessage httpRequest = this.getResponse(nativeWebRequest);
    		
    		ObjectMapper objectMapper = new ObjectMapper();
    		
    	
    		objectMapper.setMixIns(getMixins(methodParameter.getMethod().getAnnotation(Json.class)));
    		ServletOutputStream outputStream = ((ServletServerHttpResponse)httpRequest).getServletResponse().getOutputStream();
    		
    		 JsonGenerator jsonGenerator =
             objectMapper.getFactory().createGenerator(outputStream, JsonEncoding.UTF8);

           if (this.prefixJson) {
               jsonGenerator.writeRaw("{} && ");
           }

           objectMapper.writeValue(jsonGenerator, arg0);
           outputStream.flush();
           outputStream.close();

//    		this.writeInternal(objectMapper, arg0, httpRequest);
    	}
	}
    
    private void writeInternal(ObjectMapper objectMapper, Object object, HttpOutputMessage outputMessage) throws IOException, HttpMessageNotWritableException{
        JsonEncoding encoding = getJsonEncoding(outputMessage.getHeaders().getContentType());
        JsonGenerator jsonGenerator = objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding);
        try
        {
            if(prefixJson)
                jsonGenerator.writeRaw("{} && ");
            objectMapper.writeValue(jsonGenerator, object);
        }
        catch(JsonProcessingException ex)
        {
            throw new HttpMessageNotWritableException((new StringBuilder("Could not write JSON: ")).append(ex.getMessage()).toString(), ex);
        }
    }
    
    private JsonEncoding getJsonEncoding(MediaType contentType)
    {
        if(contentType != null && contentType.getCharset() != null)
        {
            Charset charset = contentType.getCharset();
            JsonEncoding ajsonencoding[];
            int j = (ajsonencoding = JsonEncoding.values()).length;
            for(int i = 0; i < j; i++)
            {
                JsonEncoding encoding = ajsonencoding[i];
                if(charset.name().equals(encoding.getJavaName()))
                    return encoding;
            }

        }
        return JsonEncoding.UTF8;
    }

	@Override
	public boolean supportsReturnType(MethodParameter methodParameter) {
		return methodParameter.getMethod().getAnnotation(Json.class) != null;
	}
	
	
//	private  ServletServerHttpRequest createInputMessage(NativeWebRequest webRequest)
//    {
//        return (HttpServletRequest)webRequest.getNativeRequest(HttpServletRequest.class);
//        return new ServletServerHttpRequest(servletRequest);
//    }
	
	private HttpOutputMessage getResponse(NativeWebRequest webRequest)
    {
		HttpServletResponse servletResponse = webRequest.getNativeResponse(HttpServletResponse.class);
        return new ServletServerHttpResponse(servletResponse);
    }

//	@Override
//    public ModelAndView resolveModelAndView(Method handlerMethod, Class handlerType, Object returnValue, ExtendedModelMap implicitModel, NativeWebRequest webRequest) {
//
//        if(handlerMethod.getAnnotation(Json.class) != null) {
//
//            try {
//
//                HttpServletResponse httpResponse = webRequest.getNativeResponse(HttpServletResponse.class);
//
//                httpResponse.setContentType(DEFAULT_MEDIA_TYPE.toString());
//
//                OutputStream out = httpResponse.getOutputStream();
//
//                ObjectMapper objectMapper = new ObjectMapper();
//
//                objectMapper.getSerializationConfig().setMixInAnnotations(getMixins(handlerMethod.getAnnotation(Json.class)));
//
//                JsonGenerator jsonGenerator =
//                        objectMapper.getJsonFactory().createJsonGenerator(out, JsonEncoding.UTF8);
//
//                if (this.prefixJson) {
//                    jsonGenerator.writeRaw("{} && ");
//                }
//
//                objectMapper.writeValue(jsonGenerator, returnValue);
//
//                out.flush();
//                out.close();
//
//                return null;
//
//            } catch (JsonProcessingException e) {
//                e.printStackTrace();
//            } catch (IOException e) {
//                e.printStackTrace();
//            }
//        }
//
//        return UNRESOLVED;
//    }

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/method/annotation/RequestJsonBodyMethodArgumentResolver.java
================================================
package com.ejie.x38.control.method.annotation;

import java.util.List;

import javax.validation.Validator;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.MethodParameter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;

import com.ejie.x38.control.bind.annotation.RequestJsonBody;

public class RequestJsonBodyMethodArgumentResolver implements HandlerMethodArgumentResolver {

    @Autowired
    private RequestMappingHandlerAdapter requestMappingHandlerAdapter;
    private RequestJsonBodyMethodProcessor requestFormEntityMethodProcessor = null;
    @Autowired
    private Validator validator;

    @Override
    public boolean supportsParameter(MethodParameter parameter) {

    	Class<?> paramType = parameter.getParameterType();
		if (parameter.hasParameterAnnotation(RequestJsonBody.class)) {
			return true;
		}
		
		return false;
    }

    private RequestResponseBodyMethodProcessor getRequestResponseBodyMethodProcessor() {

        if (requestFormEntityMethodProcessor == null) {
            List<HttpMessageConverter<?>> messageConverters = requestMappingHandlerAdapter.getMessageConverters();
            requestFormEntityMethodProcessor = new RequestJsonBodyMethodProcessor(messageConverters);
        }
        return requestFormEntityMethodProcessor;
    }

    @Override
    public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer,
                                  NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
//    	MethodParameter methodParameter = new MethodParameter(parameter.getParameterAnnotation(RequestFormEntity.class).clazz().getDeclaredConstructor(),0);
    	
//    	Conventions.getVariableNameForParameter(parameter)
//    	webRequest.getParameterNames("usuario")
    	
//    	Object valueAux = getRequestResponseBodyMethodProcessor()
//                .resolveArgument(methodParameter, mavContainer, webRequest, binderFactory);
    	
        Object value = getRequestResponseBodyMethodProcessor()
                .resolveArgument(parameter, mavContainer, webRequest, binderFactory);
        return value;
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/method/annotation/RequestJsonBodyMethodProcessor.java
================================================
package com.ejie.x38.control.method.annotation;

import java.io.IOException;
import java.lang.annotation.Annotation;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.Conventions;
import org.springframework.core.MethodParameter;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.validation.BindingResult;
import org.springframework.web.HttpMediaTypeNotAcceptableException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.ModelAndViewContainer;
import org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;

import com.ejie.x38.control.bind.annotation.RequestJsonBody;
import com.ejie.x38.serialization.UdaMappingJackson2HttpMessageConverter;
import com.fasterxml.jackson.databind.JsonNode;

public class RequestJsonBodyMethodProcessor extends RequestResponseBodyMethodProcessor {

	@Autowired
	private UdaMappingJackson2HttpMessageConverter udaMappingJackson2HttpMessageConverter;
	
	public RequestJsonBodyMethodProcessor(
			List<HttpMessageConverter<?>> messageConverters) {
		super(messageConverters);
		// TODO Auto-generated constructor stub
	}

	@Override
	public boolean supportsParameter(MethodParameter parameter) {
		return parameter.hasParameterAnnotation(RequestJsonBody.class);
	}

	@Override
	public boolean supportsReturnType(MethodParameter returnType) {
		return false;
	}

//	private MappingJacksonHttpMessageConverter getMappingJacksonHttpMessageConverter(){
		private MappingJackson2HttpMessageConverter getMappingJackson2HttpMessageConverter(){	
		for (HttpMessageConverter httpMessageConverter :this.messageConverters){
			if (httpMessageConverter instanceof MappingJackson2HttpMessageConverter){
				return (MappingJackson2HttpMessageConverter)httpMessageConverter;
			}
		}
		
		/*
		 * FIXME : Arreglar
		 */
		throw new RuntimeException(" ERROR ");
	}
	
	@Override
	public Object resolveArgument(MethodParameter parameter,
			ModelAndViewContainer mavContainer, NativeWebRequest webRequest,
			WebDataBinderFactory binderFactory) throws Exception {
		ServletServerHttpRequest createInputMessage = this.createInputMessage(webRequest);
		
		JsonNode readTree;
		if (createInputMessage.getServletRequest().getAttribute("readTree")==null){
			readTree = this.getMappingJackson2HttpMessageConverter().getObjectMapper().readTree(createInputMessage.getBody());
			createInputMessage.getServletRequest().setAttribute("readTree", readTree);
		}else{
			readTree = (JsonNode)createInputMessage.getServletRequest().getAttribute("readTree");
		}
		
		String param = parameter.getParameterAnnotation(RequestJsonBody.class).param();
		
		JsonNode baseNode = param.equals("param")?readTree:readTree.get(param);
		
		if (baseNode == null){
			return null;
		}
		

		Object arg = this.getMappingJackson2HttpMessageConverter().getObjectMapper().readValue(
		        baseNode.traverse(this.getMappingJackson2HttpMessageConverter().getObjectMapper()),
		        parameter.getParameterType());
		
		
        Annotation annotations[] = parameter.getParameterAnnotations();
        Annotation aannotation[];
        int j = (aannotation = annotations).length;
        for(int i = 0; i < j; i++)
        {
            Annotation annot = aannotation[i];
            if(annot.annotationType().getSimpleName().startsWith("Valid"))
            {
                String name = Conventions.getVariableNameForParameter(parameter);
                WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);
                Object hints = AnnotationUtils.getValue(annot);
                binder.validate((hints instanceof Object[]) ? (Object[])hints : (new Object[] {
                    hints
                }));
                BindingResult bindingResult = binder.getBindingResult();
                if(bindingResult.hasErrors())
                    throw new MethodArgumentNotValidException(parameter, bindingResult);
            }
        }

        return arg;
	}

	@Override
	public void handleReturnValue(Object returnValue,
			MethodParameter returnType, ModelAndViewContainer mavContainer,
			NativeWebRequest webRequest) throws IOException,
			HttpMediaTypeNotAcceptableException {
		
		super.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
	}
	

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/view/JsonViewSupportFactoryBean.java
================================================
package com.ejie.x38.control.view;

import java.util.List;

import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.method.support.HandlerMethodReturnValueHandler;
import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter;
import org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor;

import com.ejie.x38.control.method.annotation.JsonMethodReturnValueHandler;

public class JsonViewSupportFactoryBean implements InitializingBean {

	@Autowired
	private RequestMappingHandlerAdapter adapter;

	@Override
	public void afterPropertiesSet() throws Exception {
		List<HandlerMethodReturnValueHandler> handlers = adapter.getReturnValueHandlers();
		decorateHandlers(handlers);
		adapter.setReturnValueHandlers(handlers);
	}

	private void decorateHandlers(List<HandlerMethodReturnValueHandler> handlers) {
		for (HandlerMethodReturnValueHandler handler : handlers) {
			if (handler instanceof RequestResponseBodyMethodProcessor) {
				JsonMethodReturnValueHandler decorator = new JsonMethodReturnValueHandler();
				int index = handlers.indexOf(handler);
				handlers.add(index, decorator);
				break;
			}
		}
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/view/UdaTilesView.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.control.view;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.context.support.ContextExposingHttpServletRequest;
import org.springframework.web.servlet.view.tiles3.TilesView;

/**
*
* Clase que permite la resolución de vistas en UDA usando Tiles permitiendo el uso de la clase UdaViewResolver
* de tal manera que se pueda exponer beans del contexto de Spring
* 
* @author UDA
* 
*/
public class UdaTilesView extends TilesView {

    private boolean exposeContextBeansAsAttributes = false;
    private Set<String> exposedContextBeanNames;

    public void setExposeContextBeansAsAttributes(boolean exposeContextBeansAsAttributes) {
        this.exposeContextBeansAsAttributes = exposeContextBeansAsAttributes;
    }

    public void setExposedContextBeanNames(String[] exposedContextBeanNames) {
        this.exposedContextBeanNames = new HashSet<String>(Arrays.asList(exposedContextBeanNames));
    } 

    protected HttpServletRequest getRequestToExpose(HttpServletRequest originalRequest) {
        if (this.exposeContextBeansAsAttributes || this.exposedContextBeanNames != null) 
        return new ContextExposingHttpServletRequest(originalRequest, getWebApplicationContext(), this.exposedContextBeanNames);
        return originalRequest;
    }

    @Override
    protected void renderMergedOutputModel(Map<String, Object> model, HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest requestToExpose = getRequestToExpose(request);
        exposeModelAsRequestAttributes(model, requestToExpose);
        super.renderMergedOutputModel(model, requestToExpose, response);
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/control/view/UdaViewResolver.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.control.view;

import org.springframework.web.servlet.view.AbstractUrlBasedView;
import org.springframework.web.servlet.view.UrlBasedViewResolver;

/**
 *
 * Clase que permite la resolución de vistas en UDA sobreescribiendo la clase de Spring UrlBasedViewResolver
 * para incluir las siguientes propiedades para el acceso a beans mediante Expression Language ${...}.
 * - exposeContextBeansAsAttributes : Permite exponer todos los beans del contexto de Spring 
 * - exposedContextBeanNames : Permite exponer los beans del contexto de Spring definidos como parámetros
 * 
 * @author UDA
 * 
 */
public class UdaViewResolver extends UrlBasedViewResolver {

    private Boolean exposeContextBeansAsAttributes;
    private String[] exposedContextBeanNames;

    public void setExposeContextBeansAsAttributes(boolean exposeContextBeansAsAttributes) {
        this.exposeContextBeansAsAttributes = exposeContextBeansAsAttributes;
    }

    public void setExposedContextBeanNames(String[] exposedContextBeanNames) {
        this.exposedContextBeanNames = exposedContextBeanNames;
    }

    @Override
    protected AbstractUrlBasedView buildView(String viewName) throws Exception {
        AbstractUrlBasedView superView = super.buildView(viewName);
        if (superView instanceof UdaTilesView) {
        	UdaTilesView view = (UdaTilesView) superView;
            if (this.exposeContextBeansAsAttributes != null) view.setExposeContextBeansAsAttributes(this.exposeContextBeansAsAttributes);
            if (this.exposedContextBeanNames != null) view.setExposedContextBeanNames(this.exposedContextBeanNames);
        }
        return superView;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/converter/DateConverter.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.converter;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.core.convert.converter.Converter;

import com.ejie.x38.util.DateTimeManager;

/**
 * Conversor de fechas dependiendo del idioma.
 * 
 * @author UDA
 * 
 */
public class DateConverter implements Converter<String, Date> {

	@Override
	public Date convert(String strFecha) {
		try {
			Locale locale = LocaleContextHolder.getLocale();
			SimpleDateFormat format = strFecha.length()>10?DateTimeManager.getTimestampFormat(locale):DateTimeManager.getDateTimeFormat(locale);
			return format.parse(strFecha);
		} catch (ParseException ex) {
			ex.printStackTrace();
			throw new IllegalArgumentException();
		}

	}
}



================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/GenericDao.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dao;

import java.io.Serializable;

import javax.persistence.EntityManager;

/**
 * 
 * @author UDA
 *
 * @param <T> Objeto Generico.
 * @param <PK> Objeto Generico.
 * 
 */
public interface GenericDao<T , PK extends Serializable> {
	
	void setEntityManager(EntityManager entityManager);
	
	EntityManager getEntityManager();
	
	/**
	 * Añadir un nuevo registro 
	 * @param entity instancia de clase entidad.
	 * @return el entity
	 */
	T add (T entity);
	
	/**
	 * Encontrar una entidad por clave primaria.
	 * @param id clave primaria 
	 * @return la  entidad o null en caso de no existir
	 */
	T find(PK id);
	
	/**
	 * Borrar un registro.
	 * @param id clave primaria  
	 */
	void remove(PK id);
	
	/**
	 * modificar un registro
	 * @param entity
	 * @return la entidad modificada
	 */
	T update(T entity);
	
//	/**
//	 * devolver el la lista completa de entidades
//	 * @return lista de entidades
//	 */
//	List<T> findAll();
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/GenericDaoImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dao;

import java.io.Serializable;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

import javax.persistence.EntityManager;

import org.springframework.transaction.annotation.Transactional;

/**
 * 
 * @author UDA
 *
 * @param <T> Objeto Generico.
 * @param <PK> Objeto Generico.
 * 
 */
@Transactional
public class GenericDaoImpl<T, PK extends Serializable> implements GenericDao<T, PK> {

	private EntityManager em;
	
	public void setEntityManager(EntityManager entityManager){
		this.em = entityManager;
	}
	
	public EntityManager getEntityManager(){
		return em;
	}
	
	private Class<T> classT; // cumple las veces de T.class que no es valido demomento en java.

	@SuppressWarnings({ "unchecked", "rawtypes" })
	public GenericDaoImpl() {

		// Bueno pues como no se puede hacer T.class hay que hacer esta
		// movida mediante introspección.
		// this.classT = (Class<T>) ((ParameterizedType) getClass()
		// .getGenericSuperclass()).getActualTypeArguments()[0];
		// para obtener la clase T. es decir el primer parámetro generico
		// mediante
		// introspección.
		// evitar un posible ClassCastException Por si acaso a su vez el tipo se
		// trata de un generico
		Type type = ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
		if (type instanceof ParameterizedType)
			this.classT = (Class) ((ParameterizedType) type).getRawType();
		else
			this.classT = (Class) type;
	}

	@Override
	public T add(T entity) {

		this.em.persist(entity);
		return entity;
	}

	@Transactional(readOnly = true)
	@Override
	public T find(PK id) {

		return (T) em.find(classT, id);
	}

	@Override
	public void remove(PK id) {

		T entity = (T) em.find(classT, id);
		em.remove(entity);

	}

	@Override
	public T update(T entity) {
		return em.merge(entity);

	}

//	@Transactional(readOnly = true)
//	@SuppressWarnings("unchecked")
//	@Override
//	public List<T> findAll() {
//		return em.createQuery("Select t from " + this.classT.getSimpleName() + " t").getResultList();
//	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/RowNumResultSetExtractor.java
================================================
package com.ejie.x38.dao;

import java.lang.reflect.InvocationTargetException;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.beanutils.BeanUtils;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.jdbc.core.RowMapper;

import com.ejie.x38.dto.TableRequestDto;
import com.ejie.x38.dto.TableRowDto;

public class RowNumResultSetExtractor<T> implements ResultSetExtractor<List<TableRowDto<T>>> {

	private RowMapper<T> rowMapper;
	private List<String> pkColums;
	
	@Override
	public List<TableRowDto<T>> extractData(ResultSet resultSet) throws SQLException,
			DataAccessException {
		List<TableRowDto<T>> listTableRow = new ArrayList<TableRowDto<T>>();
		
		while (resultSet.next()) {
			TableRowDto<T> tableRow = new TableRowDto<T>();
			tableRow.setPage(resultSet.getInt("PAGE"));
			tableRow.setPageLine(resultSet.getInt("PAGELINE"));
			tableRow.setTableLine(resultSet.getInt("TABLELINE"));
			
			T model = rowMapper.mapRow(resultSet, resultSet.getRow());
			tableRow.setModel(model);
			try {
				for (String pk : this.pkColums) {
					tableRow.addPrimaryKey(pk, BeanUtils.getProperty(model, pk));
				}
				listTableRow.add(tableRow);
			} catch (IllegalAccessException e) {
				throw new SQLException(e);
			} catch (InvocationTargetException e) {
				throw new SQLException(e);
			} catch (NoSuchMethodException e) {
				throw new SQLException(e);
			}
		}
		return listTableRow;
	}
	
	public RowNumResultSetExtractor(RowMapper<T> rowMapper, String...pk){
		this.rowMapper = rowMapper;
		this.pkColums = Arrays.asList(pk);
	}
	
	public RowNumResultSetExtractor(RowMapper<T> rowMapper, TableRequestDto tableRequestDto){
		this.rowMapper = rowMapper;
		this.pkColums = tableRequestDto.getCore().getPkNames();
	}
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/NlsLangControl.java
================================================
package com.ejie.x38.dao.sql;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.aop.AopInvocationException;

/**
 * The Class NlsLangControl.
 */
@Aspect
public class NlsLangControl {

	/** The sqls. */
	private List<String> sqls;
	
	/** The problems. */
	boolean problems = Boolean.TRUE;
	
	/** The nls config. */
	HashMap<String,String> nlsConfig = new HashMap<String, String>(); 
	
	/**
	 * Instantiates a new nls lang control.
	 */
	NlsLangControl(){}
	
    /**
     * Prepare nls lang.
     *
     * @param connection the connection
     * @throws SQLException the SQL exception
     */
    @AfterReturning(value = "execution(java.sql.Connection javax.sql.DataSource+.getConnection(..))", returning = "connection")
    private void prepareNlsLang (Connection connection) throws SQLException {
    	
    	if(this.problems) {
    		
	    	Statement statement = null;
	    	try{
	    		
	    		statement = connection.createStatement();
	    		
	    		if(nlsConfig.size() == 0) {
	    			ResultSet sessionPrametersRS = statement.executeQuery("select * from nls_session_parameters");
	    			
	    			while (sessionPrametersRS.next()) {
	    				nlsConfig.put(sessionPrametersRS.getString("PARAMETER"), sessionPrametersRS.getString("VALUE"));
	    			}
	    			
	    			if("SPANISH".equalsIgnoreCase(nlsConfig.get("NLS_LANGUAGE"))){
	    				problems = Boolean.FALSE;
	    			} else {
	    				problems = Boolean.TRUE;
	    			}
	    		}
	    		
	    		//Validamos el update
	    		ResultSet validateRS = statement.executeQuery("select * from nls_session_parameters");
	    		
	    		while (validateRS.next()) {
    				
	    			if(validateRS.getString("PARAMETER").equalsIgnoreCase("NLS_LANGUAGE")) {
	    				if(!("SPANISH".equalsIgnoreCase(validateRS.getString("VALUE")))){
	    					for (String sql : sqls) {
	    						statement.executeUpdate(sql);
	    					}
	    					
	    				}
	    				
	    				//Una vez valorado el idioma salimos de la valoracion de datos
	    				break;
	    			}
    			}
	    		
	    		
	    	}catch(SQLException ex){
	    		throw new AopInvocationException("Se ha producido un error en la ejecución del aspecto", ex);
	    	}finally{
	    		if (statement != null) statement.close();
	    	}
    	}
    }

	/**
	 * Sets the sqls.
	 *
	 * @param sqls the new sqls
	 */
	public void setSqls(List<String> sqls) {
		this.sqls = sqls;
	}
	
	/**
	 * Gets the nls config.
	 *
	 * @return the nls config
	 */
	public Map<String,String> getNlsConfig() {
		return this.nlsConfig; 
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/OracleEncoder.java
================================================
package com.ejie.x38.dao.sql;

import com.ejie.x38.dao.sql.codecs.Codec;
import com.ejie.x38.dao.sql.codecs.OracleCodec;

public class OracleEncoder {
	
	private static Codec codec;
	
	private static OracleEncoder instance;
	
	public static OracleEncoder getInstance(){
		if (OracleEncoder.instance == null){
			OracleEncoder.instance = new OracleEncoder();
			OracleEncoder.codec = new OracleCodec();
		}
		
		return OracleEncoder.instance;
	}
	
	
	private OracleEncoder(){
		
	}
	
	public String encode(String input){
		return SqlEncoder.encodeForSQL(OracleEncoder.codec, input);
	}
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/SqlEncoder.java
================================================
/**
 * OWASP Enterprise Security API (ESAPI)
 * 
 * This file is part of the Open Web Application Security Project (OWASP)
 * Enterprise Security API (ESAPI) project. For details, please see
 * <a href="http://www.owasp.org/index.php/ESAPI">http://www.owasp.org/index.php/ESAPI</a>.
 *
 * Copyright (c) 2007 - The OWASP Foundation
 * 
 * The ESAPI is published by OWASP under the BSD license. You should read and accept the
 * LICENSE before you use, modify, and/or redistribute this software.
 * 
 * @author Jeff Williams <a href="http://www.aspectsecurity.com">Aspect Security</a>
 * @created 2007
 */
package com.ejie.x38.dao.sql;

import com.ejie.x38.dao.sql.codecs.Codec;




/**
 * Reference implementation of the Encoder interface. This implementation takes
 * a whitelist approach to encoding, meaning that everything not specifically identified in a
 * list of "immune" characters is encoded.
 * 
 * @author Jeff Williams (jeff.williams .at. aspectsecurity.com) <a
 *         href="http://www.aspectsecurity.com">Aspect Security</a>
 * @since June 1, 2007
 * @see org.owasp.esapi.Encoder
 */
public class SqlEncoder {

	private final static char[] IMMUNE_SQL = { ' ' };
	
	public static String encodeForSQL(Codec codec, String input) {
	    if( input == null ) {
	    	return null;
	    }
	    return codec.encode(IMMUNE_SQL, input);
	}

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/codecs/Codec.java
================================================
/**
 * OWASP Enterprise Security API (ESAPI)
 * 
 * This file is part of the Open Web Application Security Project (OWASP)
 * Enterprise Security API (ESAPI) project. For details, please see
 * <a href="http://www.owasp.org/index.php/ESAPI">http://www.owasp.org/index.php/ESAPI</a>.
 *
 * Copyright (c) 2007 - The OWASP Foundation
 * 
 * The ESAPI is published by OWASP under the BSD license. You should read and accept the
 * LICENSE before you use, modify, and/or redistribute this software.
 * 
 * @author Jeff Williams <a href="http://www.aspectsecurity.com">Aspect Security</a>
 * @created 2007
 */
package com.ejie.x38.dao.sql.codecs;


/**
 * The Codec interface defines a set of methods for encoding and decoding application level encoding schemes,
 * such as HTML entity encoding and percent encoding (aka URL encoding). Codecs are used in output encoding
 * and canonicalization.  The design of these codecs allows for character-by-character decoding, which is
 * necessary to detect double-encoding and the use of multiple encoding schemes, both of which are techniques
 * used by attackers to bypass validation and bury encoded attacks in data.
 * 
 * @author Jeff Williams (jeff.williams .at. aspectsecurity.com) <a
 *         href="http://www.aspectsecurity.com">Aspect Security</a>
 * @since June 1, 2007
 * @see org.owasp.esapi.Encoder
 */
public abstract class Codec {

	/**
	 * Initialize an array to mark which characters are to be encoded. Store the hex
	 * string for that character to save time later. If the character shouldn't be
	 * encoded, then store null.
	 */
	private static final String[] hex = new String[256];

	static {
		for ( char c = 0; c < 0xFF; c++ ) {
			if ( c >= 0x30 && c <= 0x39 || c >= 0x41 && c <= 0x5A || c >= 0x61 && c <= 0x7A ) {
				hex[c] = null;
			} else {
				hex[c] = toHex(c).intern();
			}
		}
	}


	/**
	 * Default constructor
	 */
	public Codec() {
	}

	/**
	 * Encode a String so that it can be safely used in a specific context.
	 * 
	 * @param immune
	 * @param input
	 * 		the String to encode
	 * @return the encoded String
	 */
	public String encode(char[] immune, String input) {
		StringBuilder sb = new StringBuilder();
		for (int i = 0; i < input.length(); i++) {
			char c = input.charAt(i);
			sb.append(encodeCharacter(immune, c));
		}
		return sb.toString();
	}

	/**
	 * Default implementation that should be overridden in specific codecs.
	 * 
	 * @param immune
	 * @param c
	 * 		the Character to encode
	 * @return
	 * 		the encoded Character
	 */
	public String encodeCharacter( char[] immune, Character c ) {
		return ""+c;
	}

	/**
	 * Decode a String that was encoded using the encode method in this Class
	 * 
	 * @param input
	 * 		the String to decode
	 * @return
	 *		the decoded String
	 */
	public String decode(String input) {
		StringBuilder sb = new StringBuilder();
		PushbackString pbs = new PushbackString(input);
		while (pbs.hasNext()) {
			Character c = decodeCharacter(pbs);
			if (c != null) {
				sb.append(c);
			} else {
				sb.append(pbs.next());
			}
		}
		return sb.toString();
	}

	/**
	 * Returns the decoded version of the next character from the input string and advances the
	 * current character in the PushbackString.  If the current character is not encoded, this 
	 * method MUST reset the PushbackString.
	 * 
	 * @param input	the Character to decode
	 * 
	 * @return the decoded Character
	 */
	public Character decodeCharacter( PushbackString input ) {
		return input.next();
	}

	/**
	 * Lookup the hex value of any character that is not alphanumeric.
	 * @param c The character to lookup.
	 * @return, return null if alphanumeric or the character code
	 * 	in hex.
	 */
	public static String getHexForNonAlphanumeric(char c)
	{
		if(c<0xFF)
			return hex[c];
		return toHex(c);
	}

	public static String toOctal(char c)
	{
		return Integer.toOctalString(c);
	}

	public static String toHex(char c)
	{
		return Integer.toHexString(c);
	}

	/**
	 * Utility to search a char[] for a specific char.
	 * 
	 * @param c
	 * @param array
	 * @return
	 */
	public static boolean containsCharacter( char c, char[] array ) {
		for (char ch : array) {
			if (c == ch) return true;
		}
		return false;
	}

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/codecs/OracleCodec.java
================================================
/**
 * OWASP Enterprise Security API (ESAPI)
 *
 * This file is part of the Open Web Application Security Project (OWASP)
 * Enterprise Security API (ESAPI) project. For details, please see
 * <a href="http://www.owasp.org/index.php/ESAPI">http://www.owasp.org/index.php/ESAPI</a>.
 *
 * Copyright (c) 2007 - The OWASP Foundation
 *
 * The ESAPI is published by OWASP under the BSD license. You should read and accept the
 * LICENSE before you use, modify, and/or redistribute this software.
 *
 * @author Jeff Williams <a href="http://www.aspectsecurity.com">Aspect Security</a>
 * @created 2007
 */
package com.ejie.x38.dao.sql.codecs;



/**
 * Implementation of the Codec interface for Oracle strings. This function will only protect you from SQLi in the case of user data
 * bring placed within an Oracle quoted string such as:
 * 
 * select * from table where user_name='  USERDATA    ';
 * 
 * @see <a href="http://oraqa.com/2006/03/20/how-to-escape-single-quotes-in-strings/">how-to-escape-single-quotes-in-strings</a>
 * 
 * @author Jeff Williams (jeff.williams .at. aspectsecurity.com) <a href="http://www.aspectsecurity.com">Aspect Security</a>
 * @author Jim Manico (jim@manico.net) <a href="http://www.manico.net">Manico.net</a>
 * @since June 1, 2007
 * @see org.owasp.esapi.Encoder
 */
public class OracleCodec extends Codec {


	/**
	 * {@inheritDoc}
	 * 
	 * Encodes ' to ''
     *
	 * Encodes ' to ''
     *
     * @param immune
     */
	public String encodeCharacter( char[] immune, Character c ) {
		if ( c.charValue() == '\'' )
        	return "\'\'";
        return ""+c;
	}
	


	/**
	 * {@inheritDoc}
	 *
	 * Returns the decoded version of the character starting at index, or
	 * null if no decoding is possible.
	 *
	 * Formats all are legal
	 *   '' decodes to '
	 */
	public Character decodeCharacter( PushbackString input ) {
		input.mark();
		Character first = input.next();
		if ( first == null ) {
			input.reset();
			return null;
		}

		// if this is not an encoded character, return null
		if ( first.charValue() != '\'' ) {
			input.reset();
			return null;
		}

		Character second = input.next();
		if ( second == null ) {
			input.reset();
			return null;
		}
		
		// if this is not an encoded character, return null
		if ( second.charValue() != '\'' ) {
			input.reset();
			return null;
		}
		return( Character.valueOf( '\'' ) );
	}

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/codecs/PushbackString.java
================================================
/**
 * OWASP Enterprise Security API (ESAPI)
 * 
 * This file is part of the Open Web Application Security Project (OWASP)
 * Enterprise Security API (ESAPI) project. For details, please see
 * <a href="http://www.owasp.org/index.php/ESAPI">http://www.owasp.org/index.php/ESAPI</a>.
 *
 * Copyright (c) 2007 - The OWASP Foundation
 * 
 * The ESAPI is published by OWASP under the BSD license. You should read and accept the
 * LICENSE before you use, modify, and/or redistribute this software.
 * 
 * @author Jeff Williams <a href="http://www.aspectsecurity.com">Aspect Security</a>
 * @created 2007
 */
package com.ejie.x38.dao.sql.codecs;


/**
 * The pushback string is used by Codecs to allow them to push decoded characters back onto a string
 * for further decoding. This is necessary to detect double-encoding.
 * 
 * @author Jeff Williams (jeff.williams .at. aspectsecurity.com) <a
 *         href="http://www.aspectsecurity.com">Aspect Security</a>
 * @since June 1, 2007
 * @see org.owasp.esapi.Encoder
 */
public class PushbackString {

	private String input;
	private Character pushback;
	private Character temp;
	private int index = 0;
	private int mark = 0;
	
    /**
     *
     * @param input
     */
    public PushbackString( String input ) {
		this.input = input;
	}

    /**
     *
     * @param c
     */
    public void pushback( Character c ) {
		pushback = c;
	}
	

    /**
     * Get the current index of the PushbackString. Typically used in error messages.
     * @return The current index of the PushbackString.
     */
    public int index() {
		return index;
	}
	
    /**
     *
     * @return
     */
    public boolean hasNext() {
		if ( pushback != null ) return true;
		if ( input == null ) return false;
		if ( input.length() == 0 ) return false;
		if ( index >= input.length() ) return false;
		return true;		
	}
	
    /**
     *
     * @return
     */
    public Character next() {
		if ( pushback != null ) {
			Character save = pushback;
			pushback = null;
			return save;
		}
		if ( input == null ) return null;
		if ( input.length() == 0 ) return null;
		if ( index >= input.length() ) return null;		
		return Character.valueOf( input.charAt(index++) );
	}
	
    /**
    *
    * @return
    */
   public Character nextHex() {
		Character c = next();
		if ( c == null ) return null;
		if ( isHexDigit( c ) ) return c;
		return null;
	}

   /**
   *
   * @return
   */
  public Character nextOctal() {
		Character c = next();
		if ( c == null ) return null;
		if ( isOctalDigit( c ) ) return c;
		return null;
	}

  /**
 * Returns true if the parameter character is a hexidecimal digit 0 through 9, a through f, or A through F.
  * @param c
  * @return
  */
 public static boolean isHexDigit( Character c ) {
		if ( c == null ) return false;
		char ch = c.charValue();
		return (ch >= '0' && ch <= '9' ) || (ch >= 'a' && ch <= 'f' ) || (ch >= 'A' && ch <= 'F' );
	}

 /**
 * Returns true if the parameter character is an octal digit 0 through 7.
 * @param c
 * @return
 */
public static boolean isOctalDigit( Character c ) {
	if ( c == null ) return false;
	char ch = c.charValue();
	return ch >= '0' && ch <= '7';
}

    /**
     * Return the next character without affecting the current index.
     * @return
     */
    public Character peek() {
		if ( pushback != null ) return pushback;
		if ( input == null ) return null;
		if ( input.length() == 0 ) return null;
		if ( index >= input.length() ) return null;		
		return Character.valueOf( input.charAt(index) );
	}
	
    /**
     * Test to see if the next character is a particular value without affecting the current index.
     * @param c
     * @return
     */
    public boolean peek( char c ) {
		if ( pushback != null && pushback.charValue() == c ) return true;
		if ( input == null ) return false;
		if ( input.length() == 0 ) return false;
		if ( index >= input.length() ) return false;		
		return input.charAt(index) == c;
	}	
	
    /**
     *
     */
    public void mark() {
		temp = pushback;
		mark = index;
	}

    /**
     *
     */
    public void reset() {
		pushback = temp;
		index = mark;
	}
	
    /**
     *
     * @return
     */
    protected String remainder() {
		String output = input.substring( index );
		if ( pushback != null ) {
			output = pushback + output;
		}
		return output;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/error/EncodingException.java
================================================
/**
 * OWASP Enterprise Security API (ESAPI)
 * 
 * This file is part of the Open Web Application Security Project (OWASP)
 * Enterprise Security API (ESAPI) project. For details, please see
 * <a href="http://www.owasp.org/index.php/ESAPI">http://www.owasp.org/index.php/ESAPI</a>.
 *
 * Copyright (c) 2007 - The OWASP Foundation
 * 
 * The ESAPI is published by OWASP under the BSD license. You should read and accept the
 * LICENSE before you use, modify, and/or redistribute this software.
 * 
 * @author Jeff Williams <a href="http://www.aspectsecurity.com">Aspect Security</a>
 * @created 2007
 */
package com.ejie.x38.dao.sql.error;

/**
 * An EncodingException should be thrown for any problems that occur when
 * encoding or decoding data.
 * 
 * @author Jeff Williams (jeff.williams@aspectsecurity.com)
 */
public class EncodingException extends RuntimeException{

	/** The Constant serialVersionUID. */
	private static final long serialVersionUID = 1L;

	/**
	 * Instantiates a new service exception.
	 */
	protected EncodingException() {
		// hidden
	}

       /**
     * Creates a new instance of EncodingException.
     * 
     * @param userMessage
     *            the message displayed to the user
     * @param logMessage
	 * 			  the message logged
     */
    public EncodingException(String userMessage, String logMessage) {
        super(userMessage);
    }

    /**
     * Instantiates a new EncodingException.
     * 
     * @param userMessage
     *            the message displayed to the user
     * @param logMessage
	 * 			  the message logged
     * @param cause
     *            the cause
     */
    public EncodingException(String userMessage, String logMessage, Throwable cause) {
        super(userMessage, cause);
    }

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dao/sql/error/SqlInjectionException.java
================================================
package com.ejie.x38.dao.sql.error;

public class SqlInjectionException extends RuntimeException {

	public SqlInjectionException() {
		super();
		// TODO Auto-generated constructor stub
	}

	public SqlInjectionException(String arg0, Throwable arg1) {
		super(arg0, arg1);
		// TODO Auto-generated constructor stub
	}

	public SqlInjectionException(String arg0) {
		super(arg0);
		// TODO Auto-generated constructor stub
	}

	public SqlInjectionException(Throwable arg0) {
		super(arg0);
		// TODO Auto-generated constructor stub
	}
	
	

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/SearchDto.java
================================================
package com.ejie.x38.dto;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;


/**
 * DTO encargado de facilitar la recogida de los parámetros de filtrado y búsqueda en la acción search del componente tabla.
 * 
 * @author UDA
 *
 * @param <T> Tipo de bean utlizado para recoger los parámetros de filtado.
 * @param <U> Tipo de bean utilizado para recoger los parámetros de búsqueda.
 */
public class SearchDto<T, U> {
	
	private Map<String, Object> filterParams;
	private Map<String, Object> searchParams;
	
	/**
	 * Constructor.
	 */
	public SearchDto(){
	}
	
	/**
	 * Constructor.
	 * 
	 * @param filterParams
	 *            Parámetros de filtrado.
	 * @param searchParams
	 *            Parámetros de búsqueda.
	 */
	public SearchDto(Map<String, Object> filterParams, Map<String, Object> searchParams){
		this.filterParams = filterParams;
		this.searchParams = searchParams;
	}	
	
	/**
	 * Getter de filterParams;
	 * 
	 * @return filterParams.
	 */
	public Map<String, Object> getFilterParams() {
		return filterParams;
	}

	/**
	 * Setter de filterParams.
	 * 
	 * @param filterParams
	 *            Parámetros de filtrado.
	 */
	public void setFilterParams(Map<String, Object> filterParams) {
		this.filterParams = filterParams;
	}

	/**
	 * Getter de searchParams;
	 * 
	 * @return searchParams.
	 */
	public Map<String, Object> getSearchParams() {
		return this.searchParams;
	}

	/**
	 * Setter de searchParams.
	 * 
	 * @param searchParams
	 *            Parámetros de búsqueda.
	 */
	public void setSearchParams(Map<String, Object> searchParams) {
		this.searchParams = searchParams;
	}
	
	/**
	 * Devuelve un bean del tipo indicado como parámetro, con los criterios de
	 * filtrado.
	 * 
	 * @param clazz
	 *            Tipo de bean.
	 * @return Parámetros de filtrado.
	 */
	public T getFilterParams(Class<T> clazz) {
		return this.fromMapToBean(clazz, this.filterParams);
	}
	
	/**
	 * Devuelve un bean del tipo indicado como parámetro, con los criterios de
	 * búsqueda.
	 * 
	 * @param clazz
	 *            Tipo de bean.
	 * @return Parámetros de búsqueda.
	 */
	public U getSearchParams(Class<U> clazz) {
		return this.fromMapToBean(clazz, this.searchParams);
	}
	
	/**
	 * Devuelve un bean del tipo TableRequestDto, con los parámetros de paginación.
	 * 
	 * @return Parámetros de paginación.
	 */
	public TableRequestDto getPagination() {
		return this.fromMapToBean(TableRequestDto.class, this.filterParams);
	}
	
	@SuppressWarnings("unchecked")
	private <V> V fromMapToBean(Class<V> clazz, Map<String, Object> propertyMap){
		
		BeanWrapper beanWrapper = new BeanWrapperImpl(clazz);
		Set<String> keySet = propertyMap.keySet();
		
		for (Iterator<String> iterator = keySet.iterator(); iterator.hasNext();) {
			String key = iterator.next();
			if (beanWrapper.isWritableProperty(key)){
				beanWrapper.setPropertyValue(key, propertyMap.get(key));
			}
			
		}
		
		return (V) beanWrapper.getWrappedInstance();
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/SearchModelMapDto.java
================================================
package com.ejie.x38.dto;

import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;


/**
 * DTO encargado de facilitar la recogida de los parámetros de filtrado y búsqueda en la acción search del componente tabla.
 * 
 * @author UDA
 *
 * @param <T> Tipo de bean utlizado para recoger los parámetros de filtado.
 * @param <U> Tipo de bean utilizado para recoger los parámetros de búsqueda.
 */
public class SearchModelMapDto<T, U> {
	
	private Map<String, Object> filterParams;
	private Map<String, Object> searchParams;
	
	/**
	 * Constructor.
	 */
	public SearchModelMapDto(){
	}
	
	/**
	 * Constructor.
	 * 
	 * @param filterParams
	 *            Parámetros de filtrado.
	 * @param searchParams
	 *            Parámetros de búsqueda.
	 */
	public SearchModelMapDto(Map<String, Object> filterParams, Map<String, Object> searchParams){
		this.filterParams = filterParams;
		this.searchParams = searchParams;
	}	
	
	/**
	 * Getter de filterParams;
	 * 
	 * @return filterParams.
	 */
	public Map<String, Object> getFilterParams() {
		return filterParams;
	}

	/**
	 * Setter de filterParams.
	 * 
	 * @param filterParams
	 *            Parámetros de filtrado.
	 */
	public void setFilterParams(Map<String, Object> filterParams) {
		this.filterParams = filterParams;
	}

	/**
	 * Getter de searchParams;
	 * 
	 * @return searchParams.
	 */
	public Map<String, Object> getSearchParams() {
		return this.searchParams;
	}

	/**
	 * Setter de searchParams.
	 * 
	 * @param searchParams
	 *            Parámetros de búsqueda.
	 */
	public void setSearchParams(Map<String, Object> searchParams) {
		this.searchParams = searchParams;
	}
	
	/**
	 * Devuelve un bean del tipo indicado como parámetro, con los criterios de
	 * filtrado.
	 * 
	 * @param clazz
	 *            Tipo de bean.
	 * @return Parámetros de filtrado.
	 */
	public T getFilterParams(Class<T> clazz) {
		return this.fromMapToBean(clazz, this.filterParams);
	}
	
	/**
	 * Devuelve un bean del tipo indicado como parámetro, con los criterios de
	 * búsqueda.
	 * 
	 * @param clazz
	 *            Tipo de bean.
	 * @return Parámetros de búsqueda.
	 */
	public U getSearchParams(Class<U> clazz) {
		return this.fromMapToBean(clazz, this.searchParams);
	}
	
	/**
	 * Devuelve un bean del tipo TableRequestDto, con los parámetros de paginación.
	 * 
	 * @return Parámetros de paginación.
	 */
	public TableRequestDto getPagination() {
		return this.fromMapToBean(TableRequestDto.class, this.filterParams);
	}
	
	@SuppressWarnings("unchecked")
	private <V> V fromMapToBean(Class<V> clazz, Map<String, Object> propertyMap){
		
		BeanWrapper beanWrapper = new BeanWrapperImpl(clazz);
		Set<String> keySet = propertyMap.keySet();
		
		for (Iterator<String> iterator = keySet.iterator(); iterator.hasNext();) {
			String key = iterator.next();
			if (beanWrapper.isWritableProperty(key)){
				beanWrapper.setPropertyValue(key, propertyMap.get(key));
			}
			
		}
		
		return (V) beanWrapper.getWrappedInstance();
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableDto.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dto;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;

/**
 * Bean contenedor de las propiedades que utiliza el componente table.
 * 
 * @author UDA
 *
 * @param <T> Tipo de bean que se va a representar en el grid.
 */

@JsonInclude(Include.NON_NULL)
public class TableDto<T> {

	//Página actuals
	private String page = null;
	//Datos de la página
	private List<T> rows = null;
	//Número total de páginas	
	private String total = null;
	//Número total de registros
	private Integer records = null;
	// Parámetros adicionales
	private Map<String,Object> additionalParams = new HashMap<String, Object>();
	
	//Constantes para parámetros adicionales
	public static final String CHILDREN = "children";
	
	/**
	 * Constructor.
	 */
	public TableDto() {
		super();
	}

	/**
	 * Contructor.
	 * 
	 * @param pagination
	 *            Objeto paginación.
	 * @param recordNum
	 *            Numero de registros.
	 * @param rows
	 *            Lista contenedora de los registros.
	 */
	public TableDto(TableRequestDto pagination, Long recordNum, List<T> rows) {
		this(pagination, recordNum, null, rows);
	}
	
	/**
	 * Contructor.
	 * 
	 * @param pagination
	 *            Objeto paginación.
	 * @param recordNum
	 *            Numero de registros.
	 * @param total
	 *            Numero de resgistros totales.
	 * @param rows
	 *            Lista contenedora de los registros.
	 */
	public TableDto(TableRequestDto pagination, Long recordNum, Long total, List<T> rows) {
		this(pagination, recordNum, total, rows, null);
	}
	
	/**
	 * Contructor.
	 * 
	 * @param pagination
	 *            Objeto paginación.
	 * @param recordNum
	 *            Numero de registros.
	 * @param rows
	 *            Lista contenedora de los registros.
	 * @param reorderedSelection
	 *            Lista con la reordenación de los registros.
	 */
	public TableDto(TableRequestDto pagination, Long recordNum, List<T> rows, List<TableRowDto<T>> reorderedSelection) {
		this(pagination, recordNum, null, rows, reorderedSelection);
	}

	/**
	 * Contructor.
	 * 
	 * @param pagination
	 *            Objeto paginación.
	 * @param recordNum
	 *            Numero de registros.
	 * @param total
	 *            Numero de resgistros totales.
	 * @param rows
	 *            Lista contenedora de los registros.
	 * @param reorderedSelection
	 *            Lista con la reordenación de los registros.
	 */
	public TableDto(TableRequestDto pagination, Long recordNum, Long total, List<T> rows, List<TableRowDto<T>> reorderedSelection) {
		super();
		this.page = (pagination.getPage()!=null)?pagination.getPage().toString():"";
		this.rows = rows;
		this.setTotal(recordNum, (pagination.getRows()!=null)?pagination.getRows():0);
		this.records = total!=null?total.intValue():recordNum.intValue();
		this.addAdditionalParam("reorderedSelection", reorderedSelection);
		this.addAdditionalParam("selectedAll", pagination.getMultiselection().getSelectedAll());
	}
	
	
	/**
	 * @return the page
	 */
	public String getPage() {
		return page;
	}
	/**
	 * @param page the page to set
	 */
	public void setPage(String page) {
		this.page = page;
	}
	/**
	 * @return the rows
	 */
	public List<?> getRows() {
		return rows;
	}
	/**
	 * @param rows the rows to set
	 */
	public void setRows(List<T> rows) {
		this.rows = rows;
	}
	/**
	 * @return the total
	 */
	public String getTotal() {
		return total;
	}

	/**
	 * Calcula el numero total de paginas, segun los registros totales y el numero de regitros pro página
	 * 
	 * @param total el número de registros totales
	 * @param rows el número de filas por pagina
	 */
	public void setTotal(Long total, Long rows) {
		double dTotal = total.doubleValue();
		double dRows = rows.doubleValue();
		double totalPages = (total > 0) ? Math.ceil(dTotal / dRows) : 0;
		
		this.total = String.valueOf((int)totalPages);
	}
	/**
	 * @return the records
	 */
	public Integer getRecords() {
		return records;
	}
	/**
	 * @param records the records to set
	 */
	public void setRecords(Integer records) {
		this.records = records;
	}
	
	/*
	 * Funciones asociadas a la gestión de parámetros adicionales
	 */
	/**
	 * Añade un parámetro adicional.
	 * 
	 * @param key
	 *            Nombre del parámetro.
	 * @param param
	 *            Objeto a admacenar.
	 */
	public void addAdditionalParam(String key, Object param){
		this.additionalParams.put(key, param);
	}
	
	/**
	 * Recupera un parámetro adicional.
	 * 
	 * @param key
	 *            Nombre del parámetro.
	 * @return Parámetro almacenado.
	 */
	public Object getAdditionalParam(String name) {
		return this.additionalParams.get(name);
	}
	
	/**
	 * Elimina un parámetro adicional de estructura.
	 * 
	 * @param key
	 *            Nombre del parámetro.
	 */
	public void removeAdditionalParam(String name) {
		this.additionalParams.remove(name);
	}
	
	/**
	 * Devuelve el mapa que almacena los parámetros adicionales.
	 * 
	 * @param name
	 * @return
	 */
	@JsonIgnore
	public Map<String,Object> getAdditionalParamsMap() {
		return this.additionalParams;
	}

	/**
	 * Método "any getter" necesario para la serialización del contenido del
	 * mapa.
	 * 
	 * @return Mapa que contiene los parámetros adicionales.
	 */
    @JsonAnyGetter
    public Map<String,Object> anyAdditionalParams() {
        return this.additionalParams;
    }

    /**
	 * Método "any setter" necesario para la deserialización del parámetros al mapa
	 * 
	 * @return Mapa que contiene los parámetros adicionales.
	 */
    @JsonAnySetter
    public void set(String name, Object value) {
    	this.additionalParams.put(name, value);
    }
	
    /*
	 * Funciones auxiliares
	 */
    public void setReorderedSelection(List<TableRowDto<T>> reorderedSelection){
    	
    }
    
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(this.getClass().getName()).append(" Object {");
		result.append(" [ page: ").append(this.page).append(" ]");
		result.append(" [ rows: ").append(this.rows).append(" ]");
		result.append(" [ total: ").append(this.total).append(" ]");
		result.append(" [ records: ").append(this.records).append(" ]");
		result.append("}");
		return result.toString();
	}
	
//	/**
//	 * Procesa la estructura reorderedSelection para completar los datos a
//	 * partir de la información de la paginación.
//	 * 
//	 * @param reorderedSelection
//	 *            Lista de registros reordenados.
//	 * @param pagination
//	 *            Objeto paginación.
//	 * @return Lista procesada de elementos reordenados.
//	 */
//	private List<TableRowDto<T>> processReorderedSelection(List<TableRowDto<T>> reorderedSelection, Pagination pagination){
//		if (reorderedSelection != null && pagination != null){
//			List<TableRowDto<T>> proccesedReorderedSelection = new ArrayList<TableRowDto<T>>(reorderedSelection);
//			for (TableRowDto<T> tableRow : proccesedReorderedSelection) {
//				Integer rowNum = tableRow.getTableLine()-1;
//				Long page = (rowNum/pagination.getRows())+1;
//				
//				tableRow.setPage(page.intValue());
//				Long rowLine = tableRow.getTableLine()%pagination.getRows();
//				tableRow.setTableLine(rowLine.intValue());
//			}
//			return proccesedReorderedSelection;
//		}
//		return reorderedSelection;
//	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableJerarquiaDto.java
================================================
package com.ejie.x38.dto;

import com.fasterxml.jackson.annotation.JsonUnwrapped;

/**
 * Object mapper propio de UDA en el que se realiza la configuración necesaria.
 * 
 * @author UDA
 *
 */
public class TableJerarquiaDto<T> implements java.io.Serializable {
	
	private static final long serialVersionUID = 2127819481595995328L;
	
	@JsonUnwrapped
	private T model;
	private int level;
	private boolean isLeaf;
	private String parentNodes;
	private boolean filter;
	private String parent;
	
	//Grid-Maint
	private boolean hasChildren;
	private String treeNodes;
	
	public TableJerarquiaDto() {
		super();
	}

	/**
	 * @return the model
	 */
	public T getModel() {
		return model;
	}
	/**
	 * @param model the model to set
	 */
	public void setModel(T model) {
		this.model = model;
	}
	/**
	 * @return the level
	 */
	public int getLevel() {
		return level;
	}
	/**
	 * @param level the level to set
	 */
	public void setLevel(int level) {
		this.level = level;
	}
	/**
	 * @return the hasChildren
	 */
	public boolean isHasChildren() {
		return hasChildren;
	}
	/**
	 * @param hasChildren the hasChildren to set
	 */
	public void setHasChildren(boolean hasChildren) {
		this.hasChildren = hasChildren;
	}
	/**
	 * @return the isLeaf
	 */
	public boolean getIsLeaf() {
		return isLeaf;
	}
	/**
	 * @param isLeaf the isLeaf to set
	 */
	public void setIsLeaf(boolean isLeaf) {
		this.isLeaf = isLeaf;
	}
	/**
	 * @return the parentNodes
	 */
	public String getParentNodes() {
		return parentNodes;
	}
	/**
	 * @param parentNodes the parentNodes to set
	 */
	public void setParentNodes(String parentNodes) {
		this.parentNodes = parentNodes;
	}
	/**
	 * @return the filter
	 */
	public boolean isFilter() {
		return filter;
	}
	/**
	 * @param filter the filter to set
	 */
	public void setFilter(boolean filter) {
		this.filter = filter;
	}
	/**
	 * @return the treeNodes
	 */
	public String getTreeNodes() {
		return treeNodes;
	}
	/**
	 * @param treeNodes the treeNodes to set
	 */
	public void setTreeNodes(String treeNodes) {
		this.treeNodes = treeNodes;
	}

	public String getParent() {
		return parent;
	}

	public void setParent(String parent) {
		this.parent = parent;
	}

	@Override
	public String toString() {
		return "Jerarquia [model=" + model + ", level=" + level
				+ ", hasChildren=" + hasChildren + ", isLeaf=" + isLeaf
				+ ", parentNodes=" + parentNodes + ", filter=" + filter
				+ ", treeNodes=" + treeNodes + "]";
	}
	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, VersiÃ³n 1.1 exclusivamente (la Â«LicenciaÂ»);
* Solo podrÃ¡ usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislaciÃ³n aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye Â«TAL CUALÂ»,
* SIN GARANTÃ�AS NI CONDICIONES DE NINGÃšN TIPO, ni expresas ni implÃ­citas.
* VÃ©ase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dto;

import java.beans.IntrospectionException;
import java.beans.PropertyDescriptor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ejie.x38.dao.sql.OracleEncoder;
import com.ejie.x38.dao.sql.error.SqlInjectionException;

/**
 *
 * @author UDA
 *
 */
public class TableManager implements java.io.Serializable{

	private static final long serialVersionUID = 2127819481595995328L;

	private static final Logger logger = LoggerFactory.getLogger(TableManager.class);

	/**
	 * PAGINACIÃ“N
	 */
	public static <T> StringBuilder getPaginationQuery(TableRequestDto pagination, StringBuilder query){
		return getQueryForPagination(pagination, query, false, null);
    }

	public static <T> StringBuilder getPaginationQuery(TableRequestDto pagination, StringBuilder query,  boolean isJerarquia){
		return getQueryForPagination(pagination, query, isJerarquia, null);
    }

	public static <T> StringBuilder getPaginationQuery(TableRequestDto pagination, StringBuilder query,  String[] orderByWhiteList){
		return getQueryForPagination(pagination, query, false, orderByWhiteList);
    }

	public static <T> StringBuilder getPaginationQuery(TableRequestDto pagination, StringBuilder query,  boolean isJerarquia, String[] orderByWhiteList){
		return getQueryForPagination(pagination, query, isJerarquia, orderByWhiteList);
    }

	private static boolean isInWhiteList(String[] whiteList, String text){

		// Comprobamos si la cadena de ordenaciÃ³n contiene varios campos


		if (StringUtils.isBlank(text)){
			return false;
		}

		for (String string : whiteList) {
			if (text.trim().toUpperCase().equals(string.trim().toUpperCase())){
				return true;
			}
		}

		return false;

	}

	private static boolean validateOrderByFields (String[] orderByWhiteList, String text){

		boolean result = true;

		String[] fields = text.indexOf(",")!=-1?text.split(","):new String[]{text};

		for (String field : fields) {

			result = result && TableManager.isInWhiteList(orderByWhiteList, field);

		}

		return result;


	}

	protected static <T> StringBuilder getQueryForPagination(TableRequestDto pagination, StringBuilder query, boolean isJerarquia, String[] orderByWhiteList){
		//Order
		query.append(getOrderBy(pagination, isJerarquia, orderByWhiteList));


		//Limits
		StringBuilder paginationQuery = new StringBuilder();
		Long rows = pagination.getRows();
		Long page = pagination.getPage();
		if (page!=null && rows!=null){
			paginationQuery.append("SELECT * FROM (SELECT rownum rnum, a.*  FROM (" + query + ")a) where rnum > " + (rows*(page-1)) +" and rnum < " + ((rows*page)+1));
		}else if (rows!=null) {
			paginationQuery.append("SELECT * FROM (SELECT rownum rnum, a.*  FROM (" + query + ")a) where rnum > 0 and rnum < " + (rows+1));
		}else{
			return query;
		}
		return paginationQuery;
    }

	protected static <T> StringBuilder getOrderBy (TableRequestDto pagination, boolean isJerarquia){
		return TableManager.getOrderBy(pagination, isJerarquia, null);

	}

	/**
	 * ORDER BY (interno)
	 */
	protected static <T> StringBuilder getOrderBy (TableRequestDto pagination, boolean isJerarquia, String[] orderByWhiteList){
		//Order
		StringBuilder orderBy = new StringBuilder();
		if (pagination.getSidx() != null) {
			boolean isColumnIndex = false;
			
			try {
		        Integer.parseInt(pagination.getSidx());
		        isColumnIndex = true;
		    } catch (NumberFormatException nfe) {}
			
			if(pagination.getSidx().indexOf(',') >= 0) {
				for(String sidx : pagination.getSidx().split(",")) {
					if (!isColumnIndex && orderByWhiteList != null && !TableManager.validateOrderByFields(orderByWhiteList, sidx)){
						throw new SqlInjectionException("Campo no permitido");
					}
				}
			} else {
				if (!isColumnIndex && orderByWhiteList != null && !TableManager.validateOrderByFields(orderByWhiteList, pagination.getSidx())){
					throw new SqlInjectionException("Campo no permitido");
				}
			}

			if (!isJerarquia){
				orderBy.append(" ORDER BY ");
			} else {
				orderBy.append("\n\t").append("order siblings by ");
			}
			if(pagination.getSidx().indexOf(',') >= 0) {
				String[] arrSidx = pagination.getSidx().split(",");
				String[] arrSord = pagination.getSord().split(",");
				
				for (int i = 0; i < arrSidx.length ; i++) {
					orderBy.append(OracleEncoder.getInstance().encode(arrSidx[i]));
					orderBy.append(" ");
					orderBy.append(OracleEncoder.getInstance().encode(arrSord[i]));
					if(i < arrSidx.length -1) {
						orderBy.append(",");
					}
					if (isJerarquia){
						orderBy.append("\n");
					}
				}
			} else {
				orderBy.append(OracleEncoder.getInstance().encode(pagination.getSidx()));
				orderBy.append(" ");
				orderBy.append(OracleEncoder.getInstance().encode(pagination.getSord()));
				if (isJerarquia){
					orderBy.append("\n");
				}
			}
		}
		return orderBy;
	}



	/**
	 * MULTISELECCION (utilidades internas)
	 */
	protected static <T> StringBuilder getMultiselectionSelectOutter(TableRequestDto pagination){
		return new StringBuilder().append(" , page, pageLine, tableLine ");
	}
	protected static <T> StringBuilder getMultiselectionSelectInner(TableRequestDto pagination){
		return new StringBuilder().append(" , ceil(rownum/").append(pagination.getRows()).append(") as page, rownum - ((ceil(rownum/").append(pagination.getRows()).append(") - 1) * ").append(pagination.getRows()).append(") as pageLine, rownum as tableLine ");
	}

//	public static StringBuilder getMultiselectionQuery(Pagination pagination, List<String> pkList, String tabla){
//		StringBuilder sbSQL = new StringBuilder();
//		sbSQL.append("\n").append("select ID, page, pageLine, tableLine from ( ");
//		sbSQL.append("\n\t").append("select ID, ceil(rownum/").append(pagination.getRowNum()).append(") page, case when (mod(rownum,").append(pagination.getRowNum()).append(")=0) then '").append(pagination.getRowNum()).append("' else TO_CHAR(mod(rownum,").append(pagination.getRowNum()).append(")) end as pageLine, rownum as tableLine ");
//		sbSQL.append("\n\t").append("from ").append(tabla).append(" ");
//			sbSQL.append("\n\t").append("order by ").append(pagination.getSidx()).append(" ").append(pagination.getSord()).append(" ");
//		sbSQL.append("\n").append(") ");
//		sbSQL.append("\n").append("where ID in ( ");
//			sbSQL.append("\n\t").append("select ID ");
//			sbSQL.append("\n\t").append("from ").append(tabla).append(" t1 ");
//		sbSQL.append("\n").append(") ");
//		return sbSQL;
//	}

//	public static StringBuilder getSearchQuery(Pagination pagination, List<String> pkList, String tabla){
//		StringBuilder sbSQL = new StringBuilder();
//		sbSQL.append("\n").append("select ID, page, pageLine, tableLine from ( ");
//		sbSQL.append("\n\t").append("select ID, ceil(rownum/").append(pagination.getRowNum()).append(") page, case when (mod(rownum,").append(pagination.getRowNum()).append(")=0) then '").append(pagination.getRowNum()).append("' else TO_CHAR(mod(rownum,").append(pagination.getRowNum()).append(")) end as pageLine, rownum as tableLine ");
//		sbSQL.append("\n\t").append("from ").append(tabla).append(" ");
//			sbSQL.append("\n\t").append("order by ").append(pagination.getSidx()).append(" ").append(pagination.getSord()).append(" ");
//		sbSQL.append("\n").append(") ");
//		sbSQL.append("\n").append("where ID in ( ");
//			sbSQL.append("\n\t").append("select ID ");
//			sbSQL.append("\n\t").append("from ").append(tabla).append(" t1 ");
//		sbSQL.append("\n").append(") ");
//		return sbSQL;
//	}

	public static <T> StringBuilder getSearchQuery(StringBuilder query, TableRequestDto pagination, Class<T> clazz, List<Object> paramList, String searchSQL, List<Object> searchParamList, String... pkList){
		return TableManager.getSearchQuery(query, pagination, clazz, paramList, searchSQL, searchParamList, null, pkList);
	}

	public static <T> StringBuilder getSearchQuery(StringBuilder query, TableRequestDto pagination, Class<T> clazz, List<Object> paramList, String searchSQL, List<Object> searchParamList, List<String> tableAliases, String... pkList){

		String pkStr = (TableManager.strArrayToCommaSeparatedStr(pkList)).toUpperCase();

		StringBuilder sbSQL = new StringBuilder();

		sbSQL.append("\n").append("select ").append(pkStr).append(TableManager.getMultiselectionSelectOutter(pagination)).append("from ( ");
		sbSQL.append("\n\t").append("select SEARCH_QUERY.*").append(TableManager.getMultiselectionSelectInner(pagination));
		sbSQL.append("\n\t").append("from (").append(query);
			sbSQL.append("\n\t").append(TableManager.getOrderBy(pagination, false)).append(") SEARCH_QUERY ");
		sbSQL.append("\n").append(") ");
		sbSQL.append("\n").append("where 1=1 ");

		for (String tableAlias : tableAliases) {
			searchSQL = searchSQL.replaceAll("(?i)"+tableAlias.trim()+"\\.", "").trim();
		}
		sbSQL.append("\n\t").append(searchSQL);

		paramList.addAll(searchParamList);
//		sbSQL.append("(").append(pkStr).append(") ");
//		sbSQL.append(pagination.getMultiselection().getSelectedAll()?" NOT IN ":" IN (");
//
//		for (T selectedBean : pagination.getMultiselection().getSelected(clazz)) {
//			sbSQL.append("(");
//			for (int i = 0; i < pkList.length; i++) {
//				String prop = pagination.getMultiselection().getPkNames().get(i);
//				sbSQL.append("?").append(",");
//				try {
//					paramList.add(BeanUtils.getProperty(selectedBean, prop));
//				} catch (IllegalAccessException e) {
//					// TODO Auto-generated catch block
//					e.printStackTrace();
//				} catch (InvocationTargetException e) {
//					// TODO Auto-generated catch block
//					e.printStackTrace();
//				} catch (NoSuchMethodException e) {
//					// TODO Auto-generated catch block
//					e.printStackTrace();
//				}
//			}
//
//			sbSQL.deleteCharAt(sbSQL.length()-1);
//			sbSQL.append("),");
//		}
//
//		sbSQL.deleteCharAt(sbSQL.length()-1);
//		sbSQL.append(")");

		return sbSQL;
	}

	public static <T extends Object> StringBuilder getReorderQuery(StringBuilder query, TableRequestDto tableRequestDto, Class<T> clazz, List<Object> paramList, String... pkList){

		String pkStr = (TableManager.strArrayToCommaSeparatedStr(pkList)).toUpperCase();

		StringBuilder sbSQL = new StringBuilder();

		sbSQL.append("\n").append("select ").append(pkStr).append(TableManager.getMultiselectionSelectOutter(tableRequestDto)).append("from ( ");
		sbSQL.append("\n\t").append("select ").append(pkStr).append(TableManager.getMultiselectionSelectInner(tableRequestDto));
		sbSQL.append("\n\t").append("from (").append(query);
		sbSQL.append("\n\t").append(TableManager.getOrderBy(tableRequestDto, false)).append(") ");
		sbSQL.append("\n").append(") ");
		if(tableRequestDto.getMultiselection().getSelectedAll() && tableRequestDto.getMultiselection().getSelectedIds().size() == 0){
			return sbSQL;
		}
		sbSQL.append("\n").append("where ");

		sbSQL.append("(").append(pkStr).append(") IN (");
//		sbSQL.append(tableRequestDto.getMultiselection().getSelectedAll()?" NOT IN (":" IN (");
		
		for (T selectedBean : tableRequestDto.getMultiselection().getSelected(clazz)) {
			sbSQL.append("(");
			for (String pk : pkList) {
				sbSQL.append("?").append(",");
				try {
					
					// Se obtiene el valor de la pk declarada.
					paramList.add(getCampoByIntrospection(clazz, selectedBean, pk));
					
				} catch (IllegalAccessException e) {
					TableManager.logger.error(e.getMessage(), e);
				} catch (InvocationTargetException e) {
					TableManager.logger.error(e.getMessage(), e);
				} catch (IntrospectionException e) {
					TableManager.logger.error(e.getMessage(), e);
				}
			}

			sbSQL.deleteCharAt(sbSQL.length()-1);
			sbSQL.append("),");
		}

		sbSQL.deleteCharAt(sbSQL.length()-1);
		sbSQL.append(")");

		return sbSQL;
	}

	/**
	 * Str array to comma separated str.
	 *
	 * @param strArray the str array
	 * @return the string
	 */
	private static String strArrayToCommaSeparatedStr(String[] strArray){
		StringBuilder retStr = new StringBuilder();
		for (String str : strArray) {
			retStr.append(str).append(",");
		}
		retStr.deleteCharAt(retStr.length()-1);

		return retStr.toString();
	}

	/**
	 * Gets the pagination list.
	 *
	 * @param <T> the generic type
	 * @param pagination the pagination
	 * @param list the list
	 * @return the pagination list
	 */
	public static <T> List<?> getPaginationList(TableRequestDto pagination, List<?> list){
		List <Object> returnList = new ArrayList<Object>();
		Long rows = pagination.getRows();
		Long page = pagination.getPage();
		if (page!=null && rows!=null){
			for (int i = (int) (rows*(page-1)); i < (rows*page); i++) {
				returnList.add((Object)list.get(i));
			}
		}else if (rows!=null) {
			for (int i = 0; i < rows; i++) {
				returnList.add((Object)list.get(i));
			}
		}else{
			return list;
		}
		return returnList;
	}

	/*
	 * REORDENACION
	 */

	public static <T> StringBuilder getReorderQuery(TableRequestDto pagination, StringBuilder query, String... pkList){
		//Order
		StringBuilder reorderQuery = new StringBuilder();
		if (pagination.getSidx() != null) {
			reorderQuery.append(" ORDER BY ");
			if(pagination.getSidx().contains(",")) {
				String[] arrSidx = pagination.getSidx().split(",");
				String[] arrSord = pagination.getSord().split(",");
				
				for (int i = 0; i < arrSidx.length ; i++) {
					reorderQuery.append(arrSidx);
					reorderQuery.append(" ");
					reorderQuery.append(arrSord);
					if(i < arrSidx.length -1) {
						reorderQuery.append(",");
					}
				}
			} else {
				reorderQuery.append(pagination.getSidx());
				reorderQuery.append(" ");
				reorderQuery.append(pagination.getSord());
				query.append(reorderQuery);
			}
		}

		reorderQuery = new StringBuilder();
		//Limits
//		Long rows = pagination.getRows();
//		Long page = pagination.getPage();
//		if (page!=null && rows!=null){
//		SELECT rownum rnum, a.*  FROM (
//		reorderQuery.append("SELECT ");
//		for (String pkCol : pkList) {mu
//			reorderQuery.append(pkCol).append(",");
//		}
//		reorderQuery.deleteCharAt(reorderQuery.length()-1);
//		reorderQuery.append(" FROM (SELECT rownum rnum, a.*  FROM (" + query + ")a) ");
		reorderQuery.append(" SELECT * FROM (SELECT rownum rnum, a.*  FROM (").append(query).append(")a) ");
		reorderQuery.append(" WHERE ID IN (");
//		for (Object pkCol : pagination.getMultiselection().getSelectedIds()) {
//			reorderQuery.append("'").append(pkCol).append("',");;
//		}
		reorderQuery.deleteCharAt(reorderQuery.length()-1);
		reorderQuery.append(") ");
//		}else if (rows!=null) {
//			paginationQuery.append("SELECT * FROM (SELECT rownum rnum, a.*  FROM (" + query + ")a) where rnum > 0 and rnum < " + (rows+1));
//		}else{
//			return query;
//		}
		return reorderQuery;
    }
	
	/*
	 * BORRADO MULTIPLE
	 */
	
	/**
	 * Crea una consulta de eliminaciÃ³n mÃºltiple teniendo en cuenta el filtro (en caso de haberlo).
	 *
	 * @param Map<?, ?> Mapa que contiene la query where like
	 * @param TableRequestDto Dto que contiene los parÃ¡metros de configuraciÃ³n propios del RUP_TABLE
	 * @param Class<T> Tipo de clase
	 * @param String Nombre de la tabla a tratar
	 * @param String Alias usado en la query
	 * @param String... Strings que forman la clave primaria
	 * 
	 * @return StringBuilder Query que permite eliminar mÃºltiples registros de la tabla
	 */
	public static <T> StringBuilder getRemoveMultipleQuery(Map<?, ?> mapaWhereLike, TableRequestDto tableRequestDto, Class<T> clazz, String table, String alias, String... pkList) {
		String pkStr = (TableManager.strArrayToCommaSeparatedStr(pkList)).toUpperCase();
		List<Object> paramList = new ArrayList<Object>();
		StringBuilder removeQuery = new StringBuilder();
		
		removeQuery.append("DELETE FROM ").append(table).append(" ").append(alias).append(" WHERE 1=1 ");
		
		// Comprobar si el mapa no es nulo y tiene contenido
		if (mapaWhereLike != null && !mapaWhereLike.isEmpty()) {
			removeQuery.append(mapaWhereLike.get("query"));
		}
		
		if (!tableRequestDto.getMultiselection().getSelectedIds().isEmpty()) {
			removeQuery.append(" AND (").append(alias).append(".").append(pkStr).append(") ").append(tableRequestDto.getMultiselection().getSelectedAll() ? "NOT" : "").append(" IN (");
		
			for (T selectedBean : tableRequestDto.getMultiselection().getSelected(clazz)) {
				removeQuery.append("(");
				for (String pk : pkList) {
					removeQuery.append("?").append(",");
					
					try {
						// Se obtiene el valor de la pk declarada.
						paramList.add(getCampoByIntrospection(clazz, selectedBean, pk));
					} catch (IllegalAccessException e) {
						TableManager.logger.error(e.getMessage(), e);
					} catch (InvocationTargetException e) {
						TableManager.logger.error(e.getMessage(), e);
					} catch (IntrospectionException e) {
						TableManager.logger.error(e.getMessage(), e);
					}
				}
				removeQuery.deleteCharAt(removeQuery.length()-1);
				removeQuery.append("),");
			}
			removeQuery.deleteCharAt(removeQuery.length()-1);
			removeQuery.append(")");
		}
		return removeQuery;
	}
	
	public static <T> StringBuilder getSelectMultipleQuery(TableRequestDto tableRequestDto, Class<T> clazz, List<Object> paramList, String[] orderByWhiteList, String... pkList){

		String pkStr = (TableManager.strArrayToCommaSeparatedStr(pkList)).toUpperCase();

		StringBuilder selectQuery = new StringBuilder();
		
		if(!tableRequestDto.getMultiselection().getSelectedIds().isEmpty()) {
			selectQuery.append(" AND (").append(pkStr).append(") ")
				.append(tableRequestDto.getMultiselection().getSelectedAll()? "NOT":"").append(" IN (");
			
			for (T selectedBean : tableRequestDto.getMultiselection().getSelected(clazz)) {
				selectQuery.append("(");
				for (String pk : pkList) {
					selectQuery.append("?").append(",");
					
					try {
						// Se obtiene el valor de la pk declarada.
						paramList.add(getCampoByIntrospection(clazz, selectedBean, pk.replace("_", "")));
					} catch (IllegalAccessException e) {
						TableManager.logger.error(e.getMessage(), e);
					} catch (InvocationTargetException e) {
						TableManager.logger.error(e.getMessage(), e);
					} catch (IntrospectionException e) {
						TableManager.logger.error(e.getMessage(), e);
					}
				}

				selectQuery.deleteCharAt(selectQuery.length()-1);
				selectQuery.append("),");
			}
			
			selectQuery.deleteCharAt(selectQuery.length()-1);
			selectQuery.append(")");
			
			selectQuery.append(getOrderBy(tableRequestDto, false, orderByWhiteList));
		}

		return selectQuery;

	}
	
	/**
	 * Gets the campo by introspection.
	 * @param <T>
	 *
	 * @return the campo by introspection
	 * @throws IntrospectionException 
	 * @throws InvocationTargetException 
	 * @throws IllegalArgumentException 
	 * @throws IllegalAccessException 
	 */
	private static <T> Object getCampoByIntrospection(Class<T> clazz, T selectedBean, String pk) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, IntrospectionException {
		
		// Guardamos los campos declarados en la entidad.
		Field[] fields = clazz.getDeclaredFields();
		final String[] pkFieldNames = pk.split("\\.", -1);
		Object object = selectedBean;
		
		for (int j = 0; j < pkFieldNames.length; j++) {
			String pkFieldName = pkFieldNames[j].replaceAll("_", "");
			boolean pkOk = Boolean.FALSE;
			
			for (Field field : fields) {
				// No se usa equalsIgnoreCase() para evitar problemas con algunos locales.
				if (pkFieldName.toLowerCase().equals(field.getName().toLowerCase())) {
					
					object = new PropertyDescriptor(field.getName(), object.getClass()).getReadMethod().invoke(object);
					pkOk = Boolean.TRUE;
					break;
				}
			}
			
			if(pkOk) {
				fields = object.getClass().getDeclaredFields();
			} else {
				throw new IntrospectionException("La clave especificada \"" + pk + "\", no tiene su correspondencia en la clase \"" + clazz +"\". "); 
			}
		}
		
		return object;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableManagerJerarquia.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dto;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.util.StringUtils;

/**
 * 
 * @author UDA
 *
 */
public class TableManagerJerarquia implements java.io.Serializable{

	private static final long serialVersionUID = 2127819481595995328L;
	
	/**
	 * NORMAL
	 */
	public static <T> StringBuilder getQuery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes, 
			List<String> tabla, List<String> aliasTabla
	){
		return getQuery(tableRequestDto, query, mapaWhere, columna, columnaPadre, columnaParentNodes, tabla, aliasTabla, new StringBuilder(""), null, null);
	}
	public static <T> StringBuilder getQuery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes, 
			List<String> tabla, List<String> aliasTabla, StringBuilder joins
	){
		return getQuery(tableRequestDto, query, mapaWhere, columna, columnaPadre, columnaParentNodes, tabla, aliasTabla, joins, null, null);
	}
	public static <T> StringBuilder getQuery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes, 
			List<String> tabla, List<String> aliasTabla, StringBuilder joins,
			StringBuilder businessFilters, List<?> businessParams
	){
		List<Object> queryParams = new ArrayList<Object>();
		
		//Campos específicos de Jerarquía
		query.append("\n\t").append("-- Campos JERARQUIA");
		query.append("\n\t").append(", LEVEL");
		query.append("\n\t").append(", sys_connect_by_path(").append(columnaParentNodes).append(", '").append(tableRequestDto.getJerarquia().getToken()).append("') as PARENTNODES ");
		query.append("\n\t").append(", decode(connect_by_isleaf, 0, 'false', 'true') as ISLEAF ");
		
		//Decodes para destacar filtrados
		StringBuffer whereConditions = (StringBuffer) mapaWhere.get("query");
		if (whereConditions.length()==0){
			query.append("\n\t").append(", case when (1=0) then 'true' end as FILTER ");
		} else{
			whereConditions = new StringBuffer(whereConditions.substring(whereConditions.indexOf("AND")+4, whereConditions.length()));
			query.append("\n\t").append(", case when (").append(whereConditions).append(") then 'true' end as FILTER ");
			//Añadir los parametros al decode
			@SuppressWarnings("unchecked")
			List<Object> params = (List<Object>) mapaWhere.get("params");
			queryParams.addAll(params);
		}
		
		return getJerarquiaQuery(tableRequestDto, query, mapaWhere, queryParams, columna, columnaPadre, tabla, aliasTabla, joins, businessFilters, businessParams);
	}

	/**
	 * PAGINACIÓN
	 */
	
	public static <T> StringBuilder getPaginationQuery(TableRequestDto tableRequestDto, StringBuilder query){
		return TableManager.getPaginationQuery(tableRequestDto, query, true, null);
	}
	
	public static <T> StringBuilder getPaginationQuery(TableRequestDto tableRequestDto, StringBuilder query, String[] orderByWhiteList){
		return TableManager.getPaginationQuery(tableRequestDto, query, true, orderByWhiteList);
	}
	
	/**
	 * COUNT
	 */
	public static <T> StringBuilder getQueryCount(
			TableRequestDto tableRequestDto,
			Map<String, ?> mapaWhere, 
			String columna, String columnaPadre,
			List<String> tabla, List<String> aliasTabla
	){
		return getJerarquiaQuery(tableRequestDto, new StringBuilder("SELECT COUNT(1) "), mapaWhere, new ArrayList<Object>(), columna, columnaPadre, tabla, aliasTabla, new StringBuilder(""), null, null);
	}
	public static <T> StringBuilder getQueryCount(
			TableRequestDto tableRequestDto,
			Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes,
			List<String> tabla, List<String> aliasTabla, StringBuilder joins
	){
		return getJerarquiaQuery(tableRequestDto, new StringBuilder("SELECT COUNT(1) "), mapaWhere,  new ArrayList<Object>(), columna, columnaPadre, tabla, aliasTabla, joins, null, null);
	}
	public static <T> StringBuilder getQueryCount(
			TableRequestDto tableRequestDto,
			Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes, 
			List<String> tabla, List<String> aliasTabla, StringBuilder joins,
			StringBuilder businessFilters, List<?> businessParams
	){
		return getJerarquiaQuery(tableRequestDto, new StringBuilder("SELECT COUNT(1) "), mapaWhere,  new ArrayList<Object>(), columna, columnaPadre, tabla, aliasTabla, joins, businessFilters, businessParams);
	}

	/**
	 * GENERAL (interna)
	 */
	protected static <T> StringBuilder getJerarquiaQuery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, List<Object> queryParams,
			String columna, String columnaPadre, 
			List<String> tabla, List<String> aliasTabla, StringBuilder joins,
			StringBuilder businessFilters, List<?> businessParams
	){
		query.insert(0,"\n\t");
		
		//FROM (tabla + aliasTabla)
		query.append("\n\t").append("from ");
		StringBuilder from = new StringBuilder("");
		int size = tabla.size();
		for (int i = 0; i < size; i++) {
			from.append(tabla.get(i).trim()).append(" ").append(aliasTabla.get(i).trim()).append(", ");
		}
		query.append(StringUtils.trimTrailingCharacter(from.toString().trim(), ','));
		
		//Si tiene criterios aplicar _subqueries_ PADRE/HIJOS
		if (!((List<?>) mapaWhere.get("params")).isEmpty()){
			query.append(", (");
			
			//Subqueries
				//PADRES
					query.append("\n\t\t").append("-- PADRES");
					query = querySubquery(tableRequestDto, query, mapaWhere, queryParams, columna, tabla, aliasTabla, joins, businessFilters, businessParams);
					query.append("\n\t\t").append("connect by prior ").append(columnaPadre).append(" = ").append(columna);
			query.append("\n\t\t").append("union");
				//HIJOS
					query.append("\n\t\t").append("-- HIJOS");
					query = querySubquery(tableRequestDto, query, mapaWhere, queryParams, columna, tabla, aliasTabla, joins, businessFilters, businessParams);
					query.append("\n\t\t").append("connect by prior ").append(columna).append(" = ").append(columnaPadre);
			query.append("\n\t").append(") jerarquia");	
		}
		
		//CONDICIONES
		query.append("\n\t").append("where 1=1 ");
		//Si tiene criterios aplicar _join_ PADRE/HIJOS
		if (!((List<?>) mapaWhere.get("params")).isEmpty()){
			query.append("\n\t").append("-- JOIN JERARQUIA");
			query.append("\n\t").append("and ").append(aliasTabla.get(0)).append(".").append(columna).append("=jerarquia.PK_JERARQUIA");
		}
		if (!"".equals(joins.toString())){
			query.append("\n\t").append("-- JOINS");
			query.append("\n\t").append(joins);
		}
		if (businessFilters!=null){
			query.append("\n\t").append("-- Condiciones NEGOCIO");
			query.append("\n\t").append(businessFilters.toString().trim());
			queryParams.addAll(businessParams);
		}
		
		//Gestionar selección múltiple 
		query.append("\n\t").append("-- Relacion JERARQUIA");
		if (tableRequestDto.getJerarquia().getParentId()==null || tableRequestDto.getJerarquia().getParentId().equals("")){
			query.append("\n\t").append("start with ").append(columnaPadre).append(" is null");
		} else {
			query.append("\n\t").append("start with ").append(columnaPadre).append(" = ").append(tableRequestDto.getJerarquia().getParentId());
		}
		query.append("\n\t").append("connect by prior ").append(columna).append(" = ").append(columnaPadre);
		
		//Nodos contraídos
		query = filterUnexpanded(tableRequestDto, query, queryParams, columnaPadre);
		
		//Modificar parámetros
		@SuppressWarnings("unchecked")
		List<Object> whereParams = (List<Object>) mapaWhere.get("params");
		whereParams.clear();
		whereParams.addAll(queryParams);
		return query;
	}
	
	/**
	 * Subquery PADRES o HIJOS (interna)
	 */
	protected static <T> StringBuilder querySubquery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, List<Object> queryParams,
			String columna, 
			List<String> tabla, List<String> aliasTabla, StringBuilder joins,
			StringBuilder businessFilters, List<?> businessParams){
		
		@SuppressWarnings("unchecked")
		List<Object> whereParams = (List<Object>) mapaWhere.get("params");
		StringBuffer whereConditions = (StringBuffer) mapaWhere.get("query");
		
		//Condiciones
		String filterSubquery = whereConditions.toString();
		String businessSubquery = (businessFilters!=null) ? businessFilters.toString() : "";
		String joinsSubquery = joins.toString();
		for (String aliasTablaStr : aliasTabla) {
			filterSubquery = filterSubquery.replaceAll("(?i)"+aliasTablaStr+"\\.", "").trim();
			businessSubquery = businessSubquery.replaceAll("(?i)"+aliasTablaStr+"\\.", "").trim();
			joinsSubquery = joinsSubquery.toString().replaceAll("(?i)"+aliasTablaStr+"\\.", "").trim();
		}
		
		String token = tableRequestDto.getJerarquia().getToken();
		query.append("\n\t\t").append("select distinct substr(sys_connect_by_path(").append(columna).append(", '").append(token).append("'),"); 
		query.append("\n\t\t").append("instr(sys_connect_by_path(").append(columna).append(", '").append(token).append("'), '").append(token).append("', -1)+").append(token.length()).append(") PK_JERARQUIA");
		query.append("\n\t\t").append("from ").append(StringUtils.collectionToCommaDelimitedString(tabla));
		query.append("\n\t\t").append("where 1=1 ");
			if (!"".equals(joinsSubquery)){
				query.append("\n\t\t").append("-- JOINS");
				query.append("\n\t\t").append(joinsSubquery);
			}
			if (!"".equals(businessSubquery)){
				query.append("\n\t\t").append("-- Condiciones NEGOCIO");
				query.append("\n\t\t").append(businessSubquery);
				queryParams.addAll(businessParams);
			}
		//Jerarquia
		query.append("\n\t\t").append("start with ").append(columna).append(" in ( "); 
			query.append("\n\t\t\t").append("select ").append(columna);
			query.append("\n\t\t\t").append("from ").append(StringUtils.collectionToCommaDelimitedString(tabla));
			query.append("\n\t\t\t").append("where 1=1 ");
			if (!"".equals(joinsSubquery)){
				query.append("\n\t\t\t").append("-- JOINS");
				query.append("\n\t\t\t").append(joinsSubquery);
			}
			if (!"".equals(businessSubquery)){
				query.append("\n\t\t\t").append("-- Condiciones NEGOCIO");
				query.append("\n\t\t\t").append(businessSubquery);
				queryParams.addAll(businessParams);
			}
			if (!"".equals(filterSubquery)){
				query.append("\n\t\t\t").append("-- Condiciones FILTRO");
				query.append("\n\t\t\t").append(filterSubquery);
				queryParams.addAll(whereParams);
			}
		query.append("\n\t\t").append(")");
		return query;
	}
	
	/**
	 * Filtrar elementos contraidos en la query (interna
	 */
	protected static <T> StringBuilder filterUnexpanded(TableRequestDto tableRequestDto, StringBuilder query, List<Object> params, String columnaPadre){
		if (tableRequestDto.getJerarquia().getTree()!=null && !tableRequestDto.getJerarquia().getTree().equals("")) {
			StringBuilder elems = new StringBuilder();
			String[] arrTree = tableRequestDto.getJerarquia().getTree().split(",");
			for (int i = 0; i < arrTree.length; i++) {
				elems.append("?,");
			}
			elems = new StringBuilder(elems.substring(0, elems.length()-1));
			
			query.append("\n\t").append("-- Registros CONTRAIDOS");
			query.append("\n\t").append("and ").append("").append(columnaPadre).append("").append(" not in (").append(elems).append(")");
			params.addAll(Arrays.asList(tableRequestDto.getJerarquia().getTree().split(",")));
		}
		return query;
	}

	
	/**
	 * HIJOS
	 */
	public static <T> StringBuilder getQueryChildren(
			TableRequestDto tableRequestDto,
			Map<String, ?> mapaWhere, 
			String columna, String columnaPadre,
			List<String> tabla, List<String> aliasTabla
	){
		return getQueryChildren(tableRequestDto, mapaWhere, columna, columnaPadre, tabla, aliasTabla, new StringBuilder(""), null, null, null);
	}
	public static <T> StringBuilder getQueryChildren(
				TableRequestDto tableRequestDto,
				Map<String, ?> mapaWhere, 
				String columna, String columnaPadre,
				List<String> tabla, List<String> aliasTabla, StringBuilder joins
	){
		return getQueryChildren(tableRequestDto, mapaWhere, columna, columnaPadre, tabla, aliasTabla, joins, null, null, null);
	}
	public static <T> StringBuilder getQueryChildren(
			TableRequestDto tableRequestDto,
			Map<String, ?> mapaWhere, 
			String columna, String columnaPadre,
			List<String> tabla, List<String> aliasTabla, StringBuilder joins,
			StringBuilder businessFilters, List<?> businessParams,
			String[] orderByWhiteList
	){

		//Jerarquia (filtro -> hijos del padre)
			//Quitar buscar hijos/descendientes
			Map<String,Object> mapaWhereTMP = new HashMap<String, Object>();
			mapaWhereTMP.put("params", new ArrayList<Object>());
		StringBuilder sqlJerarquiaHijos = getJerarquiaQuery(tableRequestDto, new StringBuilder(), mapaWhereTMP, new ArrayList<Object>(), columna, columnaPadre, tabla, aliasTabla, joins, businessFilters, businessParams);
		//No requiere ordenación ya que es para obetner las PKs de los descendientes

		//Quitar filtrado del padre (obtener todos los elementos para saber su página, línea en página y línea en tabla)
		tableRequestDto.getJerarquia().setParentId(null);
		
		//Jerarquia (all -> metadatos de todos)
		StringBuilder sqlJerarquia = getJerarquiaQuery(tableRequestDto, new StringBuilder(), mapaWhere, new ArrayList<Object>(), columna, columnaPadre, tabla, aliasTabla, joins, businessFilters, businessParams);
		//Ordenar según tabla
		sqlJerarquia.append(TableManager.getOrderBy(tableRequestDto, true, orderByWhiteList));
		
		//Query propia
		StringBuilder sbSQL = new StringBuilder();
		sbSQL.append("\n").append("select ").append(columna).append(TableManager.getMultiselectionSelectOutter(tableRequestDto));
		sbSQL.append("\n").append("from ( ");
		sbSQL.append("\n\t").append("-- Query Jerarquia");
		sbSQL.append("\n\t").append("select ").append(columna).append(TableManager.getMultiselectionSelectInner(tableRequestDto));
		sbSQL.append("\n\t").append(sqlJerarquia.substring(sqlJerarquia.indexOf("from")));
		sbSQL.append(") ");
		sbSQL.append("\n").append("where ").append(columna).append(" in ( ");
		sbSQL.append("\n\t").append("-- Query JerarquiaFiltro");
		sbSQL.append("\n\t").append("select ").append(columna).append(" ");
		if (tableRequestDto.getJerarquia().isChild()){
			//Solo hijos directos
			sbSQL.append("\n\t").append(sqlJerarquiaHijos.substring(sqlJerarquiaHijos.indexOf("from")).replaceAll("1=1", "LEVEL=1"));
		} else {
			//Todos los descendientes
			sbSQL.append("\n\t").append(sqlJerarquiaHijos.substring(sqlJerarquiaHijos.indexOf("from")));
		}
		sbSQL.append("\n").append(") ");
		return sbSQL;
	}

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableManagerJerarquiaGrid.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dto;

import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.ResultSetExtractor;
import org.springframework.util.StringUtils;

/**
 * 
 * @author UDA
 *
 */
public class TableManagerJerarquiaGrid implements java.io.Serializable{

	private static final long serialVersionUID = 2127819481595995328L;
	
	/**
	 * NORMAL - GRID
	 */
	public static <T> StringBuilder getQuery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes, 
			List<String> tabla, List<String> aliasTabla
	){
		return getQuery(tableRequestDto, query, mapaWhere, columna, columnaPadre, columnaParentNodes, tabla, aliasTabla, new StringBuilder(""), null, null);
	}
	public static <T> StringBuilder getQuery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes, 
			List<String> tabla, List<String> aliasTabla, StringBuilder joins
	){
		return getQuery(tableRequestDto, query, mapaWhere, columna, columnaPadre, columnaParentNodes, tabla, aliasTabla, joins, null, null);
	}
	public static <T> StringBuilder getQuery(
			TableRequestDto tableRequestDto,
			StringBuilder query, Map<String, ?> mapaWhere, 
			String columna, String columnaPadre, String columnaParentNodes, 
			List<String> tabla, List<String> aliasTabla, StringBuilder joins,
			StringBuilder businessFilters, List<?> businessParams
	){
		//GRID - JERARQUIA
		query.append("\n\t").append("-- Campos JERARQUIA (grid)");
		query.append("\n\t").append(", decode((select count(1) from ").append(tabla.get(0));
			query.append(" subquery where subquery.").append(columnaPadre).append("=").append(aliasTabla.get(0)).append(".").append(columna);
			query.append(" ), 0, 'false', 'true') as HASCHILDREN");
		query.append("\n\t").append(", sys_connect_by_path(").append(columna).append(", ").append(tableRequestDto.getJerarquia().getToken()).append(") as TREENODES ");
		return TableManagerJerarquia.getQuery(tableRequestDto, query, mapaWhere, columna, columnaPadre, columnaParentNodes, tabla, aliasTabla, joins, businessFilters, businessParams);
	}
	
	
	/**
	 * SELECTED
	 */
	public static <T> StringBuilder getQuerySelectedGrid(
			TableRequestDto tableRequestDto,
			StringBuilder query,  Map<String, ?> mapaWhere,
			Object bean, 
			String columna, String columnaPadre,
			List<String> tabla, List<String> aliasTabla
	){
		return getQuerySelectedGrid(tableRequestDto, query, mapaWhere, bean, columna, columnaPadre, tabla, aliasTabla, new StringBuilder(""), null, null, new ArrayList<String>());
	}
	public static <T> StringBuilder getQuerySelectedGrid(
			TableRequestDto tableRequestDto,
			StringBuilder query,  Map<String, ?> mapaWhere,
			Object bean, 
			String columna, String columnaPadre,
			List<String> tabla, List<String> aliasTabla, StringBuilder joins
	){
		return getQuerySelectedGrid(tableRequestDto, query, mapaWhere, bean, columna, columnaPadre, tabla, aliasTabla, joins, null, null, new ArrayList<String>());
	}
	public static <T> StringBuilder getQuerySelectedGrid(
			TableRequestDto tableRequestDto,
			StringBuilder query,  Map<String, ?> mapaWhere,
			Object bean, 
			String columna, String columnaPadre,
			List<String> tabla, List<String> aliasTabla, StringBuilder joins,
			StringBuilder businessFilters, List<?> businessParams, List<String> businessNames
	){
		
		List<Object> queryParams = new ArrayList<Object>();
		
		//Calcular campos de filtrado (evitar el elemento por el que se ordena)
		StringBuilder filterNames = new StringBuilder("");
		try {
	        PropertyDescriptor[] props = Introspector.getBeanInfo(bean.getClass(), Object.class).getPropertyDescriptors();  
	        for (PropertyDescriptor pd : props) {  
	            String name = pd.getName();  
	            if (pd.getReadMethod().invoke(bean)!=null){
	            	if(tableRequestDto.getSidx().contains(",")) {
	            		String[] arrSidx = tableRequestDto.getSidx().split(",");
	            		if(!Arrays.asList(arrSidx).contains(name)) {
	            			filterNames.append(name).append(", ");
	            		}
	            	} else {
	            		if(!name.equals(tableRequestDto.getSidx())){
	            			filterNames.append(name).append(", ");
	            		}
	            	}
	            }
	        }
		} catch(Exception e){
			throw new RuntimeException();
		}

		//Calcular campos de negocio
		for (String name : businessNames) {  
			filterNames.append(name).append(", ");
		}
		
		query.append("\n").append("select * from ( ");
		query.append("\n\t").append("select ").append(columna).append(" as pk, ceil(rownum/?) page, case when (mod(rownum,?)=0) then ? else TO_CHAR(mod(rownum,?)) end as line ");
		queryParams.add(tableRequestDto.getRows());
		queryParams.add(tableRequestDto.getRows());
		queryParams.add(tableRequestDto.getRows().toString()); //case requiere literal
		queryParams.add(tableRequestDto.getRows());
		query.append("\n\t").append("from ( ");

		query.append("\n\t\t").append("select ").append(filterNames).append(columna).append(", ").append(columnaPadre).append(", ").append(tableRequestDto.getSidx()).append(", rownum ");
		query.append("\n\t\t").append("from ").append(StringUtils.collectionToCommaDelimitedString(tabla));
		query.append("\n\t\t").append("-- Relacion JERARQUIA");
		query.append("\n\t\t").append("start with ").append(columnaPadre).append(" is null "); 
		query.append("\n\t\t").append("connect by prior ").append(columna).append(" = ").append(columnaPadre).append(" ");
		query.append("\n\t\t").append("order siblings by ");
		if(tableRequestDto.getSidx().contains(",")) {
			String[] arrSidx = tableRequestDto.getSidx().split(",");
			String[] arrSord = tableRequestDto.getSord().split(",");
			
			for(int i = 0; i < arrSidx.length ; i++) {
				query.append(arrSidx[i]).append(arrSord[i]);
				if(i < arrSidx.length -1) {
					query.append(",");
				}
			}
		} else {
			query.append(tableRequestDto.getSidx()).append(" ").append(tableRequestDto.getSord());
		}
		
		query.append("\n\t").append(") ").append(aliasTabla.get(0)).append(", (");
		
		//Subqueries
			//PADRES
				query.append("\n\t\t").append("-- PADRES");
				query = TableManagerJerarquia.querySubquery(tableRequestDto, query, mapaWhere, queryParams, columna, tabla, aliasTabla, joins, businessFilters, businessParams);
				query.append("\n\t\t").append("connect by prior ").append(columnaPadre).append(" = ").append(columna);
		query.append("\n\t\t").append("union");
			//HIJOS
				query.append("\n\t\t").append("-- HIJOS");
				query = TableManagerJerarquia.querySubquery(tableRequestDto, query, mapaWhere, queryParams, columna, tabla, aliasTabla, joins, businessFilters, businessParams);
				query.append("\n\t\t").append("connect by prior ").append(columna).append(" = ").append(columnaPadre);
		query.append("\n\t").append(") jerarquia");	
		
		//CONDICIONES
		query.append("\n\t").append("where 1=1 ");
		query.append("\n\t").append("-- JOIN JERARQUIA");
		query.append("\n\t").append("and ").append(aliasTabla.get(0)).append(".").append(columna).append("=jerarquia.PK_JERARQUIA");
		if (!"".equals(joins.toString())){
			query.append("\n\t").append("-- JOINS");
			query.append("\n\t").append(joins);
		}
		if (businessFilters!=null){
			query.append("\n\t").append("-- Condiciones NEGOCIO");
			query.append("\n\t").append(businessFilters.toString().trim());
			queryParams.addAll(businessParams);
		}
		
		query.append("\n\t").append("-- Relacion JERARQUIA");
		query.append("\n\t").append("start with ").append(columnaPadre).append(" is null "); 
		query.append("\n\t").append("connect by prior ").append(columna).append(" = ").append(columnaPadre).append(" ");

		//Nodos contraídos
		query = TableManagerJerarquia.filterUnexpanded(tableRequestDto, query, queryParams, columnaPadre);
		
		query.append("\n\t").append("order siblings by ");
		if(tableRequestDto.getSidx().contains(",")) {
			String[] arrSidx = tableRequestDto.getSidx().split(",");
			String[] arrSord = tableRequestDto.getSord().split(",");
			
			for(int i = 0; i < arrSidx.length ; i++) {
				query.append(arrSidx[i]).append(arrSord[i]);
				if(i < arrSidx.length -1) {
					query.append(",");
				}
			}
		} else {
			query.append(tableRequestDto.getSidx()).append(" ").append(tableRequestDto.getSord());
		}
		query.append("\n").append(") ");

		//Filtrar seleccionados
		if (tableRequestDto.getJerarquia().getParentId()!=null){
			query.append("\n").append("-- Registros SELECCIONADOS");
			query.append("\n").append("where (1,pk) in (");
			StringBuilder selectedParams = new StringBuilder("");
			String[] selected = tableRequestDto.getJerarquia().getParentId().split(",");
			String parsedToken = tableRequestDto.getJerarquia().getToken().substring(1, tableRequestDto.getJerarquia().getToken().length()-1);
			int selected_length = selected.length;
			for (int i = 0; i < selected_length; i++) {
				String elem = selected[i];
				elem = elem.substring(elem.lastIndexOf(parsedToken)+parsedToken.length());
				selectedParams.append("(1,?),");
				queryParams.add(elem);
			}
			query.append(selectedParams.substring(0, selectedParams.length()-1));
			query.append(") ");
		}
		
		//Modificar parámetros
		@SuppressWarnings("unchecked")
		List<Object> whereParams = (List<Object>) mapaWhere.get("params");
		whereParams.clear();
		whereParams.addAll(queryParams);
		return query;
	}

	public static ResultSetExtractor<TreeMap<String, TreeMap<String, String>>> selectedExtractorGrid = new ResultSetExtractor<TreeMap<String, TreeMap<String, String>>>() {
		public TreeMap<String, TreeMap<String, String>> extractData(ResultSet resultSet) throws SQLException, DataAccessException {
			
			TreeMap<String, TreeMap<String, String>> selectedMap = new TreeMap<String, TreeMap<String, String>>();
			while (resultSet.next()) {
				String page = resultSet.getString("PAGE");
				String line = resultSet.getString("LINE");
				String pk = resultSet.getString("PK");
				
				TreeMap<String, String> pageMap = selectedMap.get(page);
				if (pageMap == null){
					pageMap = new TreeMap<String, String>();
				}
				pageMap.put(line, pk);
				
				selectedMap.put(page, pageMap);
			}
			return selectedMap;
		}
	};
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableRequestDto.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dto;

import java.util.ArrayList;
import java.util.List;

import org.apache.commons.lang.StringUtils;
import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;

/**
 * 
 * @author UDA
 *
 */
public class TableRequestDto implements java.io.Serializable {

	private static final long serialVersionUID = 2127819481595995328L;
	
	//Table
	private Long rows;
	private Long page;
	private String sidx;
	private String sord;
	
	// Core
	private TableRequestDto.Core core = new TableRequestDto.Core();
	
	//Jerarquia
	private TableRequestDto.Jerarquia jerarquia = new TableRequestDto.Jerarquia();
	
	//Ordenacion
	private TableRequestDto.Multiselection multiselection = new TableRequestDto.Multiselection();
	
	//Ordenacion
	private TableRequestDto.Multiselection seeker= new TableRequestDto.Multiselection();
	
	
	public static final String SORT_ASC = "ASC";
	public static final String SORT_DESC = "DESC";
	
	
	public TableRequestDto(){}
	public TableRequestDto(Long rows, Long page, String sidx, String sord){
		this.rows = rows;
		this.page = page;
		this.sidx = sidx;
		this.setSord(sord);
	}
	public TableRequestDto(Long rows, Long page, String sidx, String sord, String multiselectionIds, Boolean selectAll){
		this.rows = rows;
		this.page = page;
		this.sidx = sidx;
		this.setSord(sord);
//		this.multiselectionIds = multiselectionIds;
//		this.selectedAll = selectAll;
	}
	
	public Long getRows() {
		return rows;
	}
	public void setRows(Long rows) {
		this.rows = rows;
	}
	public Long getPage() {
		return page;
	}
	public void setPage(Long page) {
		this.page = page;
	}
	public String getSidx() {
		return sidx;
	}
	public void setSidx (String sidx) {
		if (!"".equals(sidx)){ //Posible vacío en petición Ajax (jQuery >= 1.8)
			this.sidx = sidx;
		}
	}
	public String getSord() {
		return sord;
	}
	public void setSord (String sord) {
		if (sord.contains(",")) {
			ArrayList<String> tmpArr = new ArrayList<String>();
			String[] arrSord = sord.split(",");
			for(String str : arrSord) {
				tmpArr.add(TableRequestDto.SORT_DESC.equals(str.trim().toUpperCase())?TableRequestDto.SORT_DESC:TableRequestDto.SORT_ASC);
			}
			
			this.sord =StringUtils.join(tmpArr.toArray(arrSord), ",");
		} else {
			this.sord = TableRequestDto.SORT_DESC.equals(sord.trim().toUpperCase())?TableRequestDto.SORT_DESC:TableRequestDto.SORT_ASC;
		}
	}
	
	
	public TableRequestDto.Core getCore() {
		return core;
	}
	public void setCore(TableRequestDto.Core core) {
		this.core = core;
	}
	
	public TableRequestDto.Multiselection getMultiselection() {
		return multiselection;
	}
	public void setMultiselection(TableRequestDto.Multiselection multiselection) {
		this.multiselection = multiselection;
	}
	
	public TableRequestDto.Multiselection getSeeker() {
		return seeker;
	}
	public void setSeeker(TableRequestDto.Multiselection seeker) {
		this.seeker = seeker;
	}
	public TableRequestDto.Jerarquia getJerarquia() {
		return jerarquia;
	}
	public void setJerarquia(TableRequestDto.Jerarquia jerarquia) {
		this.jerarquia = jerarquia;
	}
	
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(this.getClass().getName()).append(" Object {");
		result.append(" [ rows: ").append(this.rows).append(" ]");
		result.append(" [ page: ").append(this.page).append(" ]");
		result.append(" [ sidx: ").append(this.sidx).append(" ]");
		result.append(" [ sord: ").append(this.sord).append(" ]");
		result.append("}");
		return result.toString();
	}

	//CLASES INTERNAS
	
	public class Core{
		private List<String> pkNames;
		private String pkToken;

		public List<String> getPkNames() {
			return pkNames;
		}

		public void setPkNames(List<String> pkNames) {
			this.pkNames = pkNames;
		}

		public String getPkToken() {
			return pkToken;
		}

		public void setPkToken(String pkToken) {
			this.pkToken = pkToken;
		}
	}
	
	public class Multiselection {
		private String accion;
		private List<String> deselectedIds;
		private List<String> deselectedRowsPerPage;
		private String lastSelectedId;
		private Integer numSelected;
		private Boolean selectedAll;
		private List<String> selectedIds;
		private List<String> selectedRowsPerPage;

		private Class<? extends Object> clazz;

		public String getAccion() {
			return accion;
		}

		public void setAccion(String accion) {
			this.accion = accion;
		}

		public List<String> getDeselectedIds() {
			return deselectedIds;
		}

		public void setDeselectedIds(List<String> deselectedIds) {
			this.deselectedIds = deselectedIds;
		}

		public List<String> getDeselectedRowsPerPage() {
			return deselectedRowsPerPage;
		}

		public void setDeselectedRowsPerPage(List<String> deselectedRowsPerPage) {
			this.deselectedRowsPerPage = deselectedRowsPerPage;
		}

		public String getLastSelectedId() {
			return lastSelectedId;
		}

		public void setLastSelectedId(String lastSelectedId) {
			this.lastSelectedId = lastSelectedId;
		}

		public Integer getNumSelected() {
			return numSelected;
		}

		public void setNumSelected(Integer numSelected) {
			this.numSelected = numSelected;
		}

		public Boolean getSelectedAll() {
			if (selectedAll == null) {
				selectedAll = false;
			}
			return selectedAll;
		}

		public void setSelectedAll(Boolean selectedAll) {
			this.selectedAll = selectedAll;
		}

		public List<String> getSelectedIds() {
			return selectedIds;
		}

		public void setSelectedIds(List<String> selectedIds) {
			this.selectedIds = selectedIds;
		}

		public List<String> getSelectedRowsPerPage() {
			return selectedRowsPerPage;
		}

		public void setSelectedRowsPerPage(List<String> selectedRowsPerPage) {
			this.selectedRowsPerPage = selectedRowsPerPage;
		}

		public List<? extends Object> getSelected() {
			return this.getSelected(this.clazz);
		}
		
		@SuppressWarnings("unchecked")
		public <T extends Object> List<T> getSelected(Class<T> clazz){
			String pkToken = TableRequestDto.this.getCore().getPkToken();
			List<String> pkNames = TableRequestDto.this.getCore().getPkNames();
			
			List<T> selectedIdsList = new ArrayList<T>();
			
			for (String string : selectedIds) {
				BeanWrapper beanWrapper = new BeanWrapperImpl(clazz);
				String[] split = string.split(pkToken);
				for (int i = 0; i < split.length; i++) {
					String string2 = split[i];
					beanWrapper.setPropertyValue(pkNames.get(i), string2);
				}
				
				selectedIdsList.add((T)beanWrapper.getWrappedInstance());
			}
			
			return selectedIdsList;
		}
		
		@SuppressWarnings("unchecked")
		public <T extends Object> void setModel(String strClazz){
			try {
				this.clazz = (Class<T>) Class.forName(strClazz);
			} catch (ClassNotFoundException e) {
				e.printStackTrace();
				/*
				 * FIXME: Gestion error
				 */
			}
		}
	}
	
	public class Jerarquia {
		private String token = "/";		//Separador para los tooltips
		private String tree;			//Nombre elementos expandidos/contraídos
		private String parentId;		//Elemento sobre el que obtener hijos/descendientes
		private boolean child;			//Determina si sólo deben buscarse hijos directos

		public String getToken() {
			return token;
		}
		public void setToken(String token) {
			this.token = token;
		}
		public String getTree() {
			return tree;
		}
		public void setTree(String tree) {
			this.tree = tree;
		}
		public String getParentId() {
			return parentId;
		}
		public void setParentId(String parentId) {
			this.parentId = parentId;
		}
		public boolean isChild() {
			return child;
		}
		public void setChild(boolean child) {
			this.child = child;
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableResponseDto.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.dto;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;

/**
 * Bean contenedor de las propiedades que utiliza el componente table.
 * 
 * @author UDA
 *
 * @param <T> Tipo de bean que se va a representar en el table.
 */
@JsonInclude(Include.NON_NULL)
public class TableResponseDto<T> {

	//Página actual
		private String page = null;
		//Datos de la página
		private List<T> rows = null;
		//Número total de páginas	
		private String total = null;
		//Número total de registros
		private Integer records = null;
		// Parámetros adicionales
		private Map<String,Object> additionalParams = new HashMap<String, Object>();
		
		//Constantes para parámetros adicionales
		public static final String CHILDREN = "children";
		
		/**
		 * Constructor.
		 */
		public TableResponseDto() {
			super();
		}

		/**
		 * Contructor.
		 * 
		 * @param pagination
		 *            Objeto paginación.
		 * @param recordNum
		 *            Numero de registros.
		 * @param rows
		 *            Lista contenedora de los registros.
		 */
		public <U> TableResponseDto(TableRequestDto tableRequestDto, Long recordNum, List<T> rows) {
			this(tableRequestDto, recordNum, null, rows);
		}
		
		/**
		 * Contructor.
		 * 
		 * @param pagination
		 *            Objeto paginación.
		 * @param recordNum
		 *            Numero de registros.
		 * @param total
		 *            Numero de resgistros totales.
		 * @param rows
		 *            Lista contenedora de los registros.
		 */
		public <U> TableResponseDto(TableRequestDto tableRequestDto, Long recordNum, Long total, List<T> rows) {
			this(tableRequestDto, recordNum, total, rows, null);
		}
		
		/**
		 * Contructor.
		 * 
		 * @param pagination
		 *            Objeto paginación.
		 * @param recordNum
		 *            Numero de registros.
		 * @param rows
		 *            Lista contenedora de los registros.
		 * @param reorderedSelection
		 *            Lista con la reordenación de los registros.
		 */
		public <U> TableResponseDto(TableRequestDto tableRequestDto, Long recordNum, List<T> rows, List<TableRowDto<T>> reorderedSelection) {
			this(tableRequestDto, recordNum, null, rows, reorderedSelection);
		}

		/**
		 * Contructor.
		 * 
		 * @param pagination
		 *            Objeto paginación.
		 * @param recordNum
		 *            Numero de registros.
		 * @param total
		 *            Numero de resgistros totales.
		 * @param rows
		 *            Lista contenedora de los registros.
		 * @param reorderedSelection
		 *            Lista con la reordenación de los registros.
		 */
		public <U> TableResponseDto(TableRequestDto tableRequestDto, Long recordNum, Long total, List<T> rows, List<TableRowDto<T>> reorderedSelection) {
			super();
			this.page = (tableRequestDto.getPage()!=null)?tableRequestDto.getPage().toString():"";
			this.rows = rows;
			this.setTotal(recordNum, (tableRequestDto.getRows()!=null)?tableRequestDto.getRows():0);
			this.records = total!=null?total.intValue():recordNum.intValue();
			this.addAdditionalParam("reorderedSelection", reorderedSelection);
			this.addAdditionalParam("selectedAll", tableRequestDto.getMultiselection().getSelectedAll());
		}
		
		
		/**
		 * @return the page
		 */
		public String getPage() {
			return page;
		}
		/**
		 * @param page the page to set
		 */
		public void setPage(String page) {
			this.page = page;
		}
		/**
		 * @return the rows
		 */
		public List<?> getRows() {
			return rows;
		}
		/**
		 * @param rows the rows to set
		 */
		public void setRows(List<T> rows) {
			this.rows = rows;
		}
		/**
		 * @return the total
		 */
		public String getTotal() {
			return total;
		}

		/**
		 * Calcula el numero total de paginas, segun los registros totales y el numero de regitros pro página
		 * 
		 * @param total el número de registros totales
		 * @param rows el número de filas por pagina
		 */
		public void setTotal(Long total, Long rows) {
			double dTotal = total.doubleValue();
			double dRows = rows.doubleValue();
			double totalPages = (total > 0) ? Math.ceil(dTotal / dRows) : 0;
			
			this.total = String.valueOf((int)totalPages);
		}
		/**
		 * @return the records
		 */
		public Integer getRecords() {
			return records;
		}
		/**
		 * @param records the records to set
		 */
		public void setRecords(Integer records) {
			this.records = records;
		}
		
		/*
		 * Funciones asociadas a la gestión de parámetros adicionales
		 */
		/**
		 * Añade un parámetro adicional.
		 * 
		 * @param key
		 *            Nombre del parámetro.
		 * @param param
		 *            Objeto a admacenar.
		 */
		public void addAdditionalParam(String key, Object param){
			this.additionalParams.put(key, param);
		}
		
		/**
		 * Recupera un parámetro adicional.
		 * 
		 * @param key
		 *            Nombre del parámetro.
		 * @return Parámetro almacenado.
		 */
		public Object getAdditionalParam(String name) {
			return this.additionalParams.get(name);
		}
		
		/**
		 * Elimina un parámetro adicional de estructura.
		 * 
		 * @param key
		 *            Nombre del parámetro.
		 */
		public void removeAdditionalParam(String name) {
			this.additionalParams.remove(name);
		}
		
		/**
		 * Devuelve el mapa que almacena los parámetros adicionales.
		 * 
		 * @param name
		 * @return
		 */
		@JsonIgnore
		public Map<String,Object> getAdditionalParamsMap() {
			return this.additionalParams;
		}

		/**
		 * Método "any getter" necesario para la serialización del contenido del
		 * mapa.
		 * 
		 * @return Mapa que contiene los parámetros adicionales.
		 */
	    @JsonAnyGetter
	    public Map<String,Object> anyAdditionalParams() {
	        return this.additionalParams;
	    }

	    /**
		 * Método "any setter" necesario para la deserialización del parámetros al mapa
		 * 
		 * @return Mapa que contiene los parámetros adicionales.
		 */
	    @JsonAnySetter
	    public void set(String name, Object value) {
	    	this.additionalParams.put(name, value);
	    }
		
	    /*
		 * Funciones auxiliares
		 */
	    public void setReorderedSelection(List<TableRowDto<T>> reorderedSelection){
	    	
	    }
	    
	    public void setReorderedSeeker(List<TableRowDto<T>> reorderedSeeker){
	    	
	    }
	    
		public String toString() {
			StringBuilder result = new StringBuilder();
			result.append(this.getClass().getName()).append(" Object {");
			result.append(" [ page: ").append(this.page).append(" ]");
			result.append(" [ rows: ").append(this.rows).append(" ]");
			result.append(" [ total: ").append(this.total).append(" ]");
			result.append(" [ records: ").append(this.records).append(" ]");
			result.append("}");
			return result.toString();
		}
		
//		/**
//		 * Procesa la estructura reorderedSelection para completar los datos a
//		 * partir de la información de la paginación.
//		 * 
//		 * @param reorderedSelection
//		 *            Lista de registros reordenados.
//		 * @param pagination
//		 *            Objeto paginación.
//		 * @return Lista procesada de elementos reordenados.
//		 */
//		private List<TableRowDto<T>> processReorderedSelection(List<TableRowDto<T>> reorderedSelection, Pagination pagination){
//			if (reorderedSelection != null && pagination != null){
//				List<TableRowDto<T>> proccesedReorderedSelection = new ArrayList<TableRowDto<T>>(reorderedSelection);
//				for (TableRowDto<T> tableRow : proccesedReorderedSelection) {
//					Integer rowNum = tableRow.getTableLine()-1;
//					Long page = (rowNum/pagination.getRows())+1;
//					
//					tableRow.setPage(page.intValue());
//					Long rowLine = tableRow.getTableLine()%pagination.getRows();
//					tableRow.setTableLine(rowLine.intValue());
//				}
//				return proccesedReorderedSelection;
//			}
//			return reorderedSelection;
//		}
	}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/dto/TableRowDto.java
================================================
package com.ejie.x38.dto;

import java.util.HashMap;
import java.util.Map;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.annotation.JsonProperty;

public class TableRowDto<T> {
	
	@JsonIgnore
	private Map<String, String> pkMap = new HashMap<String, String>();
	
	private Integer page;
	private Integer pageLine;
	private Integer tableLine;
	
	@JsonInclude(content = Include.NON_NULL)
	@JsonProperty("pk")
	private T model;
	
	
	public TableRowDto() {
		super();
	}
	
	/**
	 * @param model
	 */
	public TableRowDto(T model) {
		super();
		this.model = model;
	}

	/**
	 * @param pkMap
	 * @param page
	 * @param pageLine
	 * @param tableLine
	 */
	public TableRowDto(Map<String, String> pkMap, Integer page,
			Integer pageLine, Integer tableLine) {
		super();
		this.pkMap = pkMap;
		this.page = page;
		this.pageLine = pageLine;
		this.tableLine = tableLine;
	}

	/**
	 * @param pkMap
	 * @param page
	 * @param pageLine
	 * @param tableLine
	 * @param model
	 */
	public TableRowDto(Map<String, String> pkMap, Integer page,
			Integer pageLine, Integer tableLine, T model) {
		super();
		this.pkMap = pkMap;
		this.page = page;
		this.pageLine = pageLine;
		this.tableLine = tableLine;
		this.model = model;
	}
	
	public Map<String, String> getPkMap() {
		return pkMap;
	}
	public void setPkMap(Map<String, String> pkMap) {
		this.pkMap = pkMap;
	}
	public Integer getPage() {
		return page;
	}
	public void setPage(Integer page) {
		this.page = page;
	}
	public Integer getPageLine() {
		return pageLine;
	}
	public void setPageLine(Integer pageLine) {
		this.pageLine = pageLine;
	}
	public Integer getTableLine() {
		return tableLine;
	}
	public void setTableLine(Integer tableLine) {
		this.tableLine = tableLine;
	}
	public T getModel() {
		return model;
	}
	public void setModel(T model) {
		this.model = model;
	}
	public void addPrimaryKey(String pkName, String pkValue){
		this.pkMap.put(pkName, pkValue);
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/generic/model/SelectGeneric.java
================================================
package com.ejie.x38.generic.model;

import java.util.ArrayList;

/** Entidad que permite construir la estructura necesaria para el componente select.
 * @since 5.2.0
*/
public class SelectGeneric implements java.io.Serializable {
	private static final long serialVersionUID = 1L;
	
	private String id;
	private String text;
	private String data;
	private ArrayList<Object> children;
	private String style;
	
	public SelectGeneric() {
		super();
	}

	public SelectGeneric(String value, String label) {
		super();
		this.id = value;
		this.text = label;
	}

	public SelectGeneric(String value, String label, ArrayList<Object> children) {
		super();
		this.id = value;
		this.text = label;
		this.children = children;
	}

	public SelectGeneric(String value, String label, String style) {
		super();
		this.id = value;
		this.text = label;
		this.style = style;
	}

	public SelectGeneric(String value, String label, ArrayList<Object> children, String style) {
		super();
		this.id = value;
		this.text = label;
		this.children = children;
		this.style = style;
	}

	public SelectGeneric(String value, String label, String data, ArrayList<Object> children, String style) {
		super();
		this.id = value;
		this.text = label;
		this.data = data;
		this.children = children;
		this.style = style;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getText() {
		return text;
	}

	public void setText(String text) {
		this.text = text;
	}

	public String getData() {
		return data;
	}

	public void setData(String data) {
		this.data = data;
	}

	public ArrayList<Object> getChildren() {
		return children;
	}

	public void setChildren(ArrayList<Object> children) {
		this.children = children;
	}

	public String getStyle() {
		return style;
	}

	public void setStyle(String style) {
		this.style = style;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/CDL.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/**
 * This provides static methods to convert comma delimited text into a
 * JSONArray, and to covert a JSONArray into comma delimited text. Comma
 * delimited text is a very popular format for data interchange. It is
 * understood by most database, spreadsheet, and organizer programs.
 * <p>
 * Each row of text represents a row in a table or a data record. Each row
 * ends with a NEWLINE character. Each row contains one or more values.
 * Values are separated by commas. A value can contain any character except
 * for comma, unless is is wrapped in single quotes or double quotes.
 * <p>
 * The first row usually contains the names of the columns.
 * <p>
 * A comma delimited list can be converted into a JSONArray of JSONObjects.
 * The names for the elements in the JSONObjects can be taken from the names
 * in the first row.
 * @author JSON.org
 * @version 2010-12-24
 */
public class CDL {

    /**
     * Get the next value. The value can be wrapped in quotes. The value can
     * be empty.
     * @param x A JSONTokener of the source text.
     * @return The value string, or null if empty.
     * @throws JSONException if the quoted string is badly formed.
     */
    private static String getValue(JSONTokener x) throws JSONException {
        char c;
        char q;
        StringBuffer sb;
        do {
            c = x.next();
        } while (c == ' ' || c == '\t');
        switch (c) {
        case 0:
            return null;
        case '"':
        case '\'':
            q = c;
            sb = new StringBuffer();
            for (;;) {
                c = x.next();
                if (c == q) {
                    break;
                }
                if (c == 0 || c == '\n' || c == '\r') {
                    throw x.syntaxError("Missing close quote '" + q + "'.");
                }
                sb.append(c);
            }
            return sb.toString();
        case ',':
            x.back();
            return "";
        default:
            x.back();
            return x.nextTo(',');
        }
    }

    /**
     * Produce a JSONArray of strings from a row of comma delimited values.
     * @param x A JSONTokener of the source text.
     * @return A JSONArray of strings.
     * @throws JSONException
     */
    public static JSONArray rowToJSONArray(JSONTokener x) throws JSONException {
        JSONArray ja = new JSONArray();
        for (;;) {
            String value = getValue(x);
            char c = x.next();
            if (value == null || 
                    (ja.length() == 0 && value.length() == 0 && c != ',')) {
                return null;
            }
            ja.put(value);
            for (;;) {                
                if (c == ',') {
                    break;
                }
                if (c != ' ') {
                    if (c == '\n' || c == '\r' || c == 0) {
                        return ja;
                    }
                    throw x.syntaxError("Bad character '" + c + "' (" +
                            (int)c + ").");
                }
                c = x.next();
            }
        }
    }

    /**
     * Produce a JSONObject from a row of comma delimited text, using a
     * parallel JSONArray of strings to provides the names of the elements.
     * @param names A JSONArray of names. This is commonly obtained from the
     *  first row of a comma delimited text file using the rowToJSONArray
     *  method.
     * @param x A JSONTokener of the source text.
     * @return A JSONObject combining the names and values.
     * @throws JSONException
     */
    public static JSONObject rowToJSONObject(JSONArray names, JSONTokener x)
            throws JSONException {
        JSONArray ja = rowToJSONArray(x);
        return ja != null ? ja.toJSONObject(names) :  null;
    }

    /**
     * Produce a comma delimited text row from a JSONArray. Values containing
     * the comma character will be quoted. Troublesome characters may be 
     * removed.
     * @param ja A JSONArray of strings.
     * @return A string ending in NEWLINE.
     */
    public static String rowToString(JSONArray ja) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < ja.length(); i += 1) {
            if (i > 0) {
                sb.append(',');
            }
            Object object = ja.opt(i);
            if (object != null) {
                String string = object.toString();
                if (string.length() > 0 && (string.indexOf(',') >= 0 || 
                        string.indexOf('\n') >= 0 || string.indexOf('\r') >= 0 || 
                        string.indexOf(0) >= 0 || string.charAt(0) == '"')) {
                    sb.append('"');
                    int length = string.length();
                    for (int j = 0; j < length; j += 1) {
                        char c = string.charAt(j);
                        if (c >= ' ' && c != '"') {
                            sb.append(c);
                        }
                    }
                    sb.append('"');
                } else {
                    sb.append(string);
                }
            }
        }
        sb.append('\n');
        return sb.toString();
    }

    /**
     * Produce a JSONArray of JSONObjects from a comma delimited text string,
     * using the first row as a source of names.
     * @param string The comma delimited text.
     * @return A JSONArray of JSONObjects.
     * @throws JSONException
     */
    public static JSONArray toJSONArray(String string) throws JSONException {
        return toJSONArray(new JSONTokener(string));
    }

    /**
     * Produce a JSONArray of JSONObjects from a comma delimited text string,
     * using the first row as a source of names.
     * @param x The JSONTokener containing the comma delimited text.
     * @return A JSONArray of JSONObjects.
     * @throws JSONException
     */
    public static JSONArray toJSONArray(JSONTokener x) throws JSONException {
        return toJSONArray(rowToJSONArray(x), x);
    }

    /**
     * Produce a JSONArray of JSONObjects from a comma delimited text string
     * using a supplied JSONArray as the source of element names.
     * @param names A JSONArray of strings.
     * @param string The comma delimited text.
     * @return A JSONArray of JSONObjects.
     * @throws JSONException
     */
    public static JSONArray toJSONArray(JSONArray names, String string)
            throws JSONException {
        return toJSONArray(names, new JSONTokener(string));
    }

    /**
     * Produce a JSONArray of JSONObjects from a comma delimited text string
     * using a supplied JSONArray as the source of element names.
     * @param names A JSONArray of strings.
     * @param x A JSONTokener of the source text.
     * @return A JSONArray of JSONObjects.
     * @throws JSONException
     */
    public static JSONArray toJSONArray(JSONArray names, JSONTokener x)
            throws JSONException {
        if (names == null || names.length() == 0) {
            return null;
        }
        JSONArray ja = new JSONArray();
        for (;;) {
            JSONObject jo = rowToJSONObject(names, x);
            if (jo == null) {
                break;
            }
            ja.put(jo);
        }
        if (ja.length() == 0) {
            return null;
        }
        return ja;
    }


    /**
     * Produce a comma delimited text from a JSONArray of JSONObjects. The
     * first row will be a list of names obtained by inspecting the first
     * JSONObject.
     * @param ja A JSONArray of JSONObjects.
     * @return A comma delimited text.
     * @throws JSONException
     */
    public static String toString(JSONArray ja) throws JSONException {
        JSONObject jo = ja.optJSONObject(0);
        if (jo != null) {
            JSONArray names = jo.names();
            if (names != null) {
                return rowToString(names) + toString(names, ja);
            }
        }
        return null;
    }

    /**
     * Produce a comma delimited text from a JSONArray of JSONObjects using
     * a provided list of names. The list of names is not included in the
     * output.
     * @param names A JSONArray of strings.
     * @param ja A JSONArray of JSONObjects.
     * @return A comma delimited text.
     * @throws JSONException
     */
    public static String toString(JSONArray names, JSONArray ja)
            throws JSONException {
        if (names == null || names.length() == 0) {
            return null;
        }
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < ja.length(); i += 1) {
            JSONObject jo = ja.optJSONObject(i);
            if (jo != null) {
                sb.append(rowToString(jo.toJSONArray(names)));
            }
        }
        return sb.toString();
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/Cookie.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/**
 * Convert a web browser cookie specification to a JSONObject and back.
 * JSON and Cookies are both notations for name/value pairs.
 * @author JSON.org
 * @version 2010-12-24
 */
public class Cookie {

    /**
     * Produce a copy of a string in which the characters '+', '%', '=', ';'
     * and control characters are replaced with "%hh". This is a gentle form
     * of URL encoding, attempting to cause as little distortion to the
     * string as possible. The characters '=' and ';' are meta characters in
     * cookies. By convention, they are escaped using the URL-encoding. This is
     * only a convention, not a standard. Often, cookies are expected to have
     * encoded values. We encode '=' and ';' because we must. We encode '%' and
     * '+' because they are meta characters in URL encoding.
     * @param string The source string.
     * @return       The escaped result.
     */
    public static String escape(String string) {
        char         c;
        String       s = string.trim();
        StringBuffer sb = new StringBuffer();
        int          length = s.length();
        for (int i = 0; i < length; i += 1) {
            c = s.charAt(i);
            if (c < ' ' || c == '+' || c == '%' || c == '=' || c == ';') {
                sb.append('%');
                sb.append(Character.forDigit((char)((c >>> 4) & 0x0f), 16));
                sb.append(Character.forDigit((char)(c & 0x0f), 16));
            } else {
                sb.append(c);
            }
        }
        return sb.toString();
    }


    /**
     * Convert a cookie specification string into a JSONObject. The string
     * will contain a name value pair separated by '='. The name and the value
     * will be unescaped, possibly converting '+' and '%' sequences. The
     * cookie properties may follow, separated by ';', also represented as
     * name=value (except the secure property, which does not have a value).
     * The name will be stored under the key "name", and the value will be
     * stored under the key "value". This method does not do checking or
     * validation of the parameters. It only converts the cookie string into
     * a JSONObject.
     * @param string The cookie specification string.
     * @return A JSONObject containing "name", "value", and possibly other
     *  members.
     * @throws JSONException
     */
    public static JSONObject toJSONObject(String string) throws JSONException {
        String         name;
        JSONObject     jo = new JSONObject();
        Object         value;
        JSONTokener x = new JSONTokener(string);
        jo.put("name", x.nextTo('='));
        x.next('=');
        jo.put("value", x.nextTo(';'));
        x.next();
        while (x.more()) {
            name = unescape(x.nextTo("=;"));
            if (x.next() != '=') {
                if (name.equals("secure")) {
                    value = Boolean.TRUE;
                } else {
                    throw x.syntaxError("Missing '=' in cookie parameter.");
                }
            } else {
                value = unescape(x.nextTo(';'));
                x.next();
            }
            jo.put(name, value);
        }
        return jo;
    }


    /**
     * Convert a JSONObject into a cookie specification string. The JSONObject
     * must contain "name" and "value" members.
     * If the JSONObject contains "expires", "domain", "path", or "secure"
     * members, they will be appended to the cookie specification string.
     * All other members are ignored.
     * @param jo A JSONObject
     * @return A cookie specification string
     * @throws JSONException
     */
    public static String toString(JSONObject jo) throws JSONException {
        StringBuffer sb = new StringBuffer();

        sb.append(escape(jo.getString("name")));
        sb.append("=");
        sb.append(escape(jo.getString("value")));
        if (jo.has("expires")) {
            sb.append(";expires=");
            sb.append(jo.getString("expires"));
        }
        if (jo.has("domain")) {
            sb.append(";domain=");
            sb.append(escape(jo.getString("domain")));
        }
        if (jo.has("path")) {
            sb.append(";path=");
            sb.append(escape(jo.getString("path")));
        }
        if (jo.optBoolean("secure")) {
            sb.append(";secure");
        }
        return sb.toString();
    }

    /**
     * Convert <code>%</code><i>hh</i> sequences to single characters, and
     * convert plus to space.
     * @param string A string that may contain
     *      <code>+</code>&nbsp;<small>(plus)</small> and
     *      <code>%</code><i>hh</i> sequences.
     * @return The unescaped string.
     */
    public static String unescape(String string) {
        int length = string.length();
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < length; ++i) {
            char c = string.charAt(i);
            if (c == '+') {
                c = ' ';
            } else if (c == '%' && i + 2 < length) {
                int d = JSONTokener.dehexchar(string.charAt(i + 1));
                int e = JSONTokener.dehexchar(string.charAt(i + 2));
                if (d >= 0 && e >= 0) {
                    c = (char)(d * 16 + e);
                    i += 2;
                }
            }
            sb.append(c);
        }
        return sb.toString();
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/CookieList.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import java.util.Iterator;

/**
 * Convert a web browser cookie list string to a JSONObject and back.
 * @author JSON.org
 * @version 2010-12-24
 */
public class CookieList {

    /**
     * Convert a cookie list into a JSONObject. A cookie list is a sequence
     * of name/value pairs. The names are separated from the values by '='.
     * The pairs are separated by ';'. The names and the values
     * will be unescaped, possibly converting '+' and '%' sequences.
     *
     * To add a cookie to a cooklist,
     * cookielistJSONObject.put(cookieJSONObject.getString("name"),
     *     cookieJSONObject.getString("value"));
     * @param string  A cookie list string
     * @return A JSONObject
     * @throws JSONException
     */
    public static JSONObject toJSONObject(String string) throws JSONException {
        JSONObject jo = new JSONObject();
        JSONTokener x = new JSONTokener(string);
        while (x.more()) {
            String name = Cookie.unescape(x.nextTo('='));
            x.next('=');
            jo.put(name, Cookie.unescape(x.nextTo(';')));
            x.next();
        }
        return jo;
    }


    /**
     * Convert a JSONObject into a cookie list. A cookie list is a sequence
     * of name/value pairs. The names are separated from the values by '='.
     * The pairs are separated by ';'. The characters '%', '+', '=', and ';'
     * in the names and values are replaced by "%hh".
     * @param jo A JSONObject
     * @return A cookie list string
     * @throws JSONException
     */
    @SuppressWarnings("rawtypes")
	public static String toString(JSONObject jo) throws JSONException {
        boolean      b = false;
        Iterator     keys = jo.keys();
        String       string;
        StringBuffer sb = new StringBuffer();
        while (keys.hasNext()) {
            string = keys.next().toString();
            if (!jo.isNull(string)) {
                if (b) {
                    sb.append(';');
                }
                sb.append(Cookie.escape(string));
                sb.append("=");
                sb.append(Cookie.escape(jo.getString(string)));
                b = true;
            }
        }
        return sb.toString();
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/HTTP.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import java.util.Iterator;

/**
 * Convert an HTTP header to a JSONObject and back.
 * @author JSON.org
 * @version 2010-12-24
 */
public class HTTP {

    /** Carriage return/line feed. */
    public static final String CRLF = "\r\n";

    /**
     * Convert an HTTP header string into a JSONObject. It can be a request
     * header or a response header. A request header will contain
     * <pre>{
     *    Method: "POST" (for example),
     *    "Request-URI": "/" (for example),
     *    "HTTP-Version": "HTTP/1.1" (for example)
     * }</pre>
     * A response header will contain
     * <pre>{
     *    "HTTP-Version": "HTTP/1.1" (for example),
     *    "Status-Code": "200" (for example),
     *    "Reason-Phrase": "OK" (for example)
     * }</pre>
     * In addition, the other parameters in the header will be captured, using
     * the HTTP field names as JSON names, so that <pre>
     *    Date: Sun, 26 May 2002 18:06:04 GMT
     *    Cookie: Q=q2=PPEAsg--; B=677gi6ouf29bn&b=2&f=s
     *    Cache-Control: no-cache</pre>
     * become
     * <pre>{...
     *    Date: "Sun, 26 May 2002 18:06:04 GMT",
     *    Cookie: "Q=q2=PPEAsg--; B=677gi6ouf29bn&b=2&f=s",
     *    "Cache-Control": "no-cache",
     * ...}</pre>
     * It does no further checking or conversion. It does not parse dates.
     * It does not do '%' transforms on URLs.
     * @param string An HTTP header string.
     * @return A JSONObject containing the elements and attributes
     * of the XML string.
     * @throws JSONException
     */
    public static JSONObject toJSONObject(String string) throws JSONException {
        JSONObject     jo = new JSONObject();
        HTTPTokener    x = new HTTPTokener(string);
        String         token;

        token = x.nextToken();
        if (token.toUpperCase().startsWith("HTTP")) {

// Response

            jo.put("HTTP-Version", token);
            jo.put("Status-Code", x.nextToken());
            jo.put("Reason-Phrase", x.nextTo('\0'));
            x.next();

        } else {

// Request

            jo.put("Method", token);
            jo.put("Request-URI", x.nextToken());
            jo.put("HTTP-Version", x.nextToken());
        }

// Fields

        while (x.more()) {
            String name = x.nextTo(':');
            x.next(':');
            jo.put(name, x.nextTo('\0'));
            x.next();
        }
        return jo;
    }


    /**
     * Convert a JSONObject into an HTTP header. A request header must contain
     * <pre>{
     *    Method: "POST" (for example),
     *    "Request-URI": "/" (for example),
     *    "HTTP-Version": "HTTP/1.1" (for example)
     * }</pre>
     * A response header must contain
     * <pre>{
     *    "HTTP-Version": "HTTP/1.1" (for example),
     *    "Status-Code": "200" (for example),
     *    "Reason-Phrase": "OK" (for example)
     * }</pre>
     * Any other members of the JSONObject will be output as HTTP fields.
     * The result will end with two CRLF pairs.
     * @param jo A JSONObject
     * @return An HTTP header string.
     * @throws JSONException if the object does not contain enough
     *  information.
     */
    @SuppressWarnings("rawtypes")
	public static String toString(JSONObject jo) throws JSONException {
        Iterator     keys = jo.keys();
        String       string;
        StringBuffer sb = new StringBuffer();
        if (jo.has("Status-Code") && jo.has("Reason-Phrase")) {
            sb.append(jo.getString("HTTP-Version"));
            sb.append(' ');
            sb.append(jo.getString("Status-Code"));
            sb.append(' ');
            sb.append(jo.getString("Reason-Phrase"));
        } else if (jo.has("Method") && jo.has("Request-URI")) {
            sb.append(jo.getString("Method"));
            sb.append(' ');
            sb.append('"');
            sb.append(jo.getString("Request-URI"));
            sb.append('"');
            sb.append(' ');
            sb.append(jo.getString("HTTP-Version"));
        } else {
            throw new JSONException("Not enough material for an HTTP header.");
        }
        sb.append(CRLF);
        while (keys.hasNext()) {
            string = keys.next().toString();
            if (!"HTTP-Version".equals(string)      && !"Status-Code".equals(string) &&
                    !"Reason-Phrase".equals(string) && !"Method".equals(string) &&
                    !"Request-URI".equals(string)   && !jo.isNull(string)) {
                sb.append(string);
                sb.append(": ");
                sb.append(jo.getString(string));
                sb.append(CRLF);
            }
        }
        sb.append(CRLF);
        return sb.toString();
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/HTTPTokener.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/**
 * The HTTPTokener extends the JSONTokener to provide additional methods
 * for the parsing of HTTP headers.
 * @author JSON.org
 * @version 2010-12-24
 */
public class HTTPTokener extends JSONTokener {

    /**
     * Construct an HTTPTokener from a string.
     * @param string A source string.
     */
    public HTTPTokener(String string) {
        super(string);
    }


    /**
     * Get the next token or string. This is used in parsing HTTP headers.
     * @throws JSONException
     * @return A String.
     */
    public String nextToken() throws JSONException {
        char c;
        char q;
        StringBuffer sb = new StringBuffer();
        do {
            c = next();
        } while (Character.isWhitespace(c));
        if (c == '"' || c == '\'') {
            q = c;
            for (;;) {
                c = next();
                if (c < ' ') {
                    throw syntaxError("Unterminated string.");
                }
                if (c == q) {
                    return sb.toString();
                }
                sb.append(c);
            }
        } 
        for (;;) {
            if (c == 0 || Character.isWhitespace(c)) {
                return sb.toString();
            }
            sb.append(c);
            c = next();
        }
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONArray.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * A JSONArray is an ordered sequence of values. Its external text form is a
 * string wrapped in square brackets with commas separating the values. The
 * internal form is an object having <code>get</code> and <code>opt</code>
 * methods for accessing the values by index, and <code>put</code> methods for
 * adding or replacing values. The values can be any of these types:
 * <code>Boolean</code>, <code>JSONArray</code>, <code>JSONObject</code>,
 * <code>Number</code>, <code>String</code>, or the
 * <code>JSONObject.NULL object</code>.
 * <p>
 * The constructor can convert a JSON text into a Java object. The
 * <code>toString</code> method converts to JSON text.
 * <p>
 * A <code>get</code> method returns a value if one can be found, and throws an
 * exception if one cannot be found. An <code>opt</code> method returns a
 * default value instead of throwing an exception, and so is useful for
 * obtaining optional values.
 * <p>
 * The generic <code>get()</code> and <code>opt()</code> methods return an
 * object which you can cast or query for type. There are also typed
 * <code>get</code> and <code>opt</code> methods that do type checking and type
 * coercion for you.
 * <p>
 * The texts produced by the <code>toString</code> methods strictly conform to
 * JSON syntax rules. The constructors are more forgiving in the texts they will
 * accept:
 * <ul>
 * <li>An extra <code>,</code>&nbsp;<small>(comma)</small> may appear just
 * before the closing bracket.</li>
 * <li>The <code>null</code> value will be inserted when there is <code>,</code>
 * &nbsp;<small>(comma)</small> elision.</li>
 * <li>Strings may be quoted with <code>'</code>&nbsp;<small>(single
 * quote)</small>.</li>
 * <li>Strings do not need to be quoted at all if they do not begin with a quote
 * or single quote, and if they do not contain leading or trailing spaces, and
 * if they do not contain any of these characters:
 * <code>{ } [ ] / \ : , = ; #</code> and if they do not look like numbers and
 * if they are not the reserved words <code>true</code>, <code>false</code>, or
 * <code>null</code>.</li>
 * <li>Values can be separated by <code>;</code> <small>(semicolon)</small> as
 * well as by <code>,</code> <small>(comma)</small>.</li>
 * </ul>
 *
 * @author JSON.org
 * @version 2012-04-20
 */
public class JSONArray {


    /**
     * The arrayList where the JSONArray's properties are kept.
     */
    private final ArrayList<Object> myArrayList;


    /**
     * Construct an empty JSONArray.
     */
    public JSONArray() {
        this.myArrayList = new ArrayList<Object>();
    }

    /**
     * Construct a JSONArray from a JSONTokener.
     * @param x A JSONTokener
     * @throws JSONException If there is a syntax error.
     */
    public JSONArray(JSONTokener x) throws JSONException {
        this();
        if (x.nextClean() != '[') {
            throw x.syntaxError("A JSONArray text must start with '['");
        }
        if (x.nextClean() != ']') {
            x.back();
            for (;;) {
                if (x.nextClean() == ',') {
                    x.back();
                    this.myArrayList.add(JSONObject.NULL);
                } else {
                    x.back();
                    this.myArrayList.add(x.nextValue());
                }
                switch (x.nextClean()) {
                case ';':
                case ',':
                    if (x.nextClean() == ']') {
                        return;
                    }
                    x.back();
                    break;
                case ']':
                    return;
                default:
                    throw x.syntaxError("Expected a ',' or ']'");
                }
            }
        }
    }

    

    /**
     * Construct a JSONArray from a source JSON text.
     * @param source     A string that begins with
     * <code>[</code>&nbsp;<small>(left bracket)</small>
     *  and ends with <code>]</code>&nbsp;<small>(right bracket)</small>.
     *  @throws JSONException If there is a syntax error.
     */
    public JSONArray(String source) throws JSONException {
        this(new JSONTokener(source));
    }


    /**
     * Construct a JSONArray from a Collection.
     * @param collection     A Collection.
     */
    public  <T extends Object> JSONArray(Collection<T> collection) {
        this.myArrayList = new ArrayList<Object>();
        if (collection != null) {
            Iterator<T> iter = collection.iterator();
            while (iter.hasNext()) {
                this.myArrayList.add(JSONObject.wrap(iter.next()));
            }
        }
    }


    /**
     * Construct a JSONArray from an array
     * @throws JSONException If not an array.
     */
    public JSONArray(Object array) throws JSONException {
        this();
        if (array.getClass().isArray()) {
            int length = Array.getLength(array);
            for (int i = 0; i < length; i += 1) {
                this.put(JSONObject.wrap(Array.get(array, i)));
            }
        } else {
            throw new JSONException(
"JSONArray initial value should be a string or collection or array.");
        }
    }


    /**
     * Get the object value associated with an index.
     * @param index
     *  The index must be between 0 and length() - 1.
     * @return An object value.
     * @throws JSONException If there is no value for the index.
     */
    public Object get(int index) throws JSONException {
        Object object = this.opt(index);
        if (object == null) {
            throw new JSONException("JSONArray[" + index + "] not found.");
        }
        return object;
    }


    /**
     * Get the boolean value associated with an index.
     * The string values "true" and "false" are converted to boolean.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The truth.
     * @throws JSONException If there is no value for the index or if the
     *  value is not convertible to boolean.
     */
    public boolean getBoolean(int index) throws JSONException {
        Object object = this.get(index);
        if (object.equals(Boolean.FALSE) ||
                (object instanceof String &&
                ((String)object).equalsIgnoreCase("false"))) {
            return false;
        } else if (object.equals(Boolean.TRUE) ||
                (object instanceof String &&
                ((String)object).equalsIgnoreCase("true"))) {
            return true;
        }
        throw new JSONException("JSONArray[" + index + "] is not a boolean.");
    }


    /**
     * Get the double value associated with an index.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The value.
     * @throws   JSONException If the key is not found or if the value cannot
     *  be converted to a number.
     */
    public double getDouble(int index) throws JSONException {
        Object object = this.get(index);
        try {
            return object instanceof Number
                ? ((Number)object).doubleValue()
                : Double.parseDouble((String)object);
        } catch (Exception e) {
            throw new JSONException("JSONArray[" + index +
                "] is not a number.");
        }
    }


    /**
     * Get the int value associated with an index.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The value.
     * @throws   JSONException If the key is not found or if the value is not a number.
     */
    public int getInt(int index) throws JSONException {
        Object object = this.get(index);
        try {
            return object instanceof Number
                ? ((Number)object).intValue()
                : Integer.parseInt((String)object);
        } catch (Exception e) {
            throw new JSONException("JSONArray[" + index +
                "] is not a number.");
        }
    }


    /**
     * Get the JSONArray associated with an index.
     * @param index The index must be between 0 and length() - 1.
     * @return      A JSONArray value.
     * @throws JSONException If there is no value for the index. or if the
     * value is not a JSONArray
     */
    public JSONArray getJSONArray(int index) throws JSONException {
        Object object = this.get(index);
        if (object instanceof JSONArray) {
            return (JSONArray)object;
        }
        throw new JSONException("JSONArray[" + index +
                "] is not a JSONArray.");
    }


    /**
     * Get the JSONObject associated with an index.
     * @param index subscript
     * @return      A JSONObject value.
     * @throws JSONException If there is no value for the index or if the
     * value is not a JSONObject
     */
    public JSONObject getJSONObject(int index) throws JSONException {
        Object object = this.get(index);
        if (object instanceof JSONObject) {
            return (JSONObject)object;
        }
        throw new JSONException("JSONArray[" + index +
            "] is not a JSONObject.");
    }


    /**
     * Get the long value associated with an index.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The value.
     * @throws   JSONException If the key is not found or if the value cannot
     *  be converted to a number.
     */
    public long getLong(int index) throws JSONException {
        Object object = this.get(index);
        try {
            return object instanceof Number
                ? ((Number)object).longValue()
                : Long.parseLong((String)object);
        } catch (Exception e) {
            throw new JSONException("JSONArray[" + index +
                "] is not a number.");
        }
    }


    /**
     * Get the string associated with an index.
     * @param index The index must be between 0 and length() - 1.
     * @return      A string value.
     * @throws JSONException If there is no string value for the index.
     */
    public String getString(int index) throws JSONException {
        Object object = this.get(index);
        if (object instanceof String) {
            return (String)object;
        }
        throw new JSONException("JSONArray[" + index + "] not a string.");
    }


    /**
     * Determine if the value is null.
     * @param index The index must be between 0 and length() - 1.
     * @return true if the value at the index is null, or if there is no value.
     */
    public boolean isNull(int index) {
        return JSONObject.NULL.equals(this.opt(index));
    }


    /**
     * Make a string from the contents of this JSONArray. The
     * <code>separator</code> string is inserted between each element.
     * Warning: This method assumes that the data structure is acyclical.
     * @param separator A string that will be inserted between the elements.
     * @return a string.
     * @throws JSONException If the array contains an invalid number.
     */
    public String join(String separator) throws JSONException {
        int len = this.length();
        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < len; i += 1) {
            if (i > 0) {
                sb.append(separator);
            }
            sb.append(JSONObject.valueToString(this.myArrayList.get(i)));
        }
        return sb.toString();
    }


    /**
     * Get the number of elements in the JSONArray, included nulls.
     *
     * @return The length (or size).
     */
    public int length() {
        return this.myArrayList.size();
    }


    /**
     * Get the optional object value associated with an index.
     * @param index The index must be between 0 and length() - 1.
     * @return      An object value, or null if there is no
     *              object at that index.
     */
    public Object opt(int index) {
        return (index < 0 || index >= this.length())
            ? null
            : this.myArrayList.get(index);
    }


    /**
     * Get the optional boolean value associated with an index.
     * It returns false if there is no value at that index,
     * or if the value is not Boolean.TRUE or the String "true".
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The truth.
     */
    public boolean optBoolean(int index)  {
        return this.optBoolean(index, false);
    }


    /**
     * Get the optional boolean value associated with an index.
     * It returns the defaultValue if there is no value at that index or if
     * it is not a Boolean or the String "true" or "false" (case insensitive).
     *
     * @param index The index must be between 0 and length() - 1.
     * @param defaultValue     A boolean default.
     * @return      The truth.
     */
    public boolean optBoolean(int index, boolean defaultValue)  {
        try {
            return this.getBoolean(index);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get the optional double value associated with an index.
     * NaN is returned if there is no value for the index,
     * or if the value is not a number and cannot be converted to a number.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The value.
     */
    public double optDouble(int index) {
        return this.optDouble(index, Double.NaN);
    }


    /**
     * Get the optional double value associated with an index.
     * The defaultValue is returned if there is no value for the index,
     * or if the value is not a number and cannot be converted to a number.
     *
     * @param index subscript
     * @param defaultValue     The default value.
     * @return      The value.
     */
    public double optDouble(int index, double defaultValue) {
        try {
            return this.getDouble(index);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get the optional int value associated with an index.
     * Zero is returned if there is no value for the index,
     * or if the value is not a number and cannot be converted to a number.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The value.
     */
    public int optInt(int index) {
        return this.optInt(index, 0);
    }


    /**
     * Get the optional int value associated with an index.
     * The defaultValue is returned if there is no value for the index,
     * or if the value is not a number and cannot be converted to a number.
     * @param index The index must be between 0 and length() - 1.
     * @param defaultValue     The default value.
     * @return      The value.
     */
    public int optInt(int index, int defaultValue) {
        try {
            return this.getInt(index);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get the optional JSONArray associated with an index.
     * @param index subscript
     * @return      A JSONArray value, or null if the index has no value,
     * or if the value is not a JSONArray.
     */
    public JSONArray optJSONArray(int index) {
        Object o = this.opt(index);
        return o instanceof JSONArray ? (JSONArray)o : null;
    }


    /**
     * Get the optional JSONObject associated with an index.
     * Null is returned if the key is not found, or null if the index has
     * no value, or if the value is not a JSONObject.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      A JSONObject value.
     */
    public JSONObject optJSONObject(int index) {
        Object o = this.opt(index);
        return o instanceof JSONObject ? (JSONObject)o : null;
    }


    /**
     * Get the optional long value associated with an index.
     * Zero is returned if there is no value for the index,
     * or if the value is not a number and cannot be converted to a number.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      The value.
     */
    public long optLong(int index) {
        return this.optLong(index, 0);
    }


    /**
     * Get the optional long value associated with an index.
     * The defaultValue is returned if there is no value for the index,
     * or if the value is not a number and cannot be converted to a number.
     * @param index The index must be between 0 and length() - 1.
     * @param defaultValue     The default value.
     * @return      The value.
     */
    public long optLong(int index, long defaultValue) {
        try {
            return this.getLong(index);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get the optional string value associated with an index. It returns an
     * empty string if there is no value at that index. If the value
     * is not a string and is not null, then it is coverted to a string.
     *
     * @param index The index must be between 0 and length() - 1.
     * @return      A String value.
     */
    public String optString(int index) {
        return this.optString(index, "");
    }


    /**
     * Get the optional string associated with an index.
     * The defaultValue is returned if the key is not found.
     *
     * @param index The index must be between 0 and length() - 1.
     * @param defaultValue     The default value.
     * @return      A String value.
     */
    public String optString(int index, String defaultValue) {
        Object object = this.opt(index);
        return JSONObject.NULL.equals(object)
 ? defaultValue : object
                .toString();
    }


    /**
     * Append a boolean value. This increases the array's length by one.
     *
     * @param value A boolean value.
     * @return this.
     */
    public JSONArray put(boolean value) {
        this.put(value ? Boolean.TRUE : Boolean.FALSE);
        return this;
    }


    /**
     * Put a value in the JSONArray, where the value will be a
     * JSONArray which is produced from a Collection.
     * @param value A Collection value.
     * @return      this.
     */
    public JSONArray put(Collection<Object> value) {
        this.put(new JSONArray(value));
        return this;
    }


    /**
     * Append a double value. This increases the array's length by one.
     *
     * @param value A double value.
     * @throws JSONException if the value is not finite.
     * @return this.
     */
    public JSONArray put(double value) throws JSONException {
        Double d = Double.valueOf(value);
        JSONObject.testValidity(d);
        this.put(d);
        return this;
    }


    /**
     * Append an int value. This increases the array's length by one.
     *
     * @param value An int value.
     * @return this.
     */
    public JSONArray put(int value) {
        this.put(Integer.valueOf(value));
        return this;
    }


    /**
     * Append an long value. This increases the array's length by one.
     *
     * @param value A long value.
     * @return this.
     */
    public JSONArray put(long value) {
        this.put(Long.valueOf(value));
        return this;
    }


    /**
     * Put a value in the JSONArray, where the value will be a
     * JSONObject which is produced from a Map.
     * @param value A Map value.
     * @return      this.
     */
    public JSONArray put(Map<Object, Object> value) {
        this.put(new JSONObject(value));
        return this;
    }


    /**
     * Append an object value. This increases the array's length by one.
     * @param value An object value.  The value should be a
     *  Boolean, Double, Integer, JSONArray, JSONObject, Long, or String, or the
     *  JSONObject.NULL object.
     * @return this.
     */
    public JSONArray put(Object value) {
        this.myArrayList.add(value);
        return this;
    }


    /**
     * Put or replace a boolean value in the JSONArray. If the index is greater
     * than the length of the JSONArray, then null elements will be added as
     * necessary to pad it out.
     * @param index The subscript.
     * @param value A boolean value.
     * @return this.
     * @throws JSONException If the index is negative.
     */
    public JSONArray put(int index, boolean value) throws JSONException {
        this.put(index, value ? Boolean.TRUE : Boolean.FALSE);
        return this;
    }


    /**
     * Put a value in the JSONArray, where the value will be a
     * JSONArray which is produced from a Collection.
     * @param index The subscript.
     * @param value A Collection value.
     * @return      this.
     * @throws JSONException If the index is negative or if the value is
     * not finite.
     */
    public JSONArray put(int index, Collection<Object> value) throws JSONException {
        this.put(index, new JSONArray(value));
        return this;
    }


    /**
     * Put or replace a double value. If the index is greater than the length of
     *  the JSONArray, then null elements will be added as necessary to pad
     *  it out.
     * @param index The subscript.
     * @param value A double value.
     * @return this.
     * @throws JSONException If the index is negative or if the value is
     * not finite.
     */
    public JSONArray put(int index, double value) throws JSONException {
        this.put(index, Double.valueOf(value));
        return this;
    }


    /**
     * Put or replace an int value. If the index is greater than the length of
     *  the JSONArray, then null elements will be added as necessary to pad
     *  it out.
     * @param index The subscript.
     * @param value An int value.
     * @return this.
     * @throws JSONException If the index is negative.
     */
    public JSONArray put(int index, int value) throws JSONException {
        this.put(index, Integer.valueOf(value));
        return this;
    }


    /**
     * Put or replace a long value. If the index is greater than the length of
     *  the JSONArray, then null elements will be added as necessary to pad
     *  it out.
     * @param index The subscript.
     * @param value A long value.
     * @return this.
     * @throws JSONException If the index is negative.
     */
    public JSONArray put(int index, long value) throws JSONException {
        this.put(index, Long.valueOf(value));
        return this;
    }


    /**
     * Put a value in the JSONArray, where the value will be a
     * JSONObject that is produced from a Map.
     * @param index The subscript.
     * @param value The Map value.
     * @return      this.
     * @throws JSONException If the index is negative or if the the value is
     *  an invalid number.
     */
    public JSONArray put(int index, Map<Object, Object> value) throws JSONException {
        this.put(index, new JSONObject(value));
        return this;
    }


    /**
     * Put or replace an object value in the JSONArray. If the index is greater
     *  than the length of the JSONArray, then null elements will be added as
     *  necessary to pad it out.
     * @param index The subscript.
     * @param value The value to put into the array. The value should be a
     *  Boolean, Double, Integer, JSONArray, JSONObject, Long, or String, or the
     *  JSONObject.NULL object.
     * @return this.
     * @throws JSONException If the index is negative or if the the value is
     *  an invalid number.
     */
    public JSONArray put(int index, Object value) throws JSONException {
        JSONObject.testValidity(value);
        if (index < 0) {
            throw new JSONException("JSONArray[" + index + "] not found.");
        }
        if (index < this.length()) {
            this.myArrayList.set(index, value);
        } else {
            while (index != this.length()) {
                this.put(JSONObject.NULL);
            }
            this.put(value);
        }
        return this;
    }


    /**
     * Remove an index and close the hole.
     * @param index The index of the element to be removed.
     * @return The value that was associated with the index,
     * or null if there was no value.
     */
    public Object remove(int index) {
        Object o = this.opt(index);
        this.myArrayList.remove(index);
        return o;
    }


    /**
     * Get the object value associated with an index.
     * @param index
     *  The index must be between 0 and length() - 1.
     * @return An object value.
     * @throws JSONException If there is no value for the index.
     */
    public void merge(JSONArray jsonArray) throws JSONException {
       this.myArrayList.addAll(jsonArray.myArrayList);
    }

    

    /**
     * Produce a JSONObject by combining a JSONArray of names with the values
     * of this JSONArray.
     * @param names A JSONArray containing a list of key strings. These will be
     * paired with the values.
     * @return A JSONObject, or null if there are no names or if this JSONArray
     * has no values.
     * @throws JSONException If any of the names are null.
     */
    public JSONObject toJSONObject(JSONArray names) throws JSONException {
        if (names == null || names.length() == 0 || this.length() == 0) {
            return null;
        }
        JSONObject jo = new JSONObject();
        for (int i = 0; i < names.length(); i += 1) {
            jo.put(names.getString(i), this.opt(i));
        }
        return jo;
    }


    /**
     * Make a JSON text of this JSONArray. For compactness, no
     * unnecessary whitespace is added. If it is not possible to produce a
     * syntactically correct JSON text then null will be returned instead. This
     * could occur if the array contains an invalid number.
     * <p>
     * Warning: This method assumes that the data structure is acyclical.
     *
     * @return a printable, displayable, transmittable
     *  representation of the array.
     */
    public String toString() {
        try {
            return '[' + this.join(",") + ']';
        } catch (Exception e) {
            return null;
        }
    }


    /**
     * Make a prettyprinted JSON text of this JSONArray.
     * Warning: This method assumes that the data structure is acyclical.
     * @param indentFactor The number of spaces to add to each level of
     *  indentation.
     * @return a printable, displayable, transmittable
     *  representation of the object, beginning
     *  with <code>[</code>&nbsp;<small>(left bracket)</small> and ending
     *  with <code>]</code>&nbsp;<small>(right bracket)</small>.
     * @throws JSONException
     */
    public String toString(int indentFactor) throws JSONException {
        StringWriter sw = new StringWriter();
        synchronized (sw.getBuffer()) {
            return this.write(sw, indentFactor, 0).toString();
        }
    }

    /**
     * Write the contents of the JSONArray as JSON text to a writer. For
     * compactness, no whitespace is added.
     * <p>
     * Warning: This method assumes that the data structure is acyclical.
     *
     * @return The writer.
     * @throws JSONException
     */
    public Writer write(Writer writer) throws JSONException {
        return this.write(writer, 0, 0);
    }
    
    public List<Object> getList(){
    	return this.myArrayList;
    }

    /**
     * Write the contents of the JSONArray as JSON text to a writer. For
     * compactness, no whitespace is added.
     * <p>
     * Warning: This method assumes that the data structure is acyclical.
     *
     * @param indentFactor
     *            The number of spaces to add to each level of indentation.
     * @param indent
     *            The indention of the top level.
     * @return The writer.
     * @throws JSONException
     */
    Writer write(Writer writer, int indentFactor, int indent)
            throws JSONException {
        try {
            boolean commanate = false;
            int length = this.length();
            writer.write('[');

            if (length == 1) {
                JSONObject.writeValue(writer, this.myArrayList.get(0),
                        indentFactor, indent);
            } else if (length != 0) {
                final int newindent = indent + indentFactor;

                for (int i = 0; i < length; i += 1) {
                    if (commanate) {
                        writer.write(',');
                    }
                    if (indentFactor > 0) {
                        writer.write('\n');
                    }
                    JSONObject.indent(writer, newindent);
                    JSONObject.writeValue(writer, this.myArrayList.get(i),
                            indentFactor, newindent);
                    commanate = true;
                }
                if (indentFactor > 0) {
                    writer.write('\n');
                }
                JSONObject.indent(writer, indent);
            }
            writer.write(']');
            return writer;
        } catch (IOException e) {
           throw new JSONException(e);
        }
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONException.java
================================================
package com.ejie.x38.json;

/**
 * The JSONException is thrown by the JSON.org classes when things are amiss.
 * @author JSON.org
 * @version 2010-12-24
 */
public class JSONException extends RuntimeException {
    private static final long serialVersionUID = 0;
    private Throwable cause;

    /**
     * Constructs a JSONException with an explanatory message.
     * @param message Detail about the reason for the exception.
     */
    public JSONException(String message) {
        super(message);
    }

    public JSONException(Throwable cause) {
        super(cause.getMessage());
        this.cause = cause;
    }

    public Throwable getCause() {
        return this.cause;
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONML.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2008 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import java.util.Iterator;


/**
 * This provides static methods to convert an XML text into a JSONArray or
 * JSONObject, and to covert a JSONArray or JSONObject into an XML text using
 * the JsonML transform.
 * @author JSON.org
 * @version 2011-11-24
 */
public class JSONML {

    /**
     * Parse XML values and store them in a JSONArray.
     * @param x       The XMLTokener containing the source string.
     * @param arrayForm true if array form, false if object form.
     * @param ja      The JSONArray that is containing the current tag or null
     *     if we are at the outermost level.
     * @return A JSONArray if the value is the outermost tag, otherwise null.
     * @throws JSONException
     */
    private static Object parse(
        XMLTokener x,
        boolean    arrayForm,
        JSONArray  ja
    ) throws JSONException {
        String     attribute;
        char       c;
        String       closeTag = null;
        int        i;
        JSONArray  newja = null;
        JSONObject newjo = null;
        Object     token;
        String       tagName = null;

// Test for and skip past these forms:
//      <!-- ... -->
//      <![  ... ]]>
//      <!   ...   >
//      <?   ...  ?>

        while (true) {
            if (!x.more()) {
                throw x.syntaxError("Bad XML");
            }
            token = x.nextContent();
            if (token == XML.LT) {
                token = x.nextToken();
                if (token instanceof Character) {
                    if (token == XML.SLASH) {

// Close tag </

                        token = x.nextToken();
                        if (!(token instanceof String)) {
                            throw new JSONException(
                                    "Expected a closing name instead of '" +
                                    token + "'.");
                        }
                        if (x.nextToken() != XML.GT) {
                            throw x.syntaxError("Misshaped close tag");
                        }
                        return token;
                    } else if (token == XML.BANG) {

// <!

                        c = x.next();
                        if (c == '-') {
                            if (x.next() == '-') {
                                x.skipPast("-->");
                            }
                            x.back();
                        } else if (c == '[') {
                            token = x.nextToken();
                            if (token.equals("CDATA") && x.next() == '[') {
                                if (ja != null) {
                                    ja.put(x.nextCDATA());
                                }
                            } else {
                                throw x.syntaxError("Expected 'CDATA['");
                            }
                        } else {
                            i = 1;
                            do {
                                token = x.nextMeta();
                                if (token == null) {
                                    throw x.syntaxError("Missing '>' after '<!'.");
                                } else if (token == XML.LT) {
                                    i += 1;
                                } else if (token == XML.GT) {
                                    i -= 1;
                                }
                            } while (i > 0);
                        }
                    } else if (token == XML.QUEST) {

// <?

                        x.skipPast("?>");
                    } else {
                        throw x.syntaxError("Misshaped tag");
                    }

// Open tag <

                } else {
                    if (!(token instanceof String)) {
                        throw x.syntaxError("Bad tagName '" + token + "'.");
                    }
                    tagName = (String)token;
                    newja = new JSONArray();
                    newjo = new JSONObject();
                    if (arrayForm) {
                        newja.put(tagName);
                        if (ja != null) {
                            ja.put(newja);
                        }
                    } else {
                        newjo.put("tagName", tagName);
                        if (ja != null) {
                            ja.put(newjo);
                        }
                    }
                    token = null;
                    for (;;) {
                        if (token == null) {
                            token = x.nextToken();
                        }
                        if (token == null) {
                            throw x.syntaxError("Misshaped tag");
                        }
                        if (!(token instanceof String)) {
                            break;
                        }

// attribute = value

                        attribute = (String)token;
                        if (!arrayForm && ("tagName".equals(attribute) || "childNode".equals(attribute))) {
                            throw x.syntaxError("Reserved attribute.");
                        }
                        token = x.nextToken();
                        if (token == XML.EQ) {
                            token = x.nextToken();
                            if (!(token instanceof String)) {
                                throw x.syntaxError("Missing value");
                            }
                            newjo.accumulate(attribute, XML.stringToValue((String)token));
                            token = null;
                        } else {
                            newjo.accumulate(attribute, "");
                        }
                    }
                    if (arrayForm && newjo.length() > 0) {
                        newja.put(newjo);
                    }

// Empty tag <.../>

                    if (token == XML.SLASH) {
                        if (x.nextToken() != XML.GT) {
                            throw x.syntaxError("Misshaped tag");
                        }
                        if (ja == null) {
                            if (arrayForm) {
                                return newja;
                            } else {
                                return newjo;
                            }
                        }

// Content, between <...> and </...>

                    } else {
                        if (token != XML.GT) {
                            throw x.syntaxError("Misshaped tag");
                        }
                        closeTag = (String)parse(x, arrayForm, newja);
                        if (closeTag != null) {
                            if (!closeTag.equals(tagName)) {
                                throw x.syntaxError("Mismatched '" + tagName +
                                        "' and '" + closeTag + "'");
                            }
                            tagName = null;
                            if (!arrayForm && newja.length() > 0) {
                                newjo.put("childNodes", newja);
                            }
                            if (ja == null) {
                                if (arrayForm) {
                                    return newja;
                                } else {
                                    return newjo;
                                }
                            }
                        }
                    }
                }
            } else {
                if (ja != null) {
                    ja.put(token instanceof String
                        ? XML.stringToValue((String)token)
                        : token);
                }
            }
        }
    }


    /**
     * Convert a well-formed (but not necessarily valid) XML string into a
     * JSONArray using the JsonML transform. Each XML tag is represented as
     * a JSONArray in which the first element is the tag name. If the tag has
     * attributes, then the second element will be JSONObject containing the
     * name/value pairs. If the tag contains children, then strings and
     * JSONArrays will represent the child tags.
     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
     * @param string The source string.
     * @return A JSONArray containing the structured data from the XML string.
     * @throws JSONException
     */
    public static JSONArray toJSONArray(String string) throws JSONException {
        return toJSONArray(new XMLTokener(string));
    }


    /**
     * Convert a well-formed (but not necessarily valid) XML string into a
     * JSONArray using the JsonML transform. Each XML tag is represented as
     * a JSONArray in which the first element is the tag name. If the tag has
     * attributes, then the second element will be JSONObject containing the
     * name/value pairs. If the tag contains children, then strings and
     * JSONArrays will represent the child content and tags.
     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
     * @param x An XMLTokener.
     * @return A JSONArray containing the structured data from the XML string.
     * @throws JSONException
     */
    public static JSONArray toJSONArray(XMLTokener x) throws JSONException {
        return (JSONArray)parse(x, true, null);
    }


    /**
     * Convert a well-formed (but not necessarily valid) XML string into a
     * JSONObject using the JsonML transform. Each XML tag is represented as
     * a JSONObject with a "tagName" property. If the tag has attributes, then
     * the attributes will be in the JSONObject as properties. If the tag
     * contains children, the object will have a "childNodes" property which
     * will be an array of strings and JsonML JSONObjects.

     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
     * @param x An XMLTokener of the XML source text.
     * @return A JSONObject containing the structured data from the XML string.
     * @throws JSONException
     */
    public static JSONObject toJSONObject(XMLTokener x) throws JSONException {
           return (JSONObject)parse(x, false, null);
    }


    /**
     * Convert a well-formed (but not necessarily valid) XML string into a
     * JSONObject using the JsonML transform. Each XML tag is represented as
     * a JSONObject with a "tagName" property. If the tag has attributes, then
     * the attributes will be in the JSONObject as properties. If the tag
     * contains children, the object will have a "childNodes" property which
     * will be an array of strings and JsonML JSONObjects.

     * Comments, prologs, DTDs, and <code>&lt;[ [ ]]></code> are ignored.
     * @param string The XML source text.
     * @return A JSONObject containing the structured data from the XML string.
     * @throws JSONException
     */
    public static JSONObject toJSONObject(String string) throws JSONException {
        return toJSONObject(new XMLTokener(string));
    }


    /**
     * Reverse the JSONML transformation, making an XML text from a JSONArray.
     * @param ja A JSONArray.
     * @return An XML string.
     * @throws JSONException
     */
    @SuppressWarnings("rawtypes")
	public static String toString(JSONArray ja) throws JSONException {
        int             i;
        JSONObject   jo;
        String       key;
        Iterator     keys;
        int             length;
        Object         object;
        StringBuffer sb = new StringBuffer();
        String       tagName;
        String       value;

// Emit <tagName

        tagName = ja.getString(0);
        XML.noSpace(tagName);
        tagName = XML.escape(tagName);
        sb.append('<');
        sb.append(tagName);

        object = ja.opt(1);
        if (object instanceof JSONObject) {
            i = 2;
            jo = (JSONObject)object;

// Emit the attributes

            keys = jo.keys();
            while (keys.hasNext()) {
                key = keys.next().toString();
                XML.noSpace(key);
                value = jo.optString(key);
                if (value != null) {
                    sb.append(' ');
                    sb.append(XML.escape(key));
                    sb.append('=');
                    sb.append('"');
                    sb.append(XML.escape(value));
                    sb.append('"');
                }
            }
        } else {
            i = 1;
        }

//Emit content in body

        length = ja.length();
        if (i >= length) {
            sb.append('/');
            sb.append('>');
        } else {
            sb.append('>');
            do {
                object = ja.get(i);
                i += 1;
                if (object != null) {
                    if (object instanceof String) {
                        sb.append(XML.escape(object.toString()));
                    } else if (object instanceof JSONObject) {
                        sb.append(toString((JSONObject)object));
                    } else if (object instanceof JSONArray) {
                        sb.append(toString((JSONArray)object));
                    }
                }
            } while (i < length);
            sb.append('<');
            sb.append('/');
            sb.append(tagName);
            sb.append('>');
        }
        return sb.toString();
    }

    /**
     * Reverse the JSONML transformation, making an XML text from a JSONObject.
     * The JSONObject must contain a "tagName" property. If it has children,
     * then it must have a "childNodes" property containing an array of objects.
     * The other properties are attributes with string values.
     * @param jo A JSONObject.
     * @return An XML string.
     * @throws JSONException
     */
    @SuppressWarnings("rawtypes")
	public static String toString(JSONObject jo) throws JSONException {
        StringBuffer sb = new StringBuffer();
        int          i;
        JSONArray    ja;
        String       key;
        Iterator     keys;
        int          length;
        Object         object;
        String       tagName;
        String       value;

//Emit <tagName

        tagName = jo.optString("tagName");
        if (tagName == null) {
            return XML.escape(jo.toString());
        }
        XML.noSpace(tagName);
        tagName = XML.escape(tagName);
        sb.append('<');
        sb.append(tagName);

//Emit the attributes

        keys = jo.keys();
        while (keys.hasNext()) {
            key = keys.next().toString();
            if (!"tagName".equals(key) && !"childNodes".equals(key)) {
                XML.noSpace(key);
                value = jo.optString(key);
                if (value != null) {
                    sb.append(' ');
                    sb.append(XML.escape(key));
                    sb.append('=');
                    sb.append('"');
                    sb.append(XML.escape(value));
                    sb.append('"');
                }
            }
        }

//Emit content in body

        ja = jo.optJSONArray("childNodes");
        if (ja == null) {
            sb.append('/');
            sb.append('>');
        } else {
            sb.append('>');
            length = ja.length();
            for (i = 0; i < length; i += 1) {
                object = ja.get(i);
                if (object != null) {
                    if (object instanceof String) {
                        sb.append(XML.escape(object.toString()));
                    } else if (object instanceof JSONObject) {
                        sb.append(toString((JSONObject)object));
                    } else if (object instanceof JSONArray) {
                        sb.append(toString((JSONArray)object));
                    } else {
                        sb.append(object.toString());
                    }
                }
            }
            sb.append('<');
            sb.append('/');
            sb.append(tagName);
            sb.append('>');
        }
        return sb.toString();
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONObject.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import java.io.IOException;
import java.io.StringWriter;
import java.io.Writer;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Collection;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.Map;
import java.util.ResourceBundle;

/**
 * A JSONObject is an unordered collection of name/value pairs. Its external
 * form is a string wrapped in curly braces with colons between the names and
 * values, and commas between the values and names. The internal form is an
 * object having <code>get</code> and <code>opt</code> methods for accessing the
 * values by name, and <code>put</code> methods for adding or replacing values
 * by name. The values can be any of these types: <code>Boolean</code>,
 * <code>JSONArray</code>, <code>JSONObject</code>, <code>Number</code>,
 * <code>String</code>, or the <code>JSONObject.NULL</code> object. A JSONObject
 * constructor can be used to convert an external form JSON text into an
 * internal form whose values can be retrieved with the <code>get</code> and
 * <code>opt</code> methods, or to convert values into a JSON text using the
 * <code>put</code> and <code>toString</code> methods. A <code>get</code> method
 * returns a value if one can be found, and throws an exception if one cannot be
 * found. An <code>opt</code> method returns a default value instead of throwing
 * an exception, and so is useful for obtaining optional values.
 * <p>
 * The generic <code>get()</code> and <code>opt()</code> methods return an
 * object, which you can cast or query for type. There are also typed
 * <code>get</code> and <code>opt</code> methods that do type checking and type
 * coercion for you. The opt methods differ from the get methods in that they do
 * not throw. Instead, they return a specified value, such as null.
 * <p>
 * The <code>put</code> methods add or replace values in an object. For example,
 *
 * <pre>
 * myString = new JSONObject().put(&quot;JSON&quot;, &quot;Hello, World!&quot;).toString();
 * </pre>
 *
 * produces the string <code>{"JSON": "Hello, World"}</code>.
 * <p>
 * The texts produced by the <code>toString</code> methods strictly conform to
 * the JSON syntax rules. The constructors are more forgiving in the texts they
 * will accept:
 * <ul>
 * <li>An extra <code>,</code>&nbsp;<small>(comma)</small> may appear just
 * before the closing brace.</li>
 * <li>Strings may be quoted with <code>'</code>&nbsp;<small>(single
 * quote)</small>.</li>
 * <li>Strings do not need to be quoted at all if they do not begin with a quote
 * or single quote, and if they do not contain leading or trailing spaces, and
 * if they do not contain any of these characters:
 * <code>{ } [ ] / \ : , = ; #</code> and if they do not look like numbers and
 * if they are not the reserved words <code>true</code>, <code>false</code>, or
 * <code>null</code>.</li>
 * <li>Keys can be followed by <code>=</code> or <code>=></code> as well as by
 * <code>:</code>.</li>
 * <li>Values can be followed by <code>;</code> <small>(semicolon)</small> as
 * well as by <code>,</code> <small>(comma)</small>.</li>
 * </ul>
 *
 * @author JSON.org
 * @version 2012-04-20
 */
public class JSONObject {

    /**
     * JSONObject.NULL is equivalent to the value that JavaScript calls null,
     * whilst Java's null is equivalent to the value that JavaScript calls
     * undefined.
     */
     private static final class Null {

        /**
         * There is only intended to be a single instance of the NULL object,
         * so the clone method returns itself.
         * @return     NULL.
         */
        protected final Object clone() {
            return this;
        }

        /**
         * A Null object is equal to the null value and to itself.
         * @param object    An object to test for nullness.
         * @return true if the object parameter is the JSONObject.NULL object
         *  or null.
         */
        public boolean equals(Object object) {
            return object == null || object == this;
        }

        /**
         * Get the "null" string value.
         * @return The string "null".
         */
        public String toString() {
            return "null";
        }
    }


    /**
     * The map where the JSONObject's properties are kept.
     */
    private final Map<Object, Object> map;


    /**
     * It is sometimes more convenient and less ambiguous to have a
     * <code>NULL</code> object than to use Java's <code>null</code> value.
     * <code>JSONObject.NULL.equals(null)</code> returns <code>true</code>.
     * <code>JSONObject.NULL.toString()</code> returns <code>"null"</code>.
     */
    public static final Object NULL = new Null();


    /**
     * Construct an empty JSONObject.
     */
    public JSONObject() {
        this.map = new HashMap<Object, Object>();
    }


    /**
     * Construct a JSONObject from a subset of another JSONObject.
     * An array of strings is used to identify the keys that should be copied.
     * Missing keys are ignored.
     * @param jo A JSONObject.
     * @param names An array of strings.
     * @throws JSONException
     * @exception JSONException If a value is a non-finite number or if a name is duplicated.
     */
    public JSONObject(JSONObject jo, String[] names) {
        this();
        for (int i = 0; i < names.length; i += 1) {
            try {
                this.putOnce(names[i], jo.opt(names[i]));
            } catch (Exception ignore) {
            }
        }
    }


    /**
     * Construct a JSONObject from a JSONTokener.
     * @param x A JSONTokener object containing the source string.
     * @throws JSONException If there is a syntax error in the source string
     *  or a duplicated key.
     */
    public JSONObject(JSONTokener x) throws JSONException {
        this();
        char c;
        String key;

        if (x.nextClean() != '{') {
            throw x.syntaxError("A JSONObject text must begin with '{'");
        }
        for (;;) {
            c = x.nextClean();
            switch (c) {
            case 0:
                throw x.syntaxError("A JSONObject text must end with '}'");
            case '}':
                return;
            default:
                x.back();
                key = x.nextValue().toString();
            }

// The key is followed by ':'. We will also tolerate '=' or '=>'.

            c = x.nextClean();
            if (c == '=') {
                if (x.next() != '>') {
                    x.back();
                }
            } else if (c != ':') {
                throw x.syntaxError("Expected a ':' after a key");
            }
            this.putOnce(key, x.nextValue());

// Pairs are separated by ','. We will also tolerate ';'.

            switch (x.nextClean()) {
            case ';':
            case ',':
                if (x.nextClean() == '}') {
                    return;
                }
                x.back();
                break;
            case '}':
                return;
            default:
                throw x.syntaxError("Expected a ',' or '}'");
            }
        }
    }


    /**
     * Construct a JSONObject from a Map.
     *
     * @param map A map object that can be used to initialize the contents of
     *  the JSONObject.
     * @throws JSONException
     */
	@SuppressWarnings("unchecked")
	public JSONObject(Map<? extends Object, ? extends Object> map) {
        this.map = new HashMap<Object, Object>();
        if (map != null) {
            Iterator<?> i = map.entrySet().iterator();
            while (i.hasNext()) {
                Map.Entry<Object, Object> e = (Map.Entry<Object, Object>)i.next();
                Object value = e.getValue();
                if (value != null) {
                    this.map.put(e.getKey(), wrap(value));
                }
            }
        }
    }


    /**
     * Construct a JSONObject from an Object using bean getters.
     * It reflects on all of the public methods of the object.
     * For each of the methods with no parameters and a name starting
     * with <code>"get"</code> or <code>"is"</code> followed by an uppercase letter,
     * the method is invoked, and a key and the value returned from the getter method
     * are put into the new JSONObject.
     *
     * The key is formed by removing the <code>"get"</code> or <code>"is"</code> prefix.
     * If the second remaining character is not upper case, then the first
     * character is converted to lower case.
     *
     * For example, if an object has a method named <code>"getName"</code>, and
     * if the result of calling <code>object.getName()</code> is <code>"Larry Fine"</code>,
     * then the JSONObject will contain <code>"name": "Larry Fine"</code>.
     *
     * @param bean An object that has getter methods that should be used
     * to make a JSONObject.
     */
    public JSONObject(Object bean) {
        this();
        this.populateMap(bean);
    }


    /**
     * Construct a JSONObject from an Object, using reflection to find the
     * public members. The resulting JSONObject's keys will be the strings
     * from the names array, and the values will be the field values associated
     * with those keys in the object. If a key is not found or not visible,
     * then it will not be copied into the new JSONObject.
     * @param object An object that has fields that should be used to make a
     * JSONObject.
     * @param names An array of strings, the names of the fields to be obtained
     * from the object.
     */
    public JSONObject(Object object, String names[]) {
        this();
        Class<? extends Object> c = object.getClass();
        for (int i = 0; i < names.length; i += 1) {
            String name = names[i];
            try {
                this.putOpt(name, c.getField(name).get(object));
            } catch (Exception ignore) {
            }
        }
    }


    /**
     * Construct a JSONObject from a source JSON text string.
     * This is the most commonly used JSONObject constructor.
     * @param source    A string beginning
     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
     * @exception JSONException If there is a syntax error in the source
     *  string or a duplicated key.
     */
    public JSONObject(String source) throws JSONException {
        this(new JSONTokener(source));
    }


    /**
     * Construct a JSONObject from a ResourceBundle.
     * @param baseName The ResourceBundle base name.
     * @param locale The Locale to load the ResourceBundle for.
     * @throws JSONException If any JSONExceptions are detected.
     */
    public JSONObject(String baseName, Locale locale) throws JSONException {
        this();
        ResourceBundle bundle = ResourceBundle.getBundle(baseName, locale,
                Thread.currentThread().getContextClassLoader());

// Iterate through the keys in the bundle.

        Enumeration<?> keys = bundle.getKeys();
        while (keys.hasMoreElements()) {
            Object key = keys.nextElement();
            if (key instanceof String) {

// Go through the path, ensuring that there is a nested JSONObject for each
// segment except the last. Add the value using the last segment's name into
// the deepest nested JSONObject.

                String[] path = ((String)key).split("\\.");
                int last = path.length - 1;
                JSONObject target = this;
                for (int i = 0; i < last; i += 1) {
                    String segment = path[i];
                    JSONObject nextTarget = target.optJSONObject(segment);
                    if (nextTarget == null) {
                        nextTarget = new JSONObject();
                        target.put(segment, nextTarget);
                    }
                    target = nextTarget;
                }
                target.put(path[last], bundle.getString((String)key));
            }
        }
    }


    /**
     * Accumulate values under a key. It is similar to the put method except
     * that if there is already an object stored under the key then a
     * JSONArray is stored under the key to hold all of the accumulated values.
     * If there is already a JSONArray, then the new value is appended to it.
     * In contrast, the put method replaces the previous value.
     *
     * If only one value is accumulated that is not a JSONArray, then the
     * result will be the same as using put. But if multiple values are
     * accumulated, then the result will be like append.
     * @param key   A key string.
     * @param value An object to be accumulated under the key.
     * @return this.
     * @throws JSONException If the value is an invalid number
     *  or if the key is null.
     */
    public JSONObject accumulate(
        String key,
        Object value
    ) throws JSONException {
        testValidity(value);
        Object object = this.opt(key);
        if (object == null) {
            this.put(key, value instanceof JSONArray
                    ? new JSONArray().put(value)
                    : value);
        } else if (object instanceof JSONArray) {
            ((JSONArray)object).put(value);
        } else {
            this.put(key, new JSONArray().put(object).put(value));
        }
        return this;
    }


    /**
     * Append values to the array under a key. If the key does not exist in the
     * JSONObject, then the key is put in the JSONObject with its value being a
     * JSONArray containing the value parameter. If the key was already
     * associated with a JSONArray, then the value parameter is appended to it.
     * @param key   A key string.
     * @param value An object to be accumulated under the key.
     * @return this.
     * @throws JSONException If the key is null or if the current value
     *  associated with the key is not a JSONArray.
     */
    public JSONObject append(String key, Object value) throws JSONException {
        testValidity(value);
        Object object = this.opt(key);
        if (object == null) {
            this.put(key, new JSONArray().put(value));
        } else if (object instanceof JSONArray) {
            this.put(key, ((JSONArray)object).put(value));
        } else {
            throw new JSONException("JSONObject[" + key +
                    "] is not a JSONArray.");
        }
        return this;
    }


    /**
     * Produce a string from a double. The string "null" will be returned if
     * the number is not finite.
     * @param  d A double.
     * @return A String.
     */
    public static String doubleToString(double d) {
        if (Double.isInfinite(d) || Double.isNaN(d)) {
            return "null";
        }

// Shave off trailing zeros and decimal point, if possible.

        String string = Double.toString(d);
        if (string.indexOf('.') > 0 && string.indexOf('e') < 0 &&
                string.indexOf('E') < 0) {
            while (string.endsWith("0")) {
                string = string.substring(0, string.length() - 1);
            }
            if (string.endsWith(".")) {
                string = string.substring(0, string.length() - 1);
            }
        }
        return string;
    }


    /**
     * Get the value object associated with a key.
     *
     * @param key   A key string.
     * @return      The object associated with the key.
     * @throws      JSONException if the key is not found.
     */
    public Object get(String key) throws JSONException {
        if (key == null) {
            throw new JSONException("Null key.");
        }
        Object object = this.opt(key);
        if (object == null) {
            throw new JSONException("JSONObject[" + quote(key) +
                    "] not found.");
        }
        return object;
    }


    /**
     * Get the boolean value associated with a key.
     *
     * @param key   A key string.
     * @return      The truth.
     * @throws      JSONException
     *  if the value is not a Boolean or the String "true" or "false".
     */
    public boolean getBoolean(String key) throws JSONException {
        Object object = this.get(key);
        if (object.equals(Boolean.FALSE) ||
                (object instanceof String &&
                ((String)object).equalsIgnoreCase("false"))) {
            return false;
        } else if (object.equals(Boolean.TRUE) ||
                (object instanceof String &&
                ((String)object).equalsIgnoreCase("true"))) {
            return true;
        }
        throw new JSONException("JSONObject[" + quote(key) +
                "] is not a Boolean.");
    }


    /**
     * Get the double value associated with a key.
     * @param key   A key string.
     * @return      The numeric value.
     * @throws JSONException if the key is not found or
     *  if the value is not a Number object and cannot be converted to a number.
     */
    public double getDouble(String key) throws JSONException {
        Object object = this.get(key);
        try {
            return object instanceof Number
                ? ((Number)object).doubleValue()
                : Double.parseDouble((String)object);
        } catch (Exception e) {
            throw new JSONException("JSONObject[" + quote(key) +
                "] is not a number.");
        }
    }


    /**
     * Get the int value associated with a key.
     *
     * @param key   A key string.
     * @return      The integer value.
     * @throws   JSONException if the key is not found or if the value cannot
     *  be converted to an integer.
     */
    public int getInt(String key) throws JSONException {
        Object object = this.get(key);
        try {
            return object instanceof Number
                ? ((Number)object).intValue()
                : Integer.parseInt((String)object);
        } catch (Exception e) {
            throw new JSONException("JSONObject[" + quote(key) +
                "] is not an int.");
        }
    }


    /**
     * Get the JSONArray value associated with a key.
     *
     * @param key   A key string.
     * @return      A JSONArray which is the value.
     * @throws      JSONException if the key is not found or
     *  if the value is not a JSONArray.
     */
    public JSONArray getJSONArray(String key) throws JSONException {
        Object object = this.get(key);
        if (object instanceof JSONArray) {
            return (JSONArray)object;
        }
        throw new JSONException("JSONObject[" + quote(key) +
                "] is not a JSONArray.");
    }


    /**
     * Get the JSONObject value associated with a key.
     *
     * @param key   A key string.
     * @return      A JSONObject which is the value.
     * @throws      JSONException if the key is not found or
     *  if the value is not a JSONObject.
     */
    public JSONObject getJSONObject(String key) throws JSONException {
        Object object = this.get(key);
        if (object instanceof JSONObject) {
            return (JSONObject)object;
        }
        throw new JSONException("JSONObject[" + quote(key) +
                "] is not a JSONObject.");
    }


    /**
     * Get the long value associated with a key.
     *
     * @param key   A key string.
     * @return      The long value.
     * @throws   JSONException if the key is not found or if the value cannot
     *  be converted to a long.
     */
    public long getLong(String key) throws JSONException {
        Object object = this.get(key);
        try {
            return object instanceof Number
                ? ((Number)object).longValue()
                : Long.parseLong((String)object);
        } catch (Exception e) {
            throw new JSONException("JSONObject[" + quote(key) +
                "] is not a long.");
        }
    }


    /**
     * Get an array of field names from a JSONObject.
     *
     * @return An array of field names, or null if there are no names.
     */
    public static String[] getNames(JSONObject jo) {
        int length = jo.length();
        if (length == 0) {
            return null;
        }
        Iterator<Object> iterator = jo.keys();
        String[] names = new String[length];
        int i = 0;
        while (iterator.hasNext()) {
            names[i] = (String)iterator.next();
            i += 1;
        }
        return names;
    }


    /**
     * Get an array of field names from an Object.
     *
     * @return An array of field names, or null if there are no names.
     */
    public static String[] getNames(Object object) {
        if (object == null) {
            return null;
        }
        Class<? extends Object> klass = object.getClass();
        Field[] fields = klass.getFields();
        int length = fields.length;
        if (length == 0) {
            return null;
        }
        String[] names = new String[length];
        for (int i = 0; i < length; i += 1) {
            names[i] = fields[i].getName();
        }
        return names;
    }


    /**
     * Get the string associated with a key.
     *
     * @param key   A key string.
     * @return      A string which is the value.
     * @throws   JSONException if there is no string value for the key.
     */
    public String getString(String key) throws JSONException {
        Object object = this.get(key);
        if (object instanceof String) {
            return (String)object;
        }
        throw new JSONException("JSONObject[" + quote(key) +
            "] not a string.");
    }


    /**
     * Determine if the JSONObject contains a specific key.
     * @param key   A key string.
     * @return      true if the key exists in the JSONObject.
     */
    public boolean has(String key) {
        return this.map.containsKey(key);
    }


    /**
     * Increment a property of a JSONObject. If there is no such property,
     * create one with a value of 1. If there is such a property, and if
     * it is an Integer, Long, Double, or Float, then add one to it.
     * @param key  A key string.
     * @return this.
     * @throws JSONException If there is already a property with this name
     * that is not an Integer, Long, Double, or Float.
     */
    public JSONObject increment(String key) throws JSONException {
        Object value = this.opt(key);
        if (value == null) {
            this.put(key, 1);
        } else if (value instanceof Integer) {
            this.put(key, ((Integer)value).intValue() + 1);
        } else if (value instanceof Long) {
            this.put(key, ((Long)value).longValue() + 1);
        } else if (value instanceof Double) {
            this.put(key, ((Double)value).doubleValue() + 1);
        } else if (value instanceof Float) {
            this.put(key, ((Float)value).floatValue() + 1);
        } else {
            throw new JSONException("Unable to increment [" + quote(key) + "].");
        }
        return this;
    }


    /**
     * Determine if the value associated with the key is null or if there is
     *  no value.
     * @param key   A key string.
     * @return      true if there is no value associated with the key or if
     *  the value is the JSONObject.NULL object.
     */
    public boolean isNull(String key) {
        return JSONObject.NULL.equals(this.opt(key));
    }


    /**
     * Get an enumeration of the keys of the JSONObject.
     *
     * @return An iterator of the keys.
     */
    public Iterator<Object> keys() {
        return this.map.keySet().iterator();
    }


    /**
     * Get the number of keys stored in the JSONObject.
     *
     * @return The number of keys in the JSONObject.
     */
    public int length() {
        return this.map.size();
    }


    /**
     * Produce a JSONArray containing the names of the elements of this
     * JSONObject.
     * @return A JSONArray containing the key strings, or null if the JSONObject
     * is empty.
     */
    public JSONArray names() {
        JSONArray ja = new JSONArray();
        Iterator<?>  keys = this.keys();
        while (keys.hasNext()) {
            ja.put(keys.next());
        }
        return ja.length() == 0 ? null : ja;
    }

    /**
     * Produce a string from a Number.
     * @param  number A Number
     * @return A String.
     * @throws JSONException If n is a non-finite number.
     */
    public static String numberToString(Number number)
            throws JSONException {
        if (number == null) {
            throw new JSONException("Null pointer");
        }
        testValidity(number);

// Shave off trailing zeros and decimal point, if possible.

        String string = number.toString();
        if (string.indexOf('.') > 0 && string.indexOf('e') < 0 &&
                string.indexOf('E') < 0) {
            while (string.endsWith("0")) {
                string = string.substring(0, string.length() - 1);
            }
            if (string.endsWith(".")) {
                string = string.substring(0, string.length() - 1);
            }
        }
        return string;
    }


    /**
     * Get an optional value associated with a key.
     * @param key   A key string.
     * @return      An object which is the value, or null if there is no value.
     */
    public Object opt(String key) {
        return key == null ? null : this.map.get(key);
    }


    /**
     * Get an optional boolean associated with a key.
     * It returns false if there is no such key, or if the value is not
     * Boolean.TRUE or the String "true".
     *
     * @param key   A key string.
     * @return      The truth.
     */
    public boolean optBoolean(String key) {
        return this.optBoolean(key, false);
    }


    /**
     * Get an optional boolean associated with a key.
     * It returns the defaultValue if there is no such key, or if it is not
     * a Boolean or the String "true" or "false" (case insensitive).
     *
     * @param key              A key string.
     * @param defaultValue     The default.
     * @return      The truth.
     */
    public boolean optBoolean(String key, boolean defaultValue) {
        try {
            return this.getBoolean(key);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get an optional double associated with a key,
     * or NaN if there is no such key or if its value is not a number.
     * If the value is a string, an attempt will be made to evaluate it as
     * a number.
     *
     * @param key   A string which is the key.
     * @return      An object which is the value.
     */
    public double optDouble(String key) {
        return this.optDouble(key, Double.NaN);
    }


    /**
     * Get an optional double associated with a key, or the
     * defaultValue if there is no such key or if its value is not a number.
     * If the value is a string, an attempt will be made to evaluate it as
     * a number.
     *
     * @param key   A key string.
     * @param defaultValue     The default.
     * @return      An object which is the value.
     */
    public double optDouble(String key, double defaultValue) {
        try {
            return this.getDouble(key);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get an optional int value associated with a key,
     * or zero if there is no such key or if the value is not a number.
     * If the value is a string, an attempt will be made to evaluate it as
     * a number.
     *
     * @param key   A key string.
     * @return      An object which is the value.
     */
    public int optInt(String key) {
        return this.optInt(key, 0);
    }


    /**
     * Get an optional int value associated with a key,
     * or the default if there is no such key or if the value is not a number.
     * If the value is a string, an attempt will be made to evaluate it as
     * a number.
     *
     * @param key   A key string.
     * @param defaultValue     The default.
     * @return      An object which is the value.
     */
    public int optInt(String key, int defaultValue) {
        try {
            return this.getInt(key);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get an optional JSONArray associated with a key.
     * It returns null if there is no such key, or if its value is not a
     * JSONArray.
     *
     * @param key   A key string.
     * @return      A JSONArray which is the value.
     */
    public JSONArray optJSONArray(String key) {
        Object o = this.opt(key);
        return o instanceof JSONArray ? (JSONArray)o : null;
    }


    /**
     * Get an optional JSONObject associated with a key.
     * It returns null if there is no such key, or if its value is not a
     * JSONObject.
     *
     * @param key   A key string.
     * @return      A JSONObject which is the value.
     */
    public JSONObject optJSONObject(String key) {
        Object object = this.opt(key);
        return object instanceof JSONObject ? (JSONObject)object : null;
    }


    /**
     * Get an optional long value associated with a key,
     * or zero if there is no such key or if the value is not a number.
     * If the value is a string, an attempt will be made to evaluate it as
     * a number.
     *
     * @param key   A key string.
     * @return      An object which is the value.
     */
    public long optLong(String key) {
        return this.optLong(key, 0);
    }


    /**
     * Get an optional long value associated with a key,
     * or the default if there is no such key or if the value is not a number.
     * If the value is a string, an attempt will be made to evaluate it as
     * a number.
     *
     * @param key          A key string.
     * @param defaultValue The default.
     * @return             An object which is the value.
     */
    public long optLong(String key, long defaultValue) {
        try {
            return this.getLong(key);
        } catch (Exception e) {
            return defaultValue;
        }
    }


    /**
     * Get an optional string associated with a key.
     * It returns an empty string if there is no such key. If the value is not
     * a string and is not null, then it is converted to a string.
     *
     * @param key   A key string.
     * @return      A string which is the value.
     */
    public String optString(String key) {
        return this.optString(key, "");
    }


    /**
     * Get an optional string associated with a key.
     * It returns the defaultValue if there is no such key.
     *
     * @param key   A key string.
     * @param defaultValue     The default.
     * @return      A string which is the value.
     */
    public String optString(String key, String defaultValue) {
        Object object = this.opt(key);
        return NULL.equals(object) ? defaultValue : object.toString();
    }


    private void populateMap(Object bean) {
        Class<? extends Object> klass = bean.getClass();

// If klass is a System class then set includeSuperClass to false.

        boolean includeSuperClass = klass.getClassLoader() != null;

        Method[] methods = includeSuperClass
                ? klass.getMethods()
                : klass.getDeclaredMethods();
        for (int i = 0; i < methods.length; i += 1) {
            try {
                Method method = methods[i];
                if (Modifier.isPublic(method.getModifiers())) {
                    String name = method.getName();
                    String key = "";
                    if (name.startsWith("get")) {
                        if ("getClass".equals(name) ||
                                "getDeclaringClass".equals(name)) {
                            key = "";
                        } else {
                            key = name.substring(3);
                        }
                    } else if (name.startsWith("is")) {
                        key = name.substring(2);
                    }
                    if (key.length() > 0 &&
                            Character.isUpperCase(key.charAt(0)) &&
                            method.getParameterTypes().length == 0) {
                        if (key.length() == 1) {
                            key = key.toLowerCase();
                        } else if (!Character.isUpperCase(key.charAt(1))) {
                            key = key.substring(0, 1).toLowerCase() +
                                key.substring(1);
                        }

                        Object result = method.invoke(bean, (Object[])null);
                        if (result != null) {
                            this.map.put(key, wrap(result));
                        }
                    }
                }
            } catch (Exception ignore) {
            }
        }
    }


    /**
     * Put a key/boolean pair in the JSONObject.
     *
     * @param key   A key string.
     * @param value A boolean which is the value.
     * @return this.
     * @throws JSONException If the key is null.
     */
    public JSONObject put(String key, boolean value) throws JSONException {
        this.put(key, value ? Boolean.TRUE : Boolean.FALSE);
        return this;
    }


    /**
     * Put a key/value pair in the JSONObject, where the value will be a
     * JSONArray which is produced from a Collection.
     * @param key   A key string.
     * @param value A Collection value.
     * @return      this.
     * @throws JSONException
     */
    public JSONObject put(String key, Collection<Object> value) throws JSONException {
        this.put(key, new JSONArray(value));
        return this;
    }


    /**
     * Put a key/double pair in the JSONObject.
     *
     * @param key   A key string.
     * @param value A double which is the value.
     * @return this.
     * @throws JSONException If the key is null or if the number is invalid.
     */
    public JSONObject put(String key, double value) throws JSONException {
        this.put(key, Double.valueOf(value));
        return this;
    }


    /**
     * Put a key/int pair in the JSONObject.
     *
     * @param key   A key string.
     * @param value An int which is the value.
     * @return this.
     * @throws JSONException If the key is null.
     */
    public JSONObject put(String key, int value) throws JSONException {
        this.put(key, Integer.valueOf(value));
        return this;
    }


    /**
     * Put a key/long pair in the JSONObject.
     *
     * @param key   A key string.
     * @param value A long which is the value.
     * @return this.
     * @throws JSONException If the key is null.
     */
    public JSONObject put(String key, long value) throws JSONException {
        this.put(key, Long.valueOf(value));
        return this;
    }


    /**
     * Put a key/value pair in the JSONObject, where the value will be a
     * JSONObject which is produced from a Map.
     * @param key   A key string.
     * @param value A Map value.
     * @return      this.
     * @throws JSONException
     */
    public JSONObject put(String key, Map<Object, Object> value) throws JSONException {
        this.put(key, new JSONObject(value));
        return this;
    }


    /**
     * Put a key/value pair in the JSONObject. If the value is null,
     * then the key will be removed from the JSONObject if it is present.
     * @param key   A key string.
     * @param value An object which is the value. It should be of one of these
     *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
     *  or the JSONObject.NULL object.
     * @return this.
     * @throws JSONException If the value is non-finite number
     *  or if the key is null.
     */
    public JSONObject put(String key, Object value) throws JSONException {
        if (key == null) {
            throw new JSONException("Null key.");
        }
        if (value != null) {
            testValidity(value);
            this.map.put(key, value);
        } else {
            this.remove(key);
        }
        return this;
    }


    /**
     * Put a key/value pair in the JSONObject, but only if the key and the
     * value are both non-null, and only if there is not already a member
     * with that name.
     * @param key
     * @param value
     * @return his.
     * @throws JSONException if the key is a duplicate
     */
    public JSONObject putOnce(String key, Object value) throws JSONException {
        if (key != null && value != null) {
            if (this.opt(key) != null) {
                throw new JSONException("Duplicate key \"" + key + "\"");
            }
            this.put(key, value);
        }
        return this;
    }


    /**
     * Put a key/value pair in the JSONObject, but only if the
     * key and the value are both non-null.
     * @param key   A key string.
     * @param value An object which is the value. It should be of one of these
     *  types: Boolean, Double, Integer, JSONArray, JSONObject, Long, String,
     *  or the JSONObject.NULL object.
     * @return this.
     * @throws JSONException If the value is a non-finite number.
     */
    public JSONObject putOpt(String key, Object value) throws JSONException {
        if (key != null && value != null) {
            this.put(key, value);
        }
        return this;
    }


    /**
     * Produce a string in double quotes with backslash sequences in all the
     * right places. A backslash will be inserted within </, producing <\/,
     * allowing JSON text to be delivered in HTML. In JSON text, a string
     * cannot contain a control character or an unescaped quote or backslash.
     * @param string A String
     * @return  A String correctly formatted for insertion in a JSON text.
     */
    public static String quote(String string) {
        StringWriter sw = new StringWriter();
        synchronized (sw.getBuffer()) {
            try {
                return quote(string, sw).toString();
            } catch (IOException ignored) {
                // will never happen - we are writing to a string writer
                return "";
            }
        }
    }

    public static Writer quote(String string, Writer w) throws IOException {
        if (string == null || string.length() == 0) {
            w.write("\"\"");
            return w;
        }

        char b;
        char c = 0;
        String hhhh;
        int i;
        int len = string.length();

        w.write('"');
        for (i = 0; i < len; i += 1) {
            b = c;
            c = string.charAt(i);
            switch (c) {
            case '\\':
            case '"':
                w.write('\\');
                w.write(c);
                break;
            case '/':
                if (b == '<') {
                    w.write('\\');
                }
                w.write(c);
                break;
            case '\b':
                w.write("\\b");
                break;
            case '\t':
                w.write("\\t");
                break;
            case '\n':
                w.write("\\n");
                break;
            case '\f':
                w.write("\\f");
                break;
            case '\r':
                w.write("\\r");
                break;
            default:
                if (c < ' ' || (c >= '\u0080' && c < '\u00a0')
                        || (c >= '\u2000' && c < '\u2100')) {
                    hhhh = "000" + Integer.toHexString(c);
                    w.write("\\u" + hhhh.substring(hhhh.length() - 4));
                } else {
                    w.write(c);
                }
            }
        }
        w.write('"');
        return w;
    }

    /**
     * Remove a name and its value, if present.
     * @param key The name to be removed.
     * @return The value that was associated with the name,
     * or null if there was no value.
     */
    public Object remove(String key) {
        return this.map.remove(key);
    }

    /**
     * Try to convert a string into a number, boolean, or null. If the string
     * can't be converted, return the string.
     * @param string A String.
     * @return A simple JSON value.
     */
    public static Object stringToValue(String string) {
        Double d;
        if (string.equals("")) {
            return string;
        }
        if (string.equalsIgnoreCase("true")) {
            return Boolean.TRUE;
        }
        if (string.equalsIgnoreCase("false")) {
            return Boolean.FALSE;
        }
        if (string.equalsIgnoreCase("null")) {
            return JSONObject.NULL;
        }

        /*
         * If it might be a number, try converting it.
         * If a number cannot be produced, then the value will just
         * be a string. Note that the plus and implied string
         * conventions are non-standard. A JSON parser may accept
         * non-JSON forms as long as it accepts all correct JSON forms.
         */

        char b = string.charAt(0);
        if ((b >= '0' && b <= '9') || b == '.' || b == '-' || b == '+') {
            try {
                if (string.indexOf('.') > -1 ||
                        string.indexOf('e') > -1 || string.indexOf('E') > -1) {
                    d = Double.valueOf(string);
                    if (!d.isInfinite() && !d.isNaN()) {
                        return d;
                    }
                } else {
                    Long myLong = Long.valueOf(string);
                    if (myLong.longValue() == myLong.intValue()) {
                        return Integer.valueOf(myLong.intValue());
                    } else {
                        return myLong;
                    }
                }
            }  catch (Exception ignore) {
            }
        }
        return string;
    }


    /**
     * Throw an exception if the object is a NaN or infinite number.
     * @param o The object to test.
     * @throws JSONException If o is a non-finite number.
     */
    public static void testValidity(Object o) throws JSONException {
        if (o != null) {
            if (o instanceof Double) {
                if (((Double)o).isInfinite() || ((Double)o).isNaN()) {
                    throw new JSONException(
                        "JSON does not allow non-finite numbers.");
                }
            } else if (o instanceof Float) {
                if (((Float)o).isInfinite() || ((Float)o).isNaN()) {
                    throw new JSONException(
                        "JSON does not allow non-finite numbers.");
                }
            }
        }
    }


    /**
     * Produce a JSONArray containing the values of the members of this
     * JSONObject.
     * @param names A JSONArray containing a list of key strings. This
     * determines the sequence of the values in the result.
     * @return A JSONArray of values.
     * @throws JSONException If any of the values are non-finite numbers.
     */
    public JSONArray toJSONArray(JSONArray names) throws JSONException {
        if (names == null || names.length() == 0) {
            return null;
        }
        JSONArray ja = new JSONArray();
        for (int i = 0; i < names.length(); i += 1) {
            ja.put(this.opt(names.getString(i)));
        }
        return ja;
    }

    /**
     * Make a JSON text of this JSONObject. For compactness, no whitespace
     * is added. If this would not result in a syntactically correct JSON text,
     * then null will be returned instead.
     * <p>
     * Warning: This method assumes that the data structure is acyclical.
     *
     * @return a printable, displayable, portable, transmittable
     *  representation of the object, beginning
     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
     */
    public String toString() {
        try {
            return this.toString(0);
        } catch (Exception e) {
            return null;
        }
    }


    /**
     * Make a prettyprinted JSON text of this JSONObject.
     * <p>
     * Warning: This method assumes that the data structure is acyclical.
     * @param indentFactor The number of spaces to add to each level of
     *  indentation.
     * @return a printable, displayable, portable, transmittable
     *  representation of the object, beginning
     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
     * @throws JSONException If the object contains an invalid number.
     */
    public String toString(int indentFactor) throws JSONException {
        StringWriter w = new StringWriter();
        synchronized (w.getBuffer()) {
            return this.write(w, indentFactor, 0).toString();
        }
    }

    /**
     * Make a JSON text of an Object value. If the object has an
     * value.toJSONString() method, then that method will be used to produce
     * the JSON text. The method is required to produce a strictly
     * conforming text. If the object does not contain a toJSONString
     * method (which is the most common case), then a text will be
     * produced by other means. If the value is an array or Collection,
     * then a JSONArray will be made from it and its toJSONString method
     * will be called. If the value is a MAP, then a JSONObject will be made
     * from it and its toJSONString method will be called. Otherwise, the
     * value's toString method will be called, and the result will be quoted.
     *
     * <p>
     * Warning: This method assumes that the data structure is acyclical.
     * @param value The value to be serialized.
     * @return a printable, displayable, transmittable
     *  representation of the object, beginning
     *  with <code>{</code>&nbsp;<small>(left brace)</small> and ending
     *  with <code>}</code>&nbsp;<small>(right brace)</small>.
     * @throws JSONException If the value is or contains an invalid number.
     */
    @SuppressWarnings("unchecked")
	public static String valueToString(Object value) throws JSONException {
        if (value == null || value.equals(null)) {
            return "null";
        }
        if (value instanceof JSONString) {
            Object object;
            try {
                object = ((JSONString)value).toJSONString();
            } catch (Exception e) {
                throw new JSONException(e);
            }
            if (object instanceof String) {
                return (String)object;
            }
            throw new JSONException("Bad value from toJSONString: " + object);
        }
        if (value instanceof Number) {
            return numberToString((Number) value);
        }
        if (value instanceof Boolean || value instanceof JSONObject ||
                value instanceof JSONArray) {
            return value.toString();
        }
        if (value instanceof Map) {
            return new JSONObject((Map<Object, Object>)value).toString();
        }
        if (value instanceof Collection) {
            return new JSONArray((Collection<Object>)value).toString();
        }
        if (value.getClass().isArray()) {
            return new JSONArray(value).toString();
        }
        return quote(value.toString());
    }

     /**
      * Wrap an object, if necessary. If the object is null, return the NULL
      * object. If it is an array or collection, wrap it in a JSONArray. If
      * it is a map, wrap it in a JSONObject. If it is a standard property
      * (Double, String, et al) then it is already wrapped. Otherwise, if it
      * comes from one of the java packages, turn it into a string. And if
      * it doesn't, try to wrap it in a JSONObject. If the wrapping fails,
      * then null is returned.
      *
      * @param object The object to wrap
      * @return The wrapped value
      */
     @SuppressWarnings({ "unchecked", "rawtypes" })
	public static Object wrap(Object object) {
         try {
             if (object == null) {
                 return NULL;
             }
             if (object instanceof JSONObject || object instanceof JSONArray  ||
                     NULL.equals(object)      || object instanceof JSONString ||
                     object instanceof Byte   || object instanceof Character  ||
                     object instanceof Short  || object instanceof Integer    ||
                     object instanceof Long   || object instanceof Boolean    ||
                     object instanceof Float  || object instanceof Double     ||
                     object instanceof String) {
                 return object;
             }

             if (object instanceof Collection) {
                 return new JSONArray((Collection)object);
             }
             if (object.getClass().isArray()) {
                 return new JSONArray(object);
             }
             if (object instanceof Map) {
                 return new JSONObject((Map)object);
             }
             Package objectPackage = object.getClass().getPackage();
             String objectPackageName = objectPackage != null
                 ? objectPackage.getName()
                 : "";
             if (
                 objectPackageName.startsWith("java.") ||
                 objectPackageName.startsWith("javax.") ||
                 object.getClass().getClassLoader() == null
             ) {
                 return object.toString();
             }
             return new JSONObject(object);
         } catch(Exception exception) {
             return null;
         }
     }


     /**
      * Write the contents of the JSONObject as JSON text to a writer.
      * For compactness, no whitespace is added.
      * <p>
      * Warning: This method assumes that the data structure is acyclical.
      *
      * @return The writer.
      * @throws JSONException
      */
     public Writer write(Writer writer) throws JSONException {
        return this.write(writer, 0, 0);
    }


    @SuppressWarnings({ "unchecked", "rawtypes" })
	static final Writer writeValue(Writer writer, Object value,
            int indentFactor, int indent) throws JSONException, IOException {
        if (value instanceof JSONObject) {
            ((JSONObject) value).write(writer, indentFactor, indent);
        } else if (value instanceof JSONArray) {
            ((JSONArray) value).write(writer, indentFactor, indent);
        } else if (value instanceof Map) {
            new JSONObject((Map) value).write(writer, indentFactor, indent);
        } else if (value instanceof Collection) {
            new JSONArray((Collection) value).write(writer, indentFactor,
                    indent);
        } else if (value.getClass().isArray()) {
            new JSONArray(value).write(writer, indentFactor, indent);
        } else if (value instanceof Number) {
            writer.write(numberToString((Number) value));
        } else if (value instanceof Boolean) {
            writer.write(value.toString());
        } else if (value instanceof JSONString) {
            Object o;
            try {
                o = ((JSONString) value).toJSONString();
            } catch (Exception e) {
                throw new JSONException(e);
            }
            writer.write(o != null ? o.toString() : quote(value.toString()));
        } else if (value == null || value.equals(null)) {
            writer.write("null");
        } else {
            quote(value.toString(), writer);
        }
        return writer;
    }

    static final void indent(Writer writer, int indent) throws IOException {
        for (int i = 0; i < indent; i += 1) {
            writer.write(' ');
        }
    }

    /**
     * Write the contents of the JSONObject as JSON text to a writer. For
     * compactness, no whitespace is added.
     * <p>
     * Warning: This method assumes that the data structure is acyclical.
     *
     * @return The writer.
     * @throws JSONException
     */
    @SuppressWarnings("rawtypes")
	Writer write(Writer writer, int indentFactor, int indent)
            throws JSONException {
        try {
            boolean commanate = false;
            final int length = this.length();
            Iterator keys = this.keys();
            writer.write('{');

            if (length == 1) {
                Object key = keys.next();
                writer.write(quote(key.toString()));
                writer.write(':');
                if (indentFactor > 0) {
                    writer.write(' ');
                }
                writeValue(writer, this.map.get(key), indentFactor, indent);
            } else if (length != 0) {
                final int newindent = indent + indentFactor;
                while (keys.hasNext()) {
                    Object key = keys.next();
                    if (commanate) {
                        writer.write(',');
                    }
                    if (indentFactor > 0) {
                        writer.write('\n');
                    }
                    indent(writer, newindent);
                    writer.write(quote(key.toString()));
                    writer.write(':');
                    if (indentFactor > 0) {
                        writer.write(' ');
                    }
                    writeValue(writer, this.map.get(key), indentFactor,
                            newindent);
                    commanate = true;
                }
                if (indentFactor > 0) {
                    writer.write('\n');
                }
                indent(writer, indent);
            }
            writer.write('}');
            return writer;
        } catch (IOException exception) {
            throw new JSONException(exception);
        }
     }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONString.java
================================================
package com.ejie.x38.json;
/**
 * The <code>JSONString</code> interface allows a <code>toJSONString()</code> 
 * method so that a class can change the behavior of 
 * <code>JSONObject.toString()</code>, <code>JSONArray.toString()</code>,
 * and <code>JSONWriter.value(</code>Object<code>)</code>. The 
 * <code>toJSONString</code> method will be used instead of the default behavior 
 * of using the Object's <code>toString()</code> method and quoting the result.
 */
public interface JSONString {
    /**
     * The <code>toJSONString</code> method allows a class to produce its own JSON 
     * serialization. 
     * 
     * @return A strictly syntactically correct JSON text.
     */
    public String toJSONString();
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONStringer.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2006 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import java.io.StringWriter;

/**
 * JSONStringer provides a quick and convenient way of producing JSON text.
 * The texts produced strictly conform to JSON syntax rules. No whitespace is
 * added, so the results are ready for transmission or storage. Each instance of
 * JSONStringer can produce one JSON text.
 * <p>
 * A JSONStringer instance provides a <code>value</code> method for appending
 * values to the
 * text, and a <code>key</code>
 * method for adding keys before values in objects. There are <code>array</code>
 * and <code>endArray</code> methods that make and bound array values, and
 * <code>object</code> and <code>endObject</code> methods which make and bound
 * object values. All of these methods return the JSONWriter instance,
 * permitting cascade style. For example, <pre>
 * myString = new JSONStringer()
 *     .object()
 *         .key("JSON")
 *         .value("Hello, World!")
 *     .endObject()
 *     .toString();</pre> which produces the string <pre>
 * {"JSON":"Hello, World!"}</pre>
 * <p>
 * The first method called must be <code>array</code> or <code>object</code>.
 * There are no methods for adding commas or colons. JSONStringer adds them for
 * you. Objects and arrays can be nested up to 20 levels deep.
 * <p>
 * This can sometimes be easier than using a JSONObject to build a string.
 * @author JSON.org
 * @version 2008-09-18
 */
public class JSONStringer extends JSONWriter {
    /**
     * Make a fresh JSONStringer. It can be used to build one JSON text.
     */
    public JSONStringer() {
        super(new StringWriter());
    }

    /**
     * Return the JSON text. This method is used to obtain the product of the
     * JSONStringer instance. It will return <code>null</code> if there was a
     * problem in the construction of the JSON text (such as the calls to
     * <code>array</code> were not properly balanced with calls to
     * <code>endArray</code>).
     * @return The JSON text.
     */
    public String toString() {
        return this.mode == 'd' ? this.writer.toString() : null;
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONTokener.java
================================================
package com.ejie.x38.json;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.StringReader;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/**
 * A JSONTokener takes a source string and extracts characters and tokens from
 * it. It is used by the JSONObject and JSONArray constructors to parse
 * JSON source strings.
 * @author JSON.org
 * @version 2012-02-16
 */
public class JSONTokener {

    private long    character;
    private boolean eof;
    private long    index;
    private long    line;
    private char    previous;
    private Reader  reader;
    private boolean usePrevious;


    /**
     * Construct a JSONTokener from a Reader.
     *
     * @param reader     A reader.
     */
    public JSONTokener(Reader reader) {
        this.reader = reader.markSupported()
            ? reader
            : new BufferedReader(reader);
        this.eof = false;
        this.usePrevious = false;
        this.previous = 0;
        this.index = 0;
        this.character = 1;
        this.line = 1;
    }


    /**
     * Construct a JSONTokener from an InputStream.
     */
    public JSONTokener(InputStream inputStream) throws JSONException {
        this(new InputStreamReader(inputStream));
    }


    /**
     * Construct a JSONTokener from a string.
     *
     * @param s     A source string.
     */
    public JSONTokener(String s) {
        this(new StringReader(s));
    }


    /**
     * Back up one character. This provides a sort of lookahead capability,
     * so that you can test for a digit or letter before attempting to parse
     * the next number or identifier.
     */
    public void back() throws JSONException {
        if (this.usePrevious || this.index <= 0) {
            throw new JSONException("Stepping back two steps is not supported");
        }
        this.index -= 1;
        this.character -= 1;
        this.usePrevious = true;
        this.eof = false;
    }


    /**
     * Get the hex value of a character (base16).
     * @param c A character between '0' and '9' or between 'A' and 'F' or
     * between 'a' and 'f'.
     * @return  An int between 0 and 15, or -1 if c was not a hex digit.
     */
    public static int dehexchar(char c) {
        if (c >= '0' && c <= '9') {
            return c - '0';
        }
        if (c >= 'A' && c <= 'F') {
            return c - ('A' - 10);
        }
        if (c >= 'a' && c <= 'f') {
            return c - ('a' - 10);
        }
        return -1;
    }

    public boolean end() {
        return this.eof && !this.usePrevious;
    }


    /**
     * Determine if the source string still contains characters that next()
     * can consume.
     * @return true if not yet at the end of the source.
     */
    public boolean more() throws JSONException {
        this.next();
        if (this.end()) {
            return false;
        }
        this.back();
        return true;
    }


    /**
     * Get the next character in the source string.
     *
     * @return The next character, or 0 if past the end of the source string.
     */
    public char next() throws JSONException {
        int c;
        if (this.usePrevious) {
            this.usePrevious = false;
            c = this.previous;
        } else {
            try {
                c = this.reader.read();
            } catch (IOException exception) {
                throw new JSONException(exception);
            }

            if (c <= 0) { // End of stream
                this.eof = true;
                c = 0;
            }
        }
        this.index += 1;
        if (this.previous == '\r') {
            this.line += 1;
            this.character = c == '\n' ? 0 : 1;
        } else if (c == '\n') {
            this.line += 1;
            this.character = 0;
        } else {
            this.character += 1;
        }
        this.previous = (char) c;
        return this.previous;
    }


    /**
     * Consume the next character, and check that it matches a specified
     * character.
     * @param c The character to match.
     * @return The character.
     * @throws JSONException if the character does not match.
     */
    public char next(char c) throws JSONException {
        char n = this.next();
        if (n != c) {
            throw this.syntaxError("Expected '" + c + "' and instead saw '" +
                    n + "'");
        }
        return n;
    }


    /**
     * Get the next n characters.
     *
     * @param n     The number of characters to take.
     * @return      A string of n characters.
     * @throws JSONException
     *   Substring bounds error if there are not
     *   n characters remaining in the source string.
     */
     public String next(int n) throws JSONException {
         if (n == 0) {
             return "";
         }

         char[] chars = new char[n];
         int pos = 0;

         while (pos < n) {
             chars[pos] = this.next();
             if (this.end()) {
                 throw this.syntaxError("Substring bounds error");
             }
             pos += 1;
         }
         return new String(chars);
     }


    /**
     * Get the next char in the string, skipping whitespace.
     * @throws JSONException
     * @return  A character, or 0 if there are no more characters.
     */
    public char nextClean() throws JSONException {
        for (;;) {
            char c = this.next();
            if (c == 0 || c > ' ') {
                return c;
            }
        }
    }


    /**
     * Return the characters up to the next close quote character.
     * Backslash processing is done. The formal JSON format does not
     * allow strings in single quotes, but an implementation is allowed to
     * accept them.
     * @param quote The quoting character, either
     *      <code>"</code>&nbsp;<small>(double quote)</small> or
     *      <code>'</code>&nbsp;<small>(single quote)</small>.
     * @return      A String.
     * @throws JSONException Unterminated string.
     */
    public String nextString(char quote) throws JSONException {
        char c;
        StringBuffer sb = new StringBuffer();
        for (;;) {
            c = this.next();
            switch (c) {
            case 0:
            case '\n':
            case '\r':
                throw this.syntaxError("Unterminated string");
            case '\\':
                c = this.next();
                switch (c) {
                case 'b':
                    sb.append('\b');
                    break;
                case 't':
                    sb.append('\t');
                    break;
                case 'n':
                    sb.append('\n');
                    break;
                case 'f':
                    sb.append('\f');
                    break;
                case 'r':
                    sb.append('\r');
                    break;
                case 'u':
                    sb.append((char)Integer.parseInt(this.next(4), 16));
                    break;
                case '"':
                case '\'':
                case '\\':
                case '/':
                    sb.append(c);
                    break;
                default:
                    throw this.syntaxError("Illegal escape.");
                }
                break;
            default:
                if (c == quote) {
                    return sb.toString();
                }
                sb.append(c);
            }
        }
    }


    /**
     * Get the text up but not including the specified character or the
     * end of line, whichever comes first.
     * @param  delimiter A delimiter character.
     * @return   A string.
     */
    public String nextTo(char delimiter) throws JSONException {
        StringBuffer sb = new StringBuffer();
        for (;;) {
            char c = this.next();
            if (c == delimiter || c == 0 || c == '\n' || c == '\r') {
                if (c != 0) {
                    this.back();
                }
                return sb.toString().trim();
            }
            sb.append(c);
        }
    }


    /**
     * Get the text up but not including one of the specified delimiter
     * characters or the end of line, whichever comes first.
     * @param delimiters A set of delimiter characters.
     * @return A string, trimmed.
     */
    public String nextTo(String delimiters) throws JSONException {
        char c;
        StringBuffer sb = new StringBuffer();
        for (;;) {
            c = this.next();
            if (delimiters.indexOf(c) >= 0 || c == 0 ||
                    c == '\n' || c == '\r') {
                if (c != 0) {
                    this.back();
                }
                return sb.toString().trim();
            }
            sb.append(c);
        }
    }


    /**
     * Get the next value. The value can be a Boolean, Double, Integer,
     * JSONArray, JSONObject, Long, or String, or the JSONObject.NULL object.
     * @throws JSONException If syntax error.
     *
     * @return An object.
     */
    public Object nextValue() throws JSONException {
        char c = this.nextClean();
        String string;

        switch (c) {
            case '"':
            case '\'':
                return this.nextString(c);
            case '{':
                this.back();
                return new JSONObject(this);
            case '[':
                this.back();
                return new JSONArray(this);
        }

        /*
         * Handle unquoted text. This could be the values true, false, or
         * null, or it can be a number. An implementation (such as this one)
         * is allowed to also accept non-standard forms.
         *
         * Accumulate characters until we reach the end of the text or a
         * formatting character.
         */

        StringBuffer sb = new StringBuffer();
        while (c >= ' ' && ",:]}/\\\"[{;=#".indexOf(c) < 0) {
            sb.append(c);
            c = this.next();
        }
        this.back();

        string = sb.toString().trim();
        if ("".equals(string)) {
            throw this.syntaxError("Missing value");
        }
        return JSONObject.stringToValue(string);
    }


    /**
     * Skip characters until the next character is the requested character.
     * If the requested character is not found, no characters are skipped.
     * @param to A character to skip to.
     * @return The requested character, or zero if the requested character
     * is not found.
     */
    public char skipTo(char to) throws JSONException {
        char c;
        try {
            long startIndex = this.index;
            long startCharacter = this.character;
            long startLine = this.line;
            this.reader.mark(1000000);
            do {
                c = this.next();
                if (c == 0) {
                    this.reader.reset();
                    this.index = startIndex;
                    this.character = startCharacter;
                    this.line = startLine;
                    return c;
                }
            } while (c != to);
        } catch (IOException exc) {
            throw new JSONException(exc);
        }

        this.back();
        return c;
    }


    /**
     * Make a JSONException to signal a syntax error.
     *
     * @param message The error message.
     * @return  A JSONException object, suitable for throwing
     */
    public JSONException syntaxError(String message) {
        return new JSONException(message + this.toString());
    }


    /**
     * Make a printable string of this JSONTokener.
     *
     * @return " at {index} [character {character} line {line}]"
     */
    public String toString() {
        return " at " + this.index + " [character " + this.character + " line " +
            this.line + "]";
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JSONWriter.java
================================================
package com.ejie.x38.json;

import java.io.IOException;
import java.io.Writer;

/*
Copyright (c) 2006 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/**
 * JSONWriter provides a quick and convenient way of producing JSON text.
 * The texts produced strictly conform to JSON syntax rules. No whitespace is
 * added, so the results are ready for transmission or storage. Each instance of
 * JSONWriter can produce one JSON text.
 * <p>
 * A JSONWriter instance provides a <code>value</code> method for appending
 * values to the
 * text, and a <code>key</code>
 * method for adding keys before values in objects. There are <code>array</code>
 * and <code>endArray</code> methods that make and bound array values, and
 * <code>object</code> and <code>endObject</code> methods which make and bound
 * object values. All of these methods return the JSONWriter instance,
 * permitting a cascade style. For example, <pre>
 * new JSONWriter(myWriter)
 *     .object()
 *         .key("JSON")
 *         .value("Hello, World!")
 *     .endObject();</pre> which writes <pre>
 * {"JSON":"Hello, World!"}</pre>
 * <p>
 * The first method called must be <code>array</code> or <code>object</code>.
 * There are no methods for adding commas or colons. JSONWriter adds them for
 * you. Objects and arrays can be nested up to 20 levels deep.
 * <p>
 * This can sometimes be easier than using a JSONObject to build a string.
 * @author JSON.org
 * @version 2011-11-24
 */
public class JSONWriter {
    private static final int maxdepth = 200;

    /**
     * The comma flag determines if a comma should be output before the next
     * value.
     */
    private boolean comma;

    /**
     * The current mode. Values:
     * 'a' (array),
     * 'd' (done),
     * 'i' (initial),
     * 'k' (key),
     * 'o' (object).
     */
    protected char mode;

    /**
     * The object/array stack.
     */
    private final JSONObject stack[];

    /**
     * The stack top index. A value of 0 indicates that the stack is empty.
     */
    private int top;

    /**
     * The writer that will receive the output.
     */
    protected Writer writer;

    /**
     * Make a fresh JSONWriter. It can be used to build one JSON text.
     */
    public JSONWriter(Writer w) {
        this.comma = false;
        this.mode = 'i';
        this.stack = new JSONObject[maxdepth];
        this.top = 0;
        this.writer = w;
    }

    /**
     * Append a value.
     * @param string A string value.
     * @return this
     * @throws JSONException If the value is out of sequence.
     */
    protected JSONWriter append(String string) throws JSONException {
        if (string == null) {
            throw new JSONException("Null pointer");
        }
        if (this.mode == 'o' || this.mode == 'a') {
            try {
                if (this.comma && this.mode == 'a') {
                    this.writer.write(',');
                }
                this.writer.write(string);
            } catch (IOException e) {
                throw new JSONException(e);
            }
            if (this.mode == 'o') {
                this.mode = 'k';
            }
            this.comma = true;
            return this;
        }
        throw new JSONException("Value out of sequence.");
    }

    /**
     * Begin appending a new array. All values until the balancing
     * <code>endArray</code> will be appended to this array. The
     * <code>endArray</code> method must be called to mark the array's end.
     * @return this
     * @throws JSONException If the nesting is too deep, or if the object is
     * started in the wrong place (for example as a key or after the end of the
     * outermost array or object).
     */
    public JSONWriter array() throws JSONException {
        if (this.mode == 'i' || this.mode == 'o' || this.mode == 'a') {
            this.push(null);
            this.append("[");
            this.comma = false;
            return this;
        }
        throw new JSONException("Misplaced array.");
    }

    /**
     * End something.
     * @param mode Mode
     * @param c Closing character
     * @return this
     * @throws JSONException If unbalanced.
     */
    private JSONWriter end(char mode, char c) throws JSONException {
        if (this.mode != mode) {
            throw new JSONException(mode == 'a'
                ? "Misplaced endArray."
                : "Misplaced endObject.");
        }
        this.pop(mode);
        try {
            this.writer.write(c);
        } catch (IOException e) {
            throw new JSONException(e);
        }
        this.comma = true;
        return this;
    }

    /**
     * End an array. This method most be called to balance calls to
     * <code>array</code>.
     * @return this
     * @throws JSONException If incorrectly nested.
     */
    public JSONWriter endArray() throws JSONException {
        return this.end('a', ']');
    }

    /**
     * End an object. This method most be called to balance calls to
     * <code>object</code>.
     * @return this
     * @throws JSONException If incorrectly nested.
     */
    public JSONWriter endObject() throws JSONException {
        return this.end('k', '}');
    }

    /**
     * Append a key. The key will be associated with the next value. In an
     * object, every value must be preceded by a key.
     * @param string A key string.
     * @return this
     * @throws JSONException If the key is out of place. For example, keys
     *  do not belong in arrays or if the key is null.
     */
    public JSONWriter key(String string) throws JSONException {
        if (string == null) {
            throw new JSONException("Null key.");
        }
        if (this.mode == 'k') {
            try {
                this.stack[this.top - 1].putOnce(string, Boolean.TRUE);
                if (this.comma) {
                    this.writer.write(',');
                }
                this.writer.write(JSONObject.quote(string));
                this.writer.write(':');
                this.comma = false;
                this.mode = 'o';
                return this;
            } catch (IOException e) {
                throw new JSONException(e);
            }
        }
        throw new JSONException("Misplaced key.");
    }


    /**
     * Begin appending a new object. All keys and values until the balancing
     * <code>endObject</code> will be appended to this object. The
     * <code>endObject</code> method must be called to mark the object's end.
     * @return this
     * @throws JSONException If the nesting is too deep, or if the object is
     * started in the wrong place (for example as a key or after the end of the
     * outermost array or object).
     */
    public JSONWriter object() throws JSONException {
        if (this.mode == 'i') {
            this.mode = 'o';
        }
        if (this.mode == 'o' || this.mode == 'a') {
            this.append("{");
            this.push(new JSONObject());
            this.comma = false;
            return this;
        }
        throw new JSONException("Misplaced object.");

    }


    /**
     * Pop an array or object scope.
     * @param c The scope to close.
     * @throws JSONException If nesting is wrong.
     */
    private void pop(char c) throws JSONException {
        if (this.top <= 0) {
            throw new JSONException("Nesting error.");
        }
        char m = this.stack[this.top - 1] == null ? 'a' : 'k';
        if (m != c) {
            throw new JSONException("Nesting error.");
        }
        this.top -= 1;
        this.mode = this.top == 0
            ? 'd'
            : this.stack[this.top - 1] == null
            ? 'a'
            : 'k';
    }

    /**
     * Push an array or object scope.
     * @param c The scope to open.
     * @throws JSONException If nesting is too deep.
     */
    private void push(JSONObject jo) throws JSONException {
        if (this.top >= maxdepth) {
            throw new JSONException("Nesting too deep.");
        }
        this.stack[this.top] = jo;
        this.mode = jo == null ? 'a' : 'k';
        this.top += 1;
    }


    /**
     * Append either the value <code>true</code> or the value
     * <code>false</code>.
     * @param b A boolean.
     * @return this
     * @throws JSONException
     */
    public JSONWriter value(boolean b) throws JSONException {
        return this.append(b ? "true" : "false");
    }

    /**
     * Append a double value.
     * @param d A double.
     * @return this
     * @throws JSONException If the number is not finite.
     */
    public JSONWriter value(double d) throws JSONException {
        return this.value(Double.valueOf(d));
    }

    /**
     * Append a long value.
     * @param l A long.
     * @return this
     * @throws JSONException
     */
    public JSONWriter value(long l) throws JSONException {
        return this.append(Long.toString(l));
    }


    /**
     * Append an object value.
     * @param object The object to append. It can be null, or a Boolean, Number,
     *   String, JSONObject, or JSONArray, or an object that implements JSONString.
     * @return this
     * @throws JSONException If the value is out of sequence.
     */
    public JSONWriter value(Object object) throws JSONException {
        return this.append(JSONObject.valueToString(object));
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/JsonMixin.java
================================================
package com.ejie.x38.json;

import java.io.Serializable;

public @interface JsonMixin {
    public Class<? extends Serializable> target();
    public Class<?> mixin();
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/MessageWriter.java
================================================
package com.ejie.x38.json;

import java.io.StringWriter;
import java.util.Locale;

import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;

public class MessageWriter extends JSONWriter {

	
	
	public MessageWriter() {
        super(new StringWriter());
    }
	
	
	public MessageWriter startMessageList(){
		this.array();
		
		return this;
	}
	
	public MessageWriter endMessageList(){
		this.endArray();
		
		return this;
	}
	
	/*
	 * ESCRITURA DE STRINGS
	 */
	/**
	 * 
	 * @param messageList
	 * @return
	 */
	public MessageWriter addMessage(String ... messageList ){
		
		for (String message : messageList) {
			this.value(message);
		}
		
		return this;
	}
	
	public MessageWriter addMessage(MessageSource messageSource, String ... messageList ){
		
		Locale locale = LocaleContextHolder.getLocale();
		
		for (String message : messageList) {
			this.value(messageSource.getMessage(message, null, locale));
		}
		
		return this;
	}
	
	public MessageWriter addMessage(MessageSource messageSource, String message, Object[] messageParams ){
		
		Locale locale = LocaleContextHolder.getLocale();
		
		this.value(messageSource.getMessage(message, messageParams, locale));
		
		return this;
	}
	
	/*
	 * ESCRITURA DE OBJETOS JSON
	 */
	
	public MessageWriter addComplexMessage(String message){
		return this.addComplexMessage(null, message, null, null, false);
	}
	
	public MessageWriter addComplexMessage(String message, boolean i18nRupResource){
		return this.addComplexMessage(null, message, null, null, i18nRupResource);
	}
	
	public MessageWriter addComplexMessage(String message, String style){
		return this.addComplexMessage(null, message, null, style, false);
	}
	
	public MessageWriter addComplexMessage(MessageSource messageSource, String message){
		return this.addComplexMessage(messageSource, message, null, null, false);
	}
	
//	public MessageWriter addComplexMessage(MessageSource messageSource, String message, boolean i18nRupResource){
//		return this.addComplexMessage(messageSource, message, null, null, i18nRupResource);
//	}
	
	public MessageWriter addComplexMessage(MessageSource messageSource, String message, String style){
		return this.addComplexMessage(messageSource, message, null, style, false);
	}
	
	public MessageWriter addComplexMessage(MessageSource messageSource, Object[] messageParams, String message){
		return this.addComplexMessage(messageSource, message, messageParams, null, false);
	}
	
//	public MessageWriter addComplexMessage(MessageSource messageSource, String message, Object[] messageParams, boolean i18nRupResource){
//		return this.addComplexMessage(messageSource, message, messageParams, null, i18nRupResource);
//	}
	
	public MessageWriter addComplexMessage(MessageSource messageSource, String message, Object[] messageParams, String style){
		return this.addComplexMessage(messageSource, message, messageParams, style, false);
	}
	
	public MessageWriter addComplexMessage(MessageSource messageSource, String message, Object[] messageParams, String style, boolean i18nRupResource){
		
		this.object();
		
		this.key((i18nRupResource ? "i18nCaption" : "label"));
		if (messageSource!=null){
			Locale locale = LocaleContextHolder.getLocale();
			this.value(messageSource.getMessage(message, messageParams,  locale));
		}else{
			this.value(message);
		}
		
		if (style!=null){
			this.key("style").value(style);
		}
		
		this.endObject();
		
		return this;
	}
	
	/*
	 * FUNCIONES DE ANIDACION
	 */
	public MessageWriter startSubLevel(){
		this.array();
		return this;
	}
	
	public MessageWriter endSubLevel(){
		this.endArray();
		return this;
	}
	
	
	public String toString() {
//		return this.writer.toString();
        return this.mode == 'd' ? this.writer.toString() : null;
    }
	
	/*
	 * Retorno de 
	 */
	public JSONArray getJSONArray(){
		
		return new JSONArray(this.toString());
		
	}
	
	public JSONObject getJSONObject(){
		
		return new JSONObject(this.toString());
		
	}
	
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/XML.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

import java.util.Iterator;


/**
 * This provides static methods to convert an XML text into a JSONObject,
 * and to covert a JSONObject into an XML text.
 * @author JSON.org
 * @version 2011-02-11
 */
public class XML {

    /** The Character '&'. */
    public static final Character AMP   = Character.valueOf('&');

    /** The Character '''. */
    public static final Character APOS  = Character.valueOf('\'');

    /** The Character '!'. */
    public static final Character BANG  = Character.valueOf('!');

    /** The Character '='. */
    public static final Character EQ    = Character.valueOf('=');

    /** The Character '>'. */
    public static final Character GT    = Character.valueOf('>');

    /** The Character '<'. */
    public static final Character LT    = Character.valueOf('<');

    /** The Character '?'. */
    public static final Character QUEST = Character.valueOf('?');

    /** The Character '"'. */
    public static final Character QUOT  = Character.valueOf('"');

    /** The Character '/'. */
    public static final Character SLASH = Character.valueOf('/');

    /**
     * Replace special characters with XML escapes:
     * <pre>
     * &amp; <small>(ampersand)</small> is replaced by &amp;amp;
     * &lt; <small>(less than)</small> is replaced by &amp;lt;
     * &gt; <small>(greater than)</small> is replaced by &amp;gt;
     * &quot; <small>(double quote)</small> is replaced by &amp;quot;
     * </pre>
     * @param string The string to be escaped.
     * @return The escaped string.
     */
    public static String escape(String string) {
        StringBuffer sb = new StringBuffer();
        for (int i = 0, length = string.length(); i < length; i++) {
            char c = string.charAt(i);
            switch (c) {
            case '&':
                sb.append("&amp;");
                break;
            case '<':
                sb.append("&lt;");
                break;
            case '>':
                sb.append("&gt;");
                break;
            case '"':
                sb.append("&quot;");
                break;
            case '\'':
                sb.append("&apos;");
                break;
            default:
                sb.append(c);
            }
        }
        return sb.toString();
    }
    
    /**
     * Throw an exception if the string contains whitespace. 
     * Whitespace is not allowed in tagNames and attributes.
     * @param string
     * @throws JSONException
     */
    public static void noSpace(String string) throws JSONException {
        int i, length = string.length();
        if (length == 0) {
            throw new JSONException("Empty string.");
        }
        for (i = 0; i < length; i += 1) {
            if (Character.isWhitespace(string.charAt(i))) {
                throw new JSONException("'" + string + 
                        "' contains a space character.");
            }
        }
    }

    /**
     * Scan the content following the named tag, attaching it to the context.
     * @param x       The XMLTokener containing the source string.
     * @param context The JSONObject that will include the new material.
     * @param name    The tag name.
     * @return true if the close tag is processed.
     * @throws JSONException
     */
    private static boolean parse(XMLTokener x, JSONObject context,
                                 String name) throws JSONException {
        char       c;
        int        i;
        JSONObject jsonobject = null;
        String     string;
        String     tagName;
        Object     token;

// Test for and skip past these forms:
//      <!-- ... -->
//      <!   ...   >
//      <![  ... ]]>
//      <?   ...  ?>
// Report errors for these forms:
//      <>
//      <=
//      <<

        token = x.nextToken();

// <!

        if (token == BANG) {
            c = x.next();
            if (c == '-') {
                if (x.next() == '-') {
                    x.skipPast("-->");
                    return false;
                }
                x.back();
            } else if (c == '[') {
                token = x.nextToken();
                if ("CDATA".equals(token)) {
                    if (x.next() == '[') {
                        string = x.nextCDATA();
                        if (string.length() > 0) {
                            context.accumulate("content", string);
                        }
                        return false;
                    }
                }
                throw x.syntaxError("Expected 'CDATA['");
            }
            i = 1;
            do {
                token = x.nextMeta();
                if (token == null) {
                    throw x.syntaxError("Missing '>' after '<!'.");
                } else if (token == LT) {
                    i += 1;
                } else if (token == GT) {
                    i -= 1;
                }
            } while (i > 0);
            return false;
        } else if (token == QUEST) {

// <?

            x.skipPast("?>");
            return false;
        } else if (token == SLASH) {

// Close tag </

            token = x.nextToken();
            if (name == null) {
                throw x.syntaxError("Mismatched close tag " + token);
            }            
            if (!token.equals(name)) {
                throw x.syntaxError("Mismatched " + name + " and " + token);
            }
            if (x.nextToken() != GT) {
                throw x.syntaxError("Misshaped close tag");
            }
            return true;

        } else if (token instanceof Character) {
            throw x.syntaxError("Misshaped tag");

// Open tag <

        } else {
            tagName = (String)token;
            token = null;
            jsonobject = new JSONObject();
            for (;;) {
                if (token == null) {
                    token = x.nextToken();
                }

// attribute = value

                if (token instanceof String) {
                    string = (String)token;
                    token = x.nextToken();
                    if (token == EQ) {
                        token = x.nextToken();
                        if (!(token instanceof String)) {
                            throw x.syntaxError("Missing value");
                        }
                        jsonobject.accumulate(string, 
                                XML.stringToValue((String)token));
                        token = null;
                    } else {
                        jsonobject.accumulate(string, "");
                    }

// Empty tag <.../>

                } else if (token == SLASH) {
                    if (x.nextToken() != GT) {
                        throw x.syntaxError("Misshaped tag");
                    }
                    if (jsonobject.length() > 0) {
                        context.accumulate(tagName, jsonobject);
                    } else {
                        context.accumulate(tagName, "");
                    }
                    return false;

// Content, between <...> and </...>

                } else if (token == GT) {
                    for (;;) {
                        token = x.nextContent();
                        if (token == null) {
                            if (tagName != null) {
                                throw x.syntaxError("Unclosed tag " + tagName);
                            }
                            return false;
                        } else if (token instanceof String) {
                            string = (String)token;
                            if (string.length() > 0) {
                                jsonobject.accumulate("content", 
                                        XML.stringToValue(string));
                            }

// Nested element

                        } else if (token == LT) {
                            if (parse(x, jsonobject, tagName)) {
                                if (jsonobject.length() == 0) {
                                    context.accumulate(tagName, "");
                                } else if (jsonobject.length() == 1 &&
                                       jsonobject.opt("content") != null) {
                                    context.accumulate(tagName, 
                                            jsonobject.opt("content"));
                                } else {
                                    context.accumulate(tagName, jsonobject);
                                }
                                return false;
                            }
                        }
                    }
                } else {
                    throw x.syntaxError("Misshaped tag");
                }
            }
        }
    }


    /**
     * Try to convert a string into a number, boolean, or null. If the string
     * can't be converted, return the string. This is much less ambitious than
     * JSONObject.stringToValue, especially because it does not attempt to
     * convert plus forms, octal forms, hex forms, or E forms lacking decimal 
     * points.
     * @param string A String.
     * @return A simple JSON value.
     */
    public static Object stringToValue(String string) {
        if ("".equals(string)) {
            return string;
        }
        if ("true".equalsIgnoreCase(string)) {
            return Boolean.TRUE;
        }
        if ("false".equalsIgnoreCase(string)) {
            return Boolean.FALSE;
        }
        if ("null".equalsIgnoreCase(string)) {
            return JSONObject.NULL;
        }
        if ("0".equals(string)) {
            return Integer.valueOf(0);
        }

// If it might be a number, try converting it. If that doesn't work, 
// return the string.

        try {
            char initial = string.charAt(0);
            boolean negative = false;
            if (initial == '-') {
                initial = string.charAt(1);
                negative = true;
            }
            if (initial == '0' && string.charAt(negative ? 2 : 1) == '0') {
                return string;
            }
            if ((initial >= '0' && initial <= '9')) {
                if (string.indexOf('.') >= 0) {
                    return Double.valueOf(string);
                } else if (string.indexOf('e') < 0 && string.indexOf('E') < 0) {
                    Long myLong = Long.valueOf(string);
                    if (myLong.longValue() == myLong.intValue()) {
                        return Integer.valueOf(myLong.intValue());
                    } else {
                        return myLong;
                    }
                }
            }
        }  catch (Exception ignore) {
        }
        return string;
    }

    
    /**
     * Convert a well-formed (but not necessarily valid) XML string into a
     * JSONObject. Some information may be lost in this transformation
     * because JSON is a data format and XML is a document format. XML uses
     * elements, attributes, and content text, while JSON uses unordered
     * collections of name/value pairs and arrays of values. JSON does not
     * does not like to distinguish between elements and attributes.
     * Sequences of similar elements are represented as JSONArrays. Content
     * text may be placed in a "content" member. Comments, prologs, DTDs, and
     * <code>&lt;[ [ ]]></code> are ignored.
     * @param string The source string.
     * @return A JSONObject containing the structured data from the XML string.
     * @throws JSONException
     */
    public static JSONObject toJSONObject(String string) throws JSONException {
        JSONObject jo = new JSONObject();
        XMLTokener x = new XMLTokener(string);
        while (x.more() && x.skipPast("<")) {
            parse(x, jo, null);
        }
        return jo;
    }


    /**
     * Convert a JSONObject into a well-formed, element-normal XML string.
     * @param object A JSONObject.
     * @return  A string.
     * @throws  JSONException
     */
    public static String toString(Object object) throws JSONException {
        return toString(object, null);
    }


    /**
     * Convert a JSONObject into a well-formed, element-normal XML string.
     * @param object A JSONObject.
     * @param tagName The optional name of the enclosing tag.
     * @return A string.
     * @throws JSONException
     */
    @SuppressWarnings("rawtypes")
	public static String toString(Object object, String tagName)
            throws JSONException {
        StringBuffer sb = new StringBuffer();
        int          i;
        JSONArray    ja;
        JSONObject   jo;
        String       key;
        Iterator     keys;
        int          length;
        String       string;
        Object       value;
        if (object instanceof JSONObject) {

// Emit <tagName>

            if (tagName != null) {
                sb.append('<');
                sb.append(tagName);
                sb.append('>');
            }

// Loop thru the keys.

            jo = (JSONObject)object;
            keys = jo.keys();
            while (keys.hasNext()) {
                key = keys.next().toString();
                value = jo.opt(key);
                if (value == null) {
                    value = "";
                }
                if (value instanceof String) {
                    string = (String)value;
                } else {
                    string = null;
                }

// Emit content in body

                if ("content".equals(key)) {
                    if (value instanceof JSONArray) {
                        ja = (JSONArray)value;
                        length = ja.length();
                        for (i = 0; i < length; i += 1) {
                            if (i > 0) {
                                sb.append('\n');
                            }
                            sb.append(escape(ja.get(i).toString()));
                        }
                    } else {
                        sb.append(escape(value.toString()));
                    }

// Emit an array of similar keys

                } else if (value instanceof JSONArray) {
                    ja = (JSONArray)value;
                    length = ja.length();
                    for (i = 0; i < length; i += 1) {
                        value = ja.get(i);
                        if (value instanceof JSONArray) {
                            sb.append('<');
                            sb.append(key);
                            sb.append('>');
                            sb.append(toString(value));
                            sb.append("</");
                            sb.append(key);
                            sb.append('>');
                        } else {
                            sb.append(toString(value, key));
                        }
                    }
                } else if ("".equals(value)) {
                    sb.append('<');
                    sb.append(key);
                    sb.append("/>");

// Emit a new tag <k>

                } else {
                    sb.append(toString(value, key));
                }
            }
            if (tagName != null) {

// Emit the </tagname> close tag

                sb.append("</");
                sb.append(tagName);
                sb.append('>');
            }
            return sb.toString();

// XML does not have good support for arrays. If an array appears in a place
// where XML is lacking, synthesize an <array> element.

        } else {
            if (object.getClass().isArray()) {
                object = new JSONArray(object);
            }
            if (object instanceof JSONArray) {
                ja = (JSONArray)object;
                length = ja.length();
                for (i = 0; i < length; i += 1) {
                    sb.append(toString(ja.opt(i), tagName == null ? "array" : tagName));
                }
                return sb.toString();
            } else {
                string = (object == null) ? "null" : escape(object.toString());
                return (tagName == null) ? "\"" + string + "\"" :
                    (string.length() == 0) ? "<" + tagName + "/>" :
                    "<" + tagName + ">" + string + "</" + tagName + ">";
            }
        }
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/json/XMLTokener.java
================================================
package com.ejie.x38.json;

/*
Copyright (c) 2002 JSON.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

The Software shall be used for Good, not Evil.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

/**
 * The XMLTokener extends the JSONTokener to provide additional methods
 * for the parsing of XML texts.
 * @author JSON.org
 * @version 2010-12-24
 */
@SuppressWarnings({ "rawtypes", "unchecked" })
public class XMLTokener extends JSONTokener {


   /** The table of entity values. It initially contains Character values for
    * amp, apos, gt, lt, quot.
    */
public static final java.util.HashMap entity;

   static {
       entity = new java.util.HashMap(8);
       entity.put("amp",  XML.AMP);
       entity.put("apos", XML.APOS);
       entity.put("gt",   XML.GT);
       entity.put("lt",   XML.LT);
       entity.put("quot", XML.QUOT);
   }

    /**
     * Construct an XMLTokener from a string.
     * @param s A source string.
     */
    public XMLTokener(String s) {
        super(s);
    }

    /**
     * Get the text in the CDATA block.
     * @return The string up to the <code>]]&gt;</code>.
     * @throws JSONException If the <code>]]&gt;</code> is not found.
     */
    public String nextCDATA() throws JSONException {
        char         c;
        int          i;
        StringBuffer sb = new StringBuffer();
        for (;;) {
            c = next();
            if (end()) {
                throw syntaxError("Unclosed CDATA");
            }
            sb.append(c);
            i = sb.length() - 3;
            if (i >= 0 && sb.charAt(i) == ']' &&
                          sb.charAt(i + 1) == ']' && sb.charAt(i + 2) == '>') {
                sb.setLength(i);
                return sb.toString();
            }
        }
    }


    /**
     * Get the next XML outer token, trimming whitespace. There are two kinds
     * of tokens: the '<' character which begins a markup tag, and the content
     * text between markup tags.
     *
     * @return  A string, or a '<' Character, or null if there is no more
     * source text.
     * @throws JSONException
     */
    public Object nextContent() throws JSONException {
        char         c;
        StringBuffer sb;
        do {
            c = next();
        } while (Character.isWhitespace(c));
        if (c == 0) {
            return null;
        }
        if (c == '<') {
            return XML.LT;
        }
        sb = new StringBuffer();
        for (;;) {
            if (c == '<' || c == 0) {
                back();
                return sb.toString().trim();
            }
            if (c == '&') {
                sb.append(nextEntity(c));
            } else {
                sb.append(c);
            }
            c = next();
        }
    }


    /**
     * Return the next entity. These entities are translated to Characters:
     *     <code>&amp;  &apos;  &gt;  &lt;  &quot;</code>.
     * @param ampersand An ampersand character.
     * @return  A Character or an entity String if the entity is not recognized.
     * @throws JSONException If missing ';' in XML entity.
     */
    public Object nextEntity(char ampersand) throws JSONException {
        StringBuffer sb = new StringBuffer();
        for (;;) {
            char c = next();
            if (Character.isLetterOrDigit(c) || c == '#') {
                sb.append(Character.toLowerCase(c));
            } else if (c == ';') {
                break;
            } else {
                throw syntaxError("Missing ';' in XML entity: &" + sb);
            }
        }
        String string = sb.toString();
        Object object = entity.get(string);
        return object != null ? object : ampersand + string + ";";
    }


    /**
     * Returns the next XML meta token. This is used for skipping over <!...>
     * and <?...?> structures.
     * @return Syntax characters (<code>< > / = ! ?</code>) are returned as
     *  Character, and strings and names are returned as Boolean. We don't care
     *  what the values actually are.
     * @throws JSONException If a string is not properly closed or if the XML
     *  is badly structured.
     */
    public Object nextMeta() throws JSONException {
        char c;
        char q;
        do {
            c = next();
        } while (Character.isWhitespace(c));
        switch (c) {
        case 0:
            throw syntaxError("Misshaped meta tag");
        case '<':
            return XML.LT;
        case '>':
            return XML.GT;
        case '/':
            return XML.SLASH;
        case '=':
            return XML.EQ;
        case '!':
            return XML.BANG;
        case '?':
            return XML.QUEST;
        case '"':
        case '\'':
            q = c;
            for (;;) {
                c = next();
                if (c == 0) {
                    throw syntaxError("Unterminated string");
                }
                if (c == q) {
                    return Boolean.TRUE;
                }
            }
        default:
            for (;;) {
                c = next();
                if (Character.isWhitespace(c)) {
                    return Boolean.TRUE;
                }
                switch (c) {
                case 0:
                case '<':
                case '>':
                case '/':
                case '=':
                case '!':
                case '?':
                case '"':
                case '\'':
                    back();
                    return Boolean.TRUE;
                }
            }
        }
    }


    /**
     * Get the next XML Token. These tokens are found inside of angle
     * brackets. It may be one of these characters: <code>/ > = ! ?</code> or it
     * may be a string wrapped in single quotes or double quotes, or it may be a
     * name.
     * @return a String or a Character.
     * @throws JSONException If the XML is not well formed.
     */
    public Object nextToken() throws JSONException {
        char c;
        char q;
        StringBuffer sb;
        do {
            c = next();
        } while (Character.isWhitespace(c));
        switch (c) {
        case 0:
            throw syntaxError("Misshaped element");
        case '<':
            throw syntaxError("Misplaced '<'");
        case '>':
            return XML.GT;
        case '/':
            return XML.SLASH;
        case '=':
            return XML.EQ;
        case '!':
            return XML.BANG;
        case '?':
            return XML.QUEST;

// Quoted string

        case '"':
        case '\'':
            q = c;
            sb = new StringBuffer();
            for (;;) {
                c = next();
                if (c == 0) {
                    throw syntaxError("Unterminated string");
                }
                if (c == q) {
                    return sb.toString();
                }
                if (c == '&') {
                    sb.append(nextEntity(c));
                } else {
                    sb.append(c);
                }
            }
        default:

// Name

            sb = new StringBuffer();
            for (;;) {
                sb.append(c);
                c = next();
                if (Character.isWhitespace(c)) {
                    return sb.toString();
                }
                switch (c) {
                case 0:
                    return sb.toString();
                case '>':
                case '/':
                case '=':
                case '!':
                case '?':
                case '[':
                case ']':
                    back();
                    return sb.toString();
                case '<':
                case '"':
                case '\'':
                    throw syntaxError("Bad character in a name");
                }
            }
        }
    }
    
    
    /**
     * Skip characters until past the requested string.
     * If it is not found, we are left at the end of the source with a result of false.
     * @param to A string to skip past.
     * @throws JSONException
     */
    public boolean skipPast(String to) throws JSONException {
        boolean b;
        char c;
        int i;
        int j;
        int offset = 0;
        int length = to.length();
        char[] circle = new char[length];
        
        /*
         * First fill the circle buffer with as many characters as are in the
         * to string. If we reach an early end, bail.
         */
        
        for (i = 0; i < length; i += 1) {
            c = next();
            if (c == 0) {
                return false;
            }
            circle[i] = c;
        }
        /*
         * We will loop, possibly for all of the remaining characters.
         */
        for (;;) {
            j = offset;
            b = true;
            /*
             * Compare the circle buffer with the to string. 
             */
            for (i = 0; i < length; i += 1) {
                if (circle[j] != to.charAt(i)) {
                    b = false;
                    break;
                }
                j += 1;
                if (j >= length) {
                    j -= length;
                }
            }
            /*
             * If we exit the loop with b intact, then victory is ours.
             */
            if (b) {
                return true;
            }
            /*
             * Get the next character. If there isn't one, then defeat is ours.
             */
            c = next();
            if (c == 0) {
                return false;
            }
            /*
             * Shove the character in the circle buffer and advance the 
             * circle offset. The offset is mod n.
             */
            circle[offset] = c;
            offset += 1;
            if (offset >= length) {
                offset -= length;
            }
        }
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/DaoLoggingAdviceImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.Hashtable;

import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.ext.XLogger.Level;

import com.ejie.x38.util.TableManager;

/**
 * 
 * @author UDA
 *
 */
public class DaoLoggingAdviceImpl extends LoggingAdviceImpl {
	
	private static Logger logger =  LoggerFactory.getLogger(DaoLoggingAdviceImpl.class);

	@Override
	public void preLogging(ProceedingJoinPoint call) throws Throwable {
		Hashtable<String, String> table = TableManager.initTable();
		table.put(LogConstants.CRITICALITY, Level.INFO.toString());
		table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.DATASUBSYSTEM);
		preComponentLogCall(call, table, logger);		
	}

	@Override
	public void postLogging(ProceedingJoinPoint call, Object ret) throws Throwable {
		Hashtable<String, String> table = TableManager.initTable();
		table.put(LogConstants.CRITICALITY, Level.INFO.toString());
		table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.DATASUBSYSTEM);
		postComponentLogCall(call, ret, table, logger);
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/FilterLoggingAdviceImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.Hashtable;

import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.ext.XLogger.Level;

import com.ejie.x38.util.TableManager;

/**
 * 
 * @author UDA
 *
 */
public class FilterLoggingAdviceImpl extends LoggingAdviceImpl {
	
	private static Logger logger =  LoggerFactory.getLogger(FilterLoggingAdviceImpl.class);
	
	@Override
	public void preLogging(ProceedingJoinPoint call) throws Throwable {
		Hashtable<String, String> table = TableManager.initTable();
		table.put(LogConstants.CRITICALITY, Level.DEBUG.toString());
		table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.WEBSUBSYSTEM);
		preComponentLogCall(call, table, logger);		
	}

	@Override
	public void postLogging(ProceedingJoinPoint call, Object ret) throws Throwable {
		Hashtable<String, String> table = TableManager.initTable();
		table.put(LogConstants.CRITICALITY, Level.DEBUG.toString());
		table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.WEBSUBSYSTEM);
		postComponentLogCall(call, ret, table, logger);
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/IncidenceLoggingAdvice.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

/**
 * 
 * @author UDA
 *
 */
public interface IncidenceLoggingAdvice {

	public void logIncidence(Object target, Exception exception);
	
	public LoggingManager getLoggingManager();
	
	public void setLoggingManager(LoggingManager loggingManager);
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/IncidenceLoggingAdviceImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.Hashtable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.ext.XLogger.Level;

import com.ejie.x38.util.StackTraceManager;
import com.ejie.x38.util.TableManager;

/**
 * 
 * @author UDA
 *
 */
public class IncidenceLoggingAdviceImpl implements IncidenceLoggingAdvice{

	private static final Logger logger =  LoggerFactory.getLogger(IncidenceLoggingAdviceImpl.class);
	
	private LoggingManager loggingManager;
	
	public void logIncidence (Object target, Exception exception){
		Hashtable<String, String> table = TableManager.initTable();
		table.put(LogConstants.CRITICALITY, Level.ERROR.toString());
		table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.INCIDENCESUBSYSTEM);
		table.put(LogConstants.ADITIONALINFO, StackTraceManager.getStackTrace(exception));
		table.put(LogConstants.MESSAGE, exception.getMessage() == null ? "" : exception.getMessage());
		loggingManager.logIncidences(target.getClass().getName(), logger, table);
	}

	//Getters & Setters
	public LoggingManager getLoggingManager() {
		return loggingManager;
	}

	public void setLoggingManager(LoggingManager loggingManager) {
		this.loggingManager = loggingManager;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LogConstants.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

//##|Fecha y hora         ~~ Sesion XLNetS ~~ IP           ~~ Usuario ~~ Puesto  ~~ Codigo de aplicacion ~~ Instancia Weblogic       ~~ Subsistema funcional    ~~ Criticidad ~~ Mensaje                     ~~ Información adicional |##
//##|2010/06/22 09:21:52  ~~ 1268767190369 ~~ 10.170.9.246 ~~ SOPDESA ~~ SOPDESA ~~ s73b                 ~~ intra_apps_dpto2_apps112 ~~ Subsistema Presentacion ~~ DEBUG      ~~ Mensaje de traza de ejemplo ~~ xxx                   |##

/**
 * 
 * @author UDA
 *
 */
public class LogConstants {

	protected static final String INITSEPARATOR = "##| ";
	protected static final String ENDSEPARATOR = " |##";
	protected static final String FIELDSEPARATOR = " ~~ ";
	protected static final String EMPTYFIELD = " ";
	
	protected static final String DATETIME = "datetime";
	protected static final String IPADDRESS = "ipAddress";
	protected static final String APPCODE = "appCode";
	protected static final String SERVERINSTANCE = "serverInstance";
	protected static final String FUNCTIONALSUBSYSTEM = "functionalSubsystem";
	protected static final String INTERFUNCTIONALSUBSYSTEM = "interFunctionalSubsystem";
	protected static final String LOGGERCLASS = "loggerClass";
	protected static final String THREAD = "thread";
	protected static final String CRITICALITY = "criticality";
	protected static final String MESSAGE = "message";
	protected static final String ADITIONALINFO = "aditionalInfo";
	protected static final String INTERADITIONALINFO = "interAditionalInfo";
	
	public static final String NOINTERNALACCES = "noInternalAcces";
	public static final String ACCESSTYPEHTTP = "httpAcces";
	public static final String ACCESSTYPEEJB = "ejbAcces";
	
	public static final String USER = "user";
	public static final String POSITION = "position";
	public static final String SESSION = "session";
	public static final String[] parameters = {DATETIME,SESSION,IPADDRESS,USER,POSITION,APPCODE,SERVERINSTANCE,FUNCTIONALSUBSYSTEM,THREAD,LOGGERCLASS,CRITICALITY,MESSAGE,ADITIONALINFO};
	
	public static final String DATETIMEFORMAT = "yyyy/MM/dd HH:mm:ss:SSS";
	
	protected static final String DATASUBSYSTEM = "Data Subsystem";
	protected static final String LOGICSUBSYSTEM = "Logic Subsystem";
	protected static final String WEBSUBSYSTEM = "Web Subsystem";
	protected static final String INCIDENCESUBSYSTEM = "Incidence Subsystem";
	protected static final String TRACESUBSYSTEM = "Trace Subsystem";
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LogLayout.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.HashMap;
import java.util.Hashtable;

import org.slf4j.MDC;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.classic.spi.ThrowableProxy;
import ch.qos.logback.core.LayoutBase;
import ch.qos.logback.core.LogbackException;

import com.ejie.x38.log.security.CurrentUserManager;
import com.ejie.x38.security.Credentials;
import com.ejie.x38.util.DateTimeManager;
import com.ejie.x38.util.StackTraceManager;
import com.ejie.x38.util.TableManager;
import com.ejie.x38.util.ThreadStorageManager;

/**
 * 
 * @author UDA
 *
 */
public class LogLayout extends LayoutBase<ILoggingEvent>{

	private String appCode = null;
	private String instance = null;
	
	public void setAppCode(String appCode) {
	    this.appCode = appCode;
	  }

	public void setInstance(String instance) {
	    this.instance = instance;
	  }
	
	@SuppressWarnings("unchecked")
	public String doLayout(ILoggingEvent event) throws LogbackException{
		Credentials Credentials = null;
		Hashtable<String, String> table;
		Object[] argArray = event.getArgumentArray();
		HashMap<String, String> argUdaObjec = new HashMap<String, String>();
		
		try{
			
			//Get internal log info
			if(event !=null && event.getArgumentArray() != null && event.getArgumentArray().length>0){
				argArray = event.getArgumentArray();
				if (argArray[0].getClass() == java.util.HashMap.class ){
					argUdaObjec = (HashMap<String, String>) argArray[0];
				}
			}
			
			//Initializing data container table
			table = TableManager.initTable();
			
			//General data collection (data not dependent)
			table.put(LogConstants.DATETIME, DateTimeManager.getDateTime());
			table.put(LogConstants.APPCODE, appCode!=null ? appCode:"");
			table.put(LogConstants.THREAD, ThreadStorageManager.getCurrentThreadId()+"");
			table.put(LogConstants.LOGGERCLASS, event.getLoggerName());
			table.put(LogConstants.SERVERINSTANCE, instance!=null ? instance:"");
			table.put(LogConstants.CRITICALITY, event.getLevel()!=null ? event.getLevel()+"":"");
			table.put(LogConstants.MESSAGE, event.getFormattedMessage()!=null ? event.getFormattedMessage()+"":"");
			
			//Assigning info of subsystema functional
			if(argUdaObjec.get(LogConstants.INTERFUNCTIONALSUBSYSTEM) == null){
				if (MDC.get(LogConstants.FUNCTIONALSUBSYSTEM) == null){
					if(event.getLoggerName().startsWith("com.ejie.") && event.getLoggerName().contains(".service.")){
						table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.LOGICSUBSYSTEM);
					} else if(event.getLoggerName().startsWith("com.ejie.") && event.getLoggerName().contains(".control.")){
						table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.WEBSUBSYSTEM);
					} else if(event.getLoggerName().startsWith("com.ejie.") && event.getLoggerName().contains(".dao.")){
						table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.DATASUBSYSTEM);
					} else {
						table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.TRACESUBSYSTEM);
					}
				} else {
					table.put(LogConstants.FUNCTIONALSUBSYSTEM, MDC.get(LogConstants.FUNCTIONALSUBSYSTEM));
				}
			} else {
				table.put(LogConstants.FUNCTIONALSUBSYSTEM, argUdaObjec.get(LogConstants.INTERFUNCTIONALSUBSYSTEM));
			}
			
			//Http access-dependent data
			if((MDC.get(LogConstants.NOINTERNALACCES) != null)&&((MDC.get(LogConstants.NOINTERNALACCES).equals(LogConstants.ACCESSTYPEHTTP))||(MDC.get(LogConstants.NOINTERNALACCES).equals(LogConstants.ACCESSTYPEEJB)))){
					
				if(MDC.get(LogConstants.USER) != null) {
					table.put(LogConstants.USER, MDC.get(LogConstants.USER));
					table.put(LogConstants.SESSION, MDC.get(LogConstants.SESSION));
					table.put(LogConstants.POSITION, MDC.get(LogConstants.POSITION));
				} else {
					//Get the data of the user credentials.
					try{
						final SecurityContext securityContext = SecurityContextHolder.getContext();
						if (securityContext != null) {
							final Authentication authentication = securityContext.getAuthentication();
							if (authentication != null) {
								Credentials = (Credentials) authentication.getCredentials();
							}
						}
					} catch(Exception e) {
						if (!(e instanceof java.lang.NullPointerException)){
							throw new LogbackException("System error logs. Error accessing the security context.",e);
						}
					}
					
					if (Credentials != null){
						//system log of the application with security context
						table.put(LogConstants.USER, CurrentUserManager.getCurrentUsername());
						table.put(LogConstants.SESSION, CurrentUserManager.getCurrentUserN38UidSesion(Credentials));
						table.put(LogConstants.POSITION, CurrentUserManager.getPosition(Credentials));
						
					} else {
						//System log of the application without security context
						table.put(LogConstants.USER, "N/A");
						table.put(LogConstants.SESSION, "N/A");
						table.put(LogConstants.POSITION, "N/A");
					}
				}
				
				//IpAddres
				table.put(LogConstants.IPADDRESS, MDC.get("IPClient"));
			}
			
			//Additional info
			if (argUdaObjec.get(LogConstants.INTERADITIONALINFO) == null){
				if (MDC.get(LogConstants.ADITIONALINFO) != null){
					table.put(LogConstants.ADITIONALINFO,MDC.get(LogConstants.ADITIONALINFO));
				} else {
					if (event.getThrowableProxy() != null) {
						ThrowableProxy throwableProxy = (ThrowableProxy) event.getThrowableProxy();
						table.put(LogConstants.ADITIONALINFO,StackTraceManager.getStackTrace(throwableProxy.getThrowable()));
					} else if (argArray != null && argArray.length>0 && argArray[0].getClass() == String.class){
						table.put(LogConstants.ADITIONALINFO, (String)argArray[0]);
					}
				}
			} else {
				table.put(LogConstants.ADITIONALINFO,argUdaObjec.get(LogConstants.INTERADITIONALINFO));
			}
			
			//Generates the output message
			StringBuffer sbuf = new StringBuffer(1023);
			sbuf.append(LogConstants.INITSEPARATOR);
			int i = 0;
			for(String param:LogConstants.parameters){
				sbuf.append(table.get(param)!=null?table.get(param):"");
				if (++i<LogConstants.parameters.length){
					sbuf.append(LogConstants.FIELDSEPARATOR);
				}
			}
			sbuf.append(LogConstants.ENDSEPARATOR);
			sbuf.append("\r\n");
			return sbuf.toString();
				
		} catch (LogbackException lbe){
			throw lbe;
		} catch (Exception e) {
			throw new LogbackException("System error logs. Error creating the log trace.",e);
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LogbackConfigurer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.io.File;
import java.io.FileNotFoundException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.ResourceUtils;
import org.springframework.util.SystemPropertyUtils;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.joran.JoranConfigurator;
import ch.qos.logback.core.joran.spi.JoranException;

/**
 * 
 * Class responsible for setting logback. Perform the following actions:
 * 1- Is responsible for collecting the settings for logback and applied to the system's log
 *  
 * @author UDA
 * 
 */
public abstract class LogbackConfigurer
{
	public static final String CLASSPATH_URL_PREFIX = "classpath:";
	public static final String XML_FILE_EXTENSION = ".xml";
	final static Logger logger = LoggerFactory.getLogger(LogbackConfigurer.class);

	public static void initLogging(String location, boolean printState) throws FileNotFoundException {
    
		logger.info("Begins the initialization of system logs");
		String resolvedLocation = null;
		File file = null;
		StringBuilder compositeLocator = new StringBuilder(CLASSPATH_URL_PREFIX);
		compositeLocator.append(location);
		
		//Validates that the URL is an XML file
		if(location.contains(XML_FILE_EXTENSION)){
			
			//Is collected, as may be absolute or relative to classpath, and validates the correctness of the URL of the configuration file.
			try {
				resolvedLocation = SystemPropertyUtils.resolvePlaceholders(compositeLocator.toString());
								
				file = ResourceUtils.getFile(resolvedLocation);
				
				logger.info("Read file => "+file.toString());
				
			} catch (FileNotFoundException fileNotFoundException) {	
					try{
						resolvedLocation = SystemPropertyUtils.resolvePlaceholders(location);
												
						file = ResourceUtils.getFile(resolvedLocation);
						
						logger.info("Read file => "+file.toString());
						
					} catch (FileNotFoundException fileNotFoundExceptionAbsolut) {
						logger.error("There has been an error of incorrect path. The route is not included in the application classpath or an absolute path is correct.", fileNotFoundExceptionAbsolut);
					}
			}	    
		    
			LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
		    
		    try {
		      JoranConfigurator configurator = new JoranConfigurator();
		      configurator.setContext(lc);
		      
		      //The context was probably already configured by default configuration rules
		      lc.reset(); 
		      
		      //Applies the new configuration
		      configurator.doConfigure(file);
		      
		    } catch (JoranException je) {		    	
		    	FileNotFoundException fnfe = new FileNotFoundException("There was an error initializing the system logs (logback). The specified file is incorrect or corrupt. "+ je.getMessage()); 
		    	throw(fnfe);
		    }
		    
		    if (printState){
		    	lc.getStatusManager();
		    }
		    
		} else {
			//Not being a path to an xml file an exception is raised and does not load  
			FileNotFoundException exc = new FileNotFoundException("The file specified for logback settings should be an xml file.");
			logger.error("There has been an error of incorrect path. The route is not included in the application classpath or an absolute path is correct.", exc);
			throw exc;
		}
		
		file = null;
		
		logger.info("Ends the initialization of system logs");
  }
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LoggingAdvice.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.Hashtable;

import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;

/**
 * 
 * @author UDA
 *
 */
public interface LoggingAdvice {

	public abstract void preLogging (ProceedingJoinPoint call) throws Throwable;
	
	public abstract void postLogging (ProceedingJoinPoint call, Object ret) throws Throwable;
	
	public void preComponentLogCall(ProceedingJoinPoint call, Hashtable<String, String> table, Logger logger) throws Throwable;

	public void postComponentLogCall(ProceedingJoinPoint call, Object ret, Hashtable<String, String> table, Logger logger) throws Throwable;
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LoggingAdviceImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.Arrays;
import java.util.Hashtable;

import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;

/**
 * 
 * @author UDA
 *
 */
public abstract class LoggingAdviceImpl implements LoggingAdvice{

	private LoggingManager loggingManager;
	
	public abstract void preLogging (ProceedingJoinPoint call) throws Throwable;
	public abstract void postLogging (ProceedingJoinPoint call, Object ret) throws Throwable;
	
	@Override
	public void preComponentLogCall(ProceedingJoinPoint call, Hashtable<String, String> table, Logger logger) throws Throwable {			
		StringBuilder message = new StringBuilder(call.getTarget().getClass().getSimpleName());
		message.append(call.toShortString());
		String aditionalInfo = Arrays.toString(call.getArgs());
		
		table.put(LogConstants.MESSAGE, message.toString());
		table.put(LogConstants.ADITIONALINFO, aditionalInfo);		
		loggingManager.autoLog(table, this.getClass().getName(), logger);
	}

	@Override
	public void postComponentLogCall(ProceedingJoinPoint call, Object ret, Hashtable<String, String> table, Logger logger) throws Throwable {	
		StringBuilder message = new StringBuilder(call.getTarget().getClass().getSimpleName());
		String aditionalInfo = "";
		
		message.append(call.toShortString());
		message.append(" - finished");
		
		if (logger.isTraceEnabled() && ret != null){
			aditionalInfo = ret+"";
		}
		
		table.put(LogConstants.ADITIONALINFO, aditionalInfo);			
		table.put(LogConstants.MESSAGE, message.toString());
		
		loggingManager.autoLog(table, this.getClass().getName(), logger);
	}
	
	//Getters & Setters
	public LoggingManager getLoggingManager() {
		return loggingManager;
	}

	public void setLoggingManager(LoggingManager loggingManager) {
		this.loggingManager = loggingManager;
	}	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LoggingEditor.java
================================================
package com.ejie.x38.log;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.text.Normalizer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import com.ejie.x38.dto.TableRequestDto;
import com.ejie.x38.dto.TableResponseDto;
import com.ejie.x38.dto.TableRowDto;
import com.ejie.x38.generic.model.SelectGeneric;
import com.ejie.x38.log.model.LogModel;

import ch.qos.logback.classic.LoggerContext;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.Appender;

/**
 * Gestion del cambio de logs en runtime.
 *
 * @author Urko Guinea
 * 
 */
@Service(value = "LoggingEditor")
public class LoggingEditor {
	private static final String LOGBACK_CLASSIC = "ch.qos.logback.classic";
    private static final String LOGBACK_CLASSIC_LOGGER = "ch.qos.logback.classic.Logger";
	private static final String LOGBACK_CLASSIC_LEVEL = "ch.qos.logback.classic.Level";
	private static final Logger logger = LoggerFactory.getLogger(LoggingEditor.class);
	private static List<TableRowDto<LogModel>> listReorderSelection = new ArrayList<TableRowDto<LogModel>>();
	private static LogModel lastFilterLogModel = new LogModel();
	private static int lastRowsNumber = 10;
	private static int lastPageNumber = 0;

	/**
	 * Cambio en runtime del nivel de logger.
	 *
	 * @param loggerName Nombre del logger a cambiar su nivel. Si blank, se usara el root logger.
	 * @param logLevel Uno de los niveles de logs soportado: TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF. {@code null}  se considera 'OFF'.
	 * 
	 * @return boolean
	 */
	public static boolean setLogLevel(String loggerName, String logLevel) {
		String logLevelUpper = (logLevel == null) ? "OFF" : logLevel.toUpperCase();
	
		try {
			Package logbackPackage = Package.getPackage(LOGBACK_CLASSIC);
			if (logbackPackage == null)
			{
				logger.info("Logback no esta en el classpath!");
				return false;
			}

			// usa el root logger en caso de que llegue vacio
			if ((loggerName == null) || loggerName.trim().isEmpty())
			{
				loggerName = (String) getFieldVaulue(LOGBACK_CLASSIC_LOGGER, "ROOT_LOGGER_NAME");
			}

			// Obtener el logger por su nombre
			Logger loggerObtained = LoggerFactory.getLogger(loggerName);
			if (loggerObtained == null)
			{
				// I don't know if this case occurs
				logger.warn("No existe un logger con tal nombre: {}", loggerName);
				return false;
			}

			Object logLevelObj = getFieldVaulue(LOGBACK_CLASSIC_LEVEL, logLevelUpper);
			if (logLevelObj == null)
			{
				logger.warn("No existe tal log level: {}", logLevelUpper);
				return false;
			}

			Class<?>[] paramTypes =  { logLevelObj.getClass() };
			Object[]   params     =  { logLevelObj };

			Class<?> clz    = Class.forName(LOGBACK_CLASSIC_LOGGER);
			Method   method = clz.getMethod("setLevel", paramTypes);
			method.invoke(loggerObtained, params);

			logger.debug("Log level cambiado a  {} para el logger '{}'", logLevelUpper, loggerName);
			
			return true;
		}
		catch (Exception e) {
			logger.warn("No se pudo asignar el log level a {} para el logger '{}'", logLevelUpper, loggerName);
			return false;
		}
	}
	
	/**
	 * Obtener un logger en concreto.
	 * 
	 * @param loggerName Nombre del log a obtener.
	 * 
	 * @return LogModel
	 */
	public static LogModel getLogger(final String loggerName) {
		final LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
		ch.qos.logback.classic.Logger aux;
		LogModel result = new LogModel();
		
		aux = lc.getLogger(loggerName);
		result.setLevelLog(aux.getEffectiveLevel().toString());
		result.setNameLog(aux.getName());
		
		return result;
	}
	
	/**
	 * Devuelve todos los loggers configurados.
	 * 
	 * @param showAll Devuelve todos los loggers, no solo los configurados.
	 * 
	 * @return List<LogModel>
	 */
	public static List<LogModel> getLoggers(final boolean showAll) {
		final LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();
		final List<LogModel> loggers = new ArrayList<LogModel>();
		LogModel aux;
		
		for (ch.qos.logback.classic.Logger log : lc.getLoggerList()) {
			if(!showAll) {
				if(log.getLevel() != null || hasAppenders(log)) {
					aux = new LogModel();
					aux.setLevelLog(log.getEffectiveLevel().toString());
					aux.setNameLog(log.getName());
					loggers.add(aux);
				}
			} else {
				aux = new LogModel();
				aux.setLevelLog(log.getEffectiveLevel().toString());
				aux.setNameLog(log.getName());
				loggers.add(aux);
			}
		}

		return loggers;
	}
	
	/** 
	 * Comprueba si el logger seleccionado tiene appender.
	 * 
	 * @param logger Logger a probar.
	 * 
	 * @return boolean True si el logger tiene appenders.
	 */
	public static boolean hasAppenders(Logger logger) {
		Iterator<Appender<ILoggingEvent>> it =((ch.qos.logback.classic.Logger) logger).iteratorForAppenders();
		return it.hasNext();
	}

	private static Object getFieldVaulue(String fullClassName, String fieldName) {
		try {
			Class<?> clazz = Class.forName(fullClassName);
			Field field = clazz.getField(fieldName);
			return field.get(null);
		}
		catch (Exception ex) {
			return null;
		}
	}
	
	/** 
	 * Devuelve los logs filtrados.
	 *
	 * @param filterLogModel Filtro a aplicar enviado por el cliente.
	 * @param tableRequestDto DTO que contiene los parámetros de configuración propios del RUP_TABLE a aplicar en el filtrado.
	 * 
	 * @return TableResponseDto<LogModel>
	 */
	public static TableResponseDto<LogModel> getLoggersFiltered(LogModel filterLogModel, TableRequestDto tableRequestDto) {
		TableResponseDto<LogModel> resultado = new TableResponseDto<LogModel>();
		List<LogModel> listalogs = getLoggers(true);
		List<LogModel> resulList = new ArrayList<LogModel>();
		LogModel model;
		
		// Paginación
		int startPosition = (int) (tableRequestDto.getRows() * (tableRequestDto.getPage() - 1));
		long iterations = (listalogs.size() - startPosition) > tableRequestDto.getRows() ? tableRequestDto.getRows() : listalogs.size() - startPosition;
		
		for (int i = startPosition; i < startPosition + iterations; i++) {	
			if (filterLogModel.getLevelLog() == null && filterLogModel.getNameLog() == null) {
				model = new LogModel();						
				model.setNameLog(listalogs.get(i).getNameLog());
				model.setLevelLog(listalogs.get(i).getLevelLog());
				resulList.add(model);
			} else if (filterLogModel.getLevelLog() != null && filterLogModel.getNameLog() == null) {
				if (filterLogModel.getLevelLog().equalsIgnoreCase(listalogs.get(i).getLevelLog())) {
					model = new LogModel();						
					model.setNameLog(listalogs.get(i).getNameLog());
					model.setLevelLog(listalogs.get(i).getLevelLog());
					resulList.add(model);
				}
			} else if (filterLogModel.getLevelLog() == null && filterLogModel.getNameLog() != null) {
				if (listalogs.get(i).getNameLog().toLowerCase().contains(filterLogModel.getNameLog().toLowerCase()) || listalogs.get(i).getNameLog().toLowerCase().contains(filterLogModel.getNameLog().toLowerCase())) {
					model = new LogModel();						
					model.setNameLog(listalogs.get(i).getNameLog());
					model.setLevelLog(listalogs.get(i).getLevelLog());
					resulList.add(model);
				}	
			} else if (filterLogModel.getLevelLog() != null && filterLogModel.getNameLog() != null) {
				if (listalogs.get(i).getNameLog().toLowerCase().contains(filterLogModel.getNameLog().toLowerCase()) && filterLogModel.getLevelLog().equalsIgnoreCase(listalogs.get(i).getLevelLog())) {
					model = new LogModel();						
					model.setNameLog(listalogs.get(i).getNameLog());
					model.setLevelLog(listalogs.get(i).getLevelLog());
					resulList.add(model);
				}
			}
		}
		
		// NOTA: las siguientes gestiones son experimentales y podrían no funcionar perfectamente
		// Cuando el filtro actual es diferente al nuevo, se deseleccionan todos los registros seleccionados. En realidad, existe la posibilidad de mantenerlos, pero habría que hacer muchas comparaciones y sería costoso en cuanto a memoria se refiere.
		if (filterLogModel.compare(lastFilterLogModel)) {
			// Añadir seleccionado o seleccionados (dependiendo de si es selección simple o múltiple)
			List<String> selectedIds = tableRequestDto.getMultiselection().getSelectedIds();
			if (selectedIds != null) {
				// Al cambiar el número de filas por página, hay que actualizar la ubicaci�n de los registros seleccionados
				if (lastRowsNumber != tableRequestDto.getRows()) {
					for (TableRowDto<LogModel> selectedItem : listReorderSelection) {
						// Comprueba si el registro está en la página actual para poder obtener la ubicación de una manera más sencilla
						boolean inTheSamePage = false;
						int rowIndex = 0;
						for (LogModel log : resulList) {
							if (log.getNameLog().equals(selectedItem.getModel().getNameLog())) {
								selectedItem.setPage(tableRequestDto.getPage().intValue());
								selectedItem.setPageLine(rowIndex);
								selectedItem.setTableLine(rowIndex);
								
								inTheSamePage = true;
								break;
							}
							rowIndex++;
						}
						
						// En caso de no estar el registro en la página actual, se calcula su posición
						if (!inTheSamePage) {
							int newPageNumber = (int) ((selectedItem.getPage() * lastRowsNumber) / tableRequestDto.getRows());
							int newPageLineNumber = 0;
							
							// Gestiona los cambios ascendentes o descendentes de la cantidad de registros a mostrar por página
							if (lastRowsNumber < tableRequestDto.getRows()) {
								newPageLineNumber = (int) ((((selectedItem.getPage() - 1) * lastRowsNumber) + selectedItem.getPageLine()) - (newPageNumber * tableRequestDto.getRows()));
								
								if (newPageLineNumber > tableRequestDto.getRows()) {
									newPageLineNumber = (int) (newPageLineNumber - tableRequestDto.getRows());
								} else if (newPageLineNumber < 0) {
									newPageLineNumber = (int) (newPageLineNumber + tableRequestDto.getRows());
								} else {
									newPageNumber = newPageNumber + 1;
								}
							} else {
								newPageLineNumber = (int) (((selectedItem.getPage() * lastRowsNumber) + selectedItem.getPageLine()) - (newPageNumber * tableRequestDto.getRows()));
								
								if (newPageLineNumber > tableRequestDto.getRows()) {
									newPageLineNumber = (int) (newPageLineNumber - tableRequestDto.getRows());
								} else {
									newPageNumber = newPageNumber - 1;
								}
							}
							
							selectedItem.setPage((int) (newPageNumber <= 0 ? 1 : newPageNumber));
							selectedItem.setPageLine((int) (newPageLineNumber < 0 ? (newPageNumber * tableRequestDto.getRows()) + newPageLineNumber : newPageLineNumber));
							selectedItem.setTableLine((int) (newPageLineNumber < 0 ? (newPageNumber * tableRequestDto.getRows()) + newPageLineNumber : newPageLineNumber));
						}
					}
				}
				
				if (selectedIds.size() == 1) {
					// Selección o multiselección con un registro seleccionado
					String rowID = tableRequestDto.getMultiselection().getSelectedIds().get(0);
					
					if (listReorderSelection.size() > 0) {
						if (!rowID.equals(listReorderSelection.get(0).getModel().getNameLog())) {
							setSelectionReorder(listalogs, rowID, tableRequestDto);
						}
					} else {
						setSelectionReorder(listalogs, rowID, tableRequestDto);
					}
				} else {
					// Multiselección
					setMultiselectionReorder(listalogs, selectedIds, tableRequestDto);
				}
			} else {
				// Nada seleccionado
				listReorderSelection.clear();
			}
		} else {
			// Como el filtro ha cambiado, se deselecciona todo
			listReorderSelection.clear();
		}
		
		resultado.setReorderedSelection(listReorderSelection);
		resultado.addAdditionalParam("reorderedSelection", listReorderSelection);
		resultado.addAdditionalParam("selectedAll", tableRequestDto.getMultiselection().getSelectedAll());
		
		// Añadir información necesaria para la tabla
		resultado.setRows(resulList);
		resultado.setRecords(listalogs.size());
		resultado.setPage(tableRequestDto.getPage().toString());
		resultado.setTotal(Long.valueOf(listalogs.size()), Long.valueOf(tableRequestDto.getRows()));
		
		// Guardar número de filas por página, número de la página actual y filtrado para poder obtenerlo en el siguiente filtrado
		lastRowsNumber = tableRequestDto.getRows().intValue();
		lastPageNumber = tableRequestDto.getPage().intValue();
		lastFilterLogModel = filterLogModel;
		
		return resultado;
	}

	/** 
	 * Devuelve los nombres disponibles.
	 *
	 * @param q String enviado por el cliente para la bússqueda de resultados.
	 * 
	 * @return List<Resource<SelectGeneric>>
	 */
	public static List<SelectGeneric> getNames(String q) {		
		List<LogModel> listalogs = getLoggers(true);
		List<SelectGeneric> columnValues = new ArrayList<SelectGeneric>();
		
		if(q != null) {
			q = Normalizer.normalize(q, Normalizer.Form.NFD).replaceAll("[^\\p{ASCII}]", "");
		} else {
			q = "";
		}
		
		for (int i = 0; i < listalogs.size(); i++){	
			if (listalogs.get(i).getNameLog() != null) {
				String name = listalogs.get(i).getNameLog();
				name = Normalizer.normalize(name, Normalizer.Form.NFD).replaceAll("[^\\p{ASCII}]", "");
				
				if (q.equals("") || name.indexOf(q) >= 0) {
					columnValues.add(new SelectGeneric(name, name));
				}
			}
		}
		
		return columnValues;
	}

	/** 
	 * Devuelve los niveles disponibles.
	 *
	 * @return List<Resource<AutocompleteComboGenericPOJO>>
	 */
	public static List<SelectGeneric> getLevels() {		
		List<SelectGeneric> columnValues = new ArrayList<SelectGeneric>();
		columnValues.add(new SelectGeneric("TRACE", "TRACE"));
		columnValues.add(new SelectGeneric("DEBUG", "DEBUG"));
		columnValues.add(new SelectGeneric("INFO", "INFO"));
		columnValues.add(new SelectGeneric("WARN", "WARN"));
		columnValues.add(new SelectGeneric("ERROR", "ERROR"));
		
		return columnValues;
	}

	/** 
	 * Gestiona la selección cuando se pagina.
	 *
	 * @param listalogs Lista que contiene los logs.
	 * @param rowID Identificador del registro seleccionado.
	 * @param tableRequestDto DTO que contiene los parámetros de configuración propios del RUP_TABLE a aplicar en el filtrado.
	 */
	private static void setSelectionReorder(List<LogModel> listalogs, String rowID, TableRequestDto tableRequestDto) {
		Map<String, String> pkMap = new HashMap<String, String>();
		pkMap.put(tableRequestDto.getCore().getPkNames().get(0), rowID);
		
		TableRowDto<LogModel> reorderSelection = new TableRowDto<LogModel>();
		reorderSelection.setPage(lastPageNumber);
		reorderSelection.setModel(new LogModel(rowID, null));
		reorderSelection.setPkMap(pkMap);
		
		int index = 0;
		for (LogModel log : listalogs) {
			if (log.getNameLog().equals(rowID)) {
				reorderSelection.setPageLine((int) (index - ((lastPageNumber - 1) * tableRequestDto.getRows())));
				reorderSelection.setTableLine((int) (index - ((lastPageNumber - 1) * tableRequestDto.getRows())));
			}
			index++;
		}
		
		// Vaciar la lista que contiene el elemento anteriormente seleccionado
		listReorderSelection.clear();
		
		// Añadir redorderSelection a la lista
		listReorderSelection.add(reorderSelection);
	}

	/** 
	 * Gestiona la multiselección cuando se pagina.
	 *
	 * @param listalogs Lista que contiene los logs.
	 * @param rowID Identificadores de registros seleccionados.
	 * @param tableRequestDto DTO que contiene los parámetros de configuración propios del RUP_TABLE a aplicar en el filtrado.
	 */
	private static void setMultiselectionReorder(List<LogModel> listalogs, List<String> selectedIds, TableRequestDto tableRequestDto) {
		// Eliminar los elementos que hayan sido deseleccionados
		Iterator<TableRowDto<LogModel>> selectedItemIterator = listReorderSelection.iterator();
		while (selectedItemIterator.hasNext()) {
			TableRowDto<LogModel> item = selectedItemIterator.next();
			boolean alreadySelected = false;
			
			for (String rowID : selectedIds) {
				if (rowID.equals(item.getModel().getNameLog())) {
					alreadySelected = true;
					break;
				}
			}
			
			if (!alreadySelected) {
				selectedItemIterator.remove();
			}
		}
		
		for (String rowID : selectedIds) {
			boolean alreadySelected = false;
			
			for (TableRowDto<LogModel> selectedItem : listReorderSelection) {
				if (rowID.equals(selectedItem.getModel().getNameLog())) {
					alreadySelected = true;
					break;
				}
			}
			
			if (!alreadySelected) {
				Map<String, String> pkMap = new HashMap<String, String>();
				pkMap.put(tableRequestDto.getCore().getPkNames().get(0), rowID);
				
				TableRowDto<LogModel> reorderSelection = new TableRowDto<LogModel>();
				reorderSelection.setPage(lastPageNumber);
				reorderSelection.setModel(new LogModel(rowID, null));
				reorderSelection.setPkMap(pkMap);
				
				int logIndex = 0;
				for (LogModel log : listalogs) {
					if (log.getNameLog().equals(rowID)) {
						reorderSelection.setPageLine((int) (logIndex - ((lastPageNumber - 1) * tableRequestDto.getRows())));
						reorderSelection.setTableLine((int) (logIndex - ((lastPageNumber - 1) * tableRequestDto.getRows())));
					}
					logIndex++;
				}
				
				// Añadir redorderSelection a la lista
				listReorderSelection.add(reorderSelection);
			}
		}
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LoggingManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.Hashtable;

import org.slf4j.Logger;

/**
 * 
 * @author UDA
 *
 */
public interface LoggingManager {
	
	/**
	 * Log. Se utiliza automáticamente por el aspecto de log.
	 * 
	 * @param args Argumentos a Loguear.
	 * @throws Exception 
	 */
	public void autoLog(Hashtable<String, String> args, String fqnClassName, Logger logger);
	
	public void logIncidences(String fqnClassName, Logger logger, Hashtable<String, String> table);
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/LoggingManagerImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Hashtable;

import org.slf4j.Logger;

/**
 * 
 * @author UDA
 *
 */
public class LoggingManagerImpl implements LoggingManager{
	
	public void autoLog(Hashtable<String, String> table, String fqnClassName, Logger logger){
		
		HashMap<String, String> info = new HashMap<String, String>(2);
		
		info.put(LogConstants.INTERFUNCTIONALSUBSYSTEM, table.get(LogConstants.FUNCTIONALSUBSYSTEM));
		info.put(LogConstants.INTERADITIONALINFO, table.get(LogConstants.ADITIONALINFO));
		
		try {
			Class<?> logClass = logger.getClass();
	        Method meth = logClass.getMethod(table.get(LogConstants.CRITICALITY).toLowerCase(), String.class, Object.class);
	        meth.invoke(logger, table.get(LogConstants.MESSAGE), info);
	    } catch (Exception e) {
			//Problems with reflection method 'autoLog' 
			logger.error("Problems with reflection method 'autoLog'.", e);
		} 
	}
	
	public void logIncidences(String fqnClassName, Logger logger, Hashtable<String, String> table){
		
		HashMap<String, String> info = new HashMap<String, String>(2);
		
		info.put(LogConstants.INTERFUNCTIONALSUBSYSTEM, table.get(LogConstants.FUNCTIONALSUBSYSTEM));
		info.put(LogConstants.INTERADITIONALINFO, table.get(LogConstants.ADITIONALINFO));
		
		try {
			Class<?> logClass = logger.getClass();
	        Method meth = logClass.getMethod(table.get(LogConstants.CRITICALITY).toLowerCase(), String.class, Object.class);
	        meth.invoke(logger, table.get(LogConstants.MESSAGE), info);
	    }
		catch (Throwable e) {
			//Problems with reflection method logIncidences 
			logger.error("Problems with reflection method 'logIncidences'.", e);
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/SLF4JLogger.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import org.eclipse.persistence.logging.AbstractSessionLog;
import org.eclipse.persistence.logging.SessionLog;
import org.eclipse.persistence.logging.SessionLogEntry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 
 * EclipseLink Logger bridge to SLF4J.
 * 
 * Posibilita que EclipseLink se cominique con LogBack, ya que sino, solo funciona con commons-logging.
 * 
 * @author UDA
 */
public class SLF4JLogger extends AbstractSessionLog implements SessionLog {
	
	private static final String CATEGORY_DEFAULT = "org.eclipse.persistence";
	
	/**
	 * {@inheritDoc}
	 */
	@Override
	public void log(final SessionLogEntry logEntry) {
		if (logEntry != null) {
			final String logCategory = logEntry.getNameSpace() != null ?
					(CATEGORY_DEFAULT + "-" + logEntry.getNameSpace()) : CATEGORY_DEFAULT;
			final Logger logger = LoggerFactory.getLogger(logCategory);
			
			switch (logEntry.getLevel()) {
			case ALL:
			case FINEST:
				if (logger.isTraceEnabled()) {
					logger.trace("{}", formatMessage(logEntry));
				}
				break;
			case FINER:
			case FINE:
				if (logger.isDebugEnabled()) {
					logger.debug("{}", formatMessage(logEntry));
				}
				break;
			case CONFIG:
			case INFO:
				if (logger.isInfoEnabled()) {
					logger.info("{}", formatMessage(logEntry));
				}
				break;
			case WARNING:
				if (logger.isWarnEnabled()) {
					logger.warn("{}", formatMessage(logEntry));
				}
				break;
			case SEVERE:
				if (logger.isErrorEnabled()) {
					logger.error("{}", formatMessage(logEntry));
				}
				break;
			case OFF:
			default:
				break;
			}
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/ServiceLoggingAdviceImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.Hashtable;

import org.aspectj.lang.ProceedingJoinPoint;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.ext.XLogger.Level;

import com.ejie.x38.util.TableManager;

/**
 * 
 * @author UDA
 *
 */
public class ServiceLoggingAdviceImpl extends LoggingAdviceImpl {
	
	private static Logger logger =  LoggerFactory.getLogger(ServiceLoggingAdviceImpl.class);
	
	@Override
	public void preLogging(ProceedingJoinPoint call) throws Throwable {
		Hashtable<String, String> table = TableManager.initTable();
		table.put(LogConstants.CRITICALITY, Level.INFO.toString());
		table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.LOGICSUBSYSTEM);
		preComponentLogCall(call, table, logger);		
	}

	@Override
	public void postLogging(ProceedingJoinPoint call, Object ret) throws Throwable {
		Hashtable<String, String> table = TableManager.initTable();
		table.put(LogConstants.CRITICALITY, Level.INFO.toString());
		table.put(LogConstants.FUNCTIONALSUBSYSTEM, LogConstants.LOGICSUBSYSTEM);
		postComponentLogCall(call, ret, table, logger);
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/UdaLogFilter.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import ch.qos.logback.classic.Level;
import ch.qos.logback.classic.spi.ILoggingEvent;
import ch.qos.logback.core.filter.Filter;
import ch.qos.logback.core.spi.FilterReply;


/**
 *
 * Filter responsible for exclude logs messages in "Exception loggers" and in "Normal loggers"
 * 
 * @author UDA
 *  
 */
public class UdaLogFilter extends Filter<ILoggingEvent> {

	private boolean logIncidences = false;
	
	public void setLogIncidences(boolean logIncidences) {
	    this.logIncidences = logIncidences;
	}
	
	@Override
	public FilterReply decide(ILoggingEvent event) {
		
		//The log entry is accepted if has not error level or warning level and is not an incidences logger
		if (!logIncidences && (!(Level.ERROR.levelInt == event.getLevel().levelInt || Level.WARN.levelInt == event.getLevel().levelInt))){
			return FilterReply.ACCEPT;
		//Will also accept if has error level or warning level and is an incidences logger
		} else if (logIncidences && (Level.ERROR.levelInt == event.getLevel().levelInt || Level.WARN.levelInt == event.getLevel().levelInt)){
			return FilterReply.ACCEPT;
		//In other cases will be deny
		} else {
			return FilterReply.DENY;
		}
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/UdaLogStatusListener.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import ch.qos.logback.core.spi.ContextAwareBase;
import ch.qos.logback.core.spi.LifeCycle;
import ch.qos.logback.core.status.ErrorStatus;
import ch.qos.logback.core.status.Status;
import ch.qos.logback.core.status.StatusListener;
import ch.qos.logback.core.status.StatusManager;
import ch.qos.logback.core.util.StatusPrinter;

/**
 *
 * Lisen responsible for writing the state of logback in the output of logs
 * 
 * @author UDA
 *  
 */
public class UdaLogStatusListener extends ContextAwareBase implements StatusListener, LifeCycle {

	final static Logger logger = LoggerFactory.getLogger(UdaLogStatusListener.class);
	static final long DEFAULT_RESTROSPECTIVE = 300L;
	boolean isStarted = false;
	long retrospective = 300L;

	private void print(Status status) {
		StringBuilder sb = null;
		if (ErrorStatus.ERROR == status.getEffectiveLevel()){
			sb = new StringBuilder(status.toString());
			StatusPrinter.buildStr(sb, "", status);
			System.out.println(sb);
			sb = null;
//			logger.error(sb.toString(), status.getThrowable());
		}
//		else if (ErrorStatus.WARN == status.getEffectiveLevel()){
//			sb = new StringBuilder(status.toString());
//			logger.warn(sb.toString());
//		} else {
//			sb = new StringBuilder(status.toString());
//			logger.info(sb.toString());
//		}
	}

	public void addStatusEvent(Status status) {
		if (!this.isStarted)
			return;
		print(status);
	}

	private void retrospectivePrint()
	{
		long now = System.currentTimeMillis();
		StatusManager sm = this.context.getStatusManager();
		List<Status> statusList = sm.getCopyOfStatusList();
		for (Status status : statusList) {
			long timestamp = status.getDate().longValue();
			if (now - timestamp < this.retrospective)
				print(status);
		}
	}

	public void start()
	{
		this.isStarted = true;
		if (this.retrospective > 0L)
			retrospectivePrint();
	}

	public void setRetrospective(long retrospective)
	{
		this.retrospective = retrospective;
	}

	public long getRetrospective() {
		return this.retrospective;
	}

	public void stop() {
		this.isStarted = false;
	}

	public boolean isStarted() {
		return this.isStarted;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/model/LogModel.java
================================================
package com.ejie.x38.log.model;

import org.apache.commons.lang.ObjectUtils;

public class LogModel implements java.io.Serializable {
	private static final long serialVersionUID = 1L;
	
	private String nameLog; 
	private String levelLog;
	private String nameEscape;
	
	public LogModel() {
		super();
	}

	public LogModel(String nameLog) {
		super();
		this.nameLog = nameLog;
	}

	public LogModel(String nameLog, String levelLog) {
		super();
		this.nameLog = nameLog;
		this.levelLog = levelLog;
	}

	public LogModel(String nameLog, String levelLog, String nameEscape) {
		super();
		this.nameLog = nameLog;
		this.levelLog = levelLog;
		this.nameEscape = nameEscape;
	}
	
	public String getNameLog() {
		return nameLog;
	}

	public void setNameLog(String name) {
		this.nameLog = name;
	}

	public String getLevelLog() {
		return levelLog;
	}

	public void setLevelLog(String level) {
		this.levelLog = level;
	}

	public String getNameEscape() {
		return nameEscape;
	}

	public void setNameEscape(String nameEscape) {
		this.nameEscape = nameEscape;
	}
	
	public boolean compare(LogModel log2) {
		return (ObjectUtils.equals(this.nameLog, log2.getNameLog()) && ObjectUtils.equals(this.levelLog, log2.getLevelLog()) && ObjectUtils.equals(this.nameEscape, log2.getNameEscape()));
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/log/security/CurrentUserManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.log.security;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.context.SecurityContextHolder;

import com.ejie.x38.security.Credentials;
import com.ejie.x38.util.StackTraceManager;

/**
 *
 * Proporciona ciertos datos referentes a la seguridad y el entorno al sistema de Logging.
 * 
 * @author UDA
 * 
 */
public class CurrentUserManager{

	private static final long serialVersionUID = 1398165309740472090L;

	private static final Logger logger =  LoggerFactory.getLogger(CurrentUserManager.class);
	
	public static String getCurrentUserN38UidSesion(Credentials Credentials) {
		String uidSesion = " ";
		try{
			if (Credentials != null) {
				uidSesion = Credentials.getUidSession();				
			}
		}catch(Exception e){
			logger.error(StackTraceManager.getStackTrace(e));
		}
		return uidSesion;
	}

	public static String getCurrentUsername() {
		String userName = " ";
		try{
			if(SecurityContextHolder.getContext().getAuthentication()!=null){
				userName = SecurityContextHolder.getContext().getAuthentication().getName();
			}	
		}catch(Exception e){
			logger.error(StackTraceManager.getStackTrace(e));
		}
		return userName;
	}
	
	public static String getPosition(Credentials Credentials){
		if (Credentials!= null){
			return Credentials.getPosition();
		}else{
			return " ";
		}
	}	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/remote/RemoteEJBFactory.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.remote;

/**
 * 
 * @author UDA
 *
 */
public interface RemoteEJBFactory {

	public abstract Object lookup(String serverName, Class<?> remoteInterfaceClass) throws Exception;

	public abstract void clearInstance(Class<?> remoteInterfaceClass);

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/remote/RemoteEJBFactoryImpl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.remote;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.Map;
import java.util.Properties;

import javax.naming.Context;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import weblogic.jndi.Environment;

import com.ejie.x38.util.StackTraceManager;

/**
 * 
 * This class is used for caching references to remote EJBs' Contexts and Remote interfaces.
 * This classes is being mainly consumed by a 3.0 Stateless Enterprise Java Bean.
 * Because EJB apps tend to run multiple beans, and because JNDI lookups are often present in many 
 * components, much of an application's performance overhead can be spent on these lookups.
 * 
 * Here, the main purpose is to avoid those overheads by caching Object Instances.
 * 
 * @author UDA
 *
 */
public class RemoteEJBFactoryImpl implements RemoteEJBFactory {

	private static final Logger logger =  LoggerFactory.getLogger(RemoteEJBFactoryImpl.class);	
	private Map<Class<?>, Object> remoteInterfaces;
	private Properties appConfiguration;

    private RemoteEJBFactoryImpl() {
    	remoteInterfaces = new HashMap<Class<?>, Object>();
    }

    @Override
	public Object lookup(String serverName, Class<?> remoteInterfaceClass) throws Exception {
        // See if we already have this interface cached
    	String jndiName = appConfiguration.getProperty(serverName+"."+remoteInterfaceClass.getSimpleName()+".jndi");
    	logger.info("Looking Up EJB with JNDI Name: "+jndiName);
        Object remoteInterface = (Object)remoteInterfaces.get(remoteInterfaceClass);
        // If not, look up with the supplied JNDI name
        if (remoteInterface == null) {
        	remoteInterface = this.getInitialContext(serverName).lookup(jndiName);
            // If this is a new ref, save for caching purposes
            remoteInterfaces.put(remoteInterfaceClass, remoteInterface);
        }
        return remoteInterface;
    }
      
  	private Context getInitialContext(String serverName){
		String url = appConfiguration.getProperty(serverName+".url");
		String user = appConfiguration.getProperty(serverName+".user");
		String password = appConfiguration.getProperty(serverName+".password");
		Hashtable<String,String> ht = new Hashtable<String,String>();
		try {
			ht.put(Context.INITIAL_CONTEXT_FACTORY, "weblogic.jndi.WLInitialContextFactory");
			ht.put(Context.PROVIDER_URL,url);
			if (user != null) {
				ht.put(Context.SECURITY_PRINCIPAL, user);
				ht.put(Context.SECURITY_CREDENTIALS, password == null ? "" : password);
			}
			Environment env = new Environment();
			env.setDelegateEnvironment(ht);
			return env.getInitialContext();
		}catch(Exception e){
			logger.error("Failed to initialize InitialContext with error: "+StackTraceManager.getStackTrace(e));
			return null;
		}
	}

  	@Override
	public void clearInstance (Class<?> remoteInterfaceClass){
  		remoteInterfaces.remove(remoteInterfaceClass);
  	}

	public Properties getAppConfiguration() {
		return appConfiguration;
	}

	public void setAppConfiguration(Properties appConfiguration) {
		this.appConfiguration = appConfiguration;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/remote/TransactionMetadata.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.remote;

import java.io.Serializable;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import ch.qos.logback.core.LogbackException;

import com.ejie.x38.log.LogConstants;
import com.ejie.x38.log.security.CurrentUserManager;
import com.ejie.x38.security.Credentials;

/**
 * 
 * Metadata DTO.
 * 
 * @author UDA
 * 
 */
public class TransactionMetadata implements Serializable{

	private static final long serialVersionUID = 1L;
	
	private static final Logger logger =  LoggerFactory.getLogger(TransactionMetadata.class);

	//private Long uniqueId;
	
	private SecurityContext securityContext = null;
	private String ipClient = "N/A";
	private String noInternalAcces = "N/A";
	private String serverInstance = "N/A";
	
	public TransactionMetadata(){
		TransactionMetadata auxTransactionMetadata = new TransactionMetadata("N/A", "N/A");
		this.setSecurityContext(auxTransactionMetadata.getSecurityContext());
		this.setIpClient(auxTransactionMetadata.getIpClient());
		this.setNoInternalAcces(auxTransactionMetadata.getNoInternalAcces());
		this.setSecurityContext(auxTransactionMetadata.getSecurityContext());
		
		auxTransactionMetadata = null;
	}
	
	public TransactionMetadata(String className, String methodName){

		//Get the data of the security context.
		try{
			this.setSecurityContext(SecurityContextHolder.getContext());
		} catch(Exception e) {
			if (!(e instanceof java.lang.NullPointerException)){
				throw new LogbackException("Error in the EJB remote calling system. Error accessing to the security context. The application doesn't have a security context",e);
			}
		}
		
		//Indicated the Ejb acces
		this.setNoInternalAcces(LogConstants.ACCESSTYPEEJB);
		
		//Recovered the server instance name 
		this.setServerInstance(System.getProperty("weblogic.Name"));
		
		//Http access-dependent data
		if((MDC.get(LogConstants.NOINTERNALACCES) != null)&&((MDC.get(LogConstants.NOINTERNALACCES).equals(LogConstants.ACCESSTYPEHTTP))||(MDC.get(LogConstants.NOINTERNALACCES).equals(LogConstants.ACCESSTYPEEJB)))){
			//IpAddres
			this. setIpClient(MDC.get("IPClient"));
		}
		
		logger.info("Make a remote call. The remote method "+methodName+" of the class "+className+" is invoked");
	}

	public String getNoInternalAcces() {
		return noInternalAcces;
	}

	public void setNoInternalAcces(String noInternalAcces) {
		this.noInternalAcces = noInternalAcces;
	}

	public String getServerInstance() {
		return serverInstance;
	}

	public void setServerInstance(String serverInstance) {
		this.serverInstance = serverInstance;
	}

	public SecurityContext getSecurityContext() {
		return securityContext;
	}

	public void setSecurityContext(SecurityContext securityContext) {
		this.securityContext = securityContext;
	}

	public String getIpClient() {
		return ipClient;
	}

	public void setIpClient(String ipClient) {
		this.ipClient = ipClient;
	}
	
	public void install (){
		
		MDC.put(LogConstants.NOINTERNALACCES, this.getNoInternalAcces());
		MDC.put("IPClient", this.getIpClient());		
		
		if (securityContext != null){
			
			Credentials Credentials = (Credentials) this.getSecurityContext().getAuthentication().getCredentials();
			
			SecurityContextHolder.setContext(this.getSecurityContext());
			MDC.put(LogConstants.USER, CurrentUserManager.getCurrentUsername());
			MDC.put(LogConstants.SESSION, CurrentUserManager.getCurrentUserN38UidSesion(Credentials));
			MDC.put(LogConstants.POSITION, CurrentUserManager.getPosition(Credentials));
		} else {
			logger.info("Remote service has not received the security context of the caller server. If the application has security services, is likely to occur a exception");
		}
		
		logger.info("The "+System.getProperty("weblogic.Name")+" instance receives a request remote from the instance "+this.getServerInstance()); 
	}
	
	public void clear (){
		logger.info("The "+System.getProperty("weblogic.Name")+" has completed the response to the request remote from the instance "+this.getServerInstance());
		MDC.clear();
		SecurityContextHolder.clearContext();
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/remote/TransactionMetadataSkeletonInterceptor.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.remote;

import javax.interceptor.AroundInvoke;
import javax.interceptor.InvocationContext;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ejie.x38.util.StackTraceManager;

/**
 * 
 * Instala la informacion que contiene el Objeto Metadata en el contexto del servidor.
 *
 * @author UDA
 * 
 */
public class TransactionMetadataSkeletonInterceptor {

	private static final Logger logger =  LoggerFactory.getLogger(TransactionMetadataSkeletonInterceptor.class);
	
	@AroundInvoke
	public Object manageTransactionMetadata(InvocationContext ic) throws Exception {
		TransactionMetadata txMeta = null;
		try{
			Object[] params = ic.getParameters();
			txMeta = (TransactionMetadata) params[params.length-1];
			txMeta.install();
			logger.info("Inside Interceptor invoked for "+ ic.getTarget()+"."+ic.getMethod().getName());
			return ic.proceed();
		}catch(Exception e){
			logger.error(StackTraceManager.getStackTrace(e));
			throw e;
		} finally{
			logger.info("Leaving Interceptor invoked for "+ ic.getTarget()+"."+ic.getMethod().getName());
			txMeta.clear();			
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/remote/TransactionMetadataStubInterceptor.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.remote;

import javax.interceptor.AroundInvoke;
import javax.interceptor.InvocationContext;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ejie.x38.util.StackTraceManager;

/**
 * 
 * Registra la informacion relativa al tiempo que dura la llamada remota en el sistema de Logging.
 * 
 * @author UDA
 *
 */
public class TransactionMetadataStubInterceptor {

	private static final Logger logger =  LoggerFactory.getLogger(TransactionMetadataStubInterceptor.class);

	@AroundInvoke
	public Object manageTransactionMetadata(InvocationContext ic) throws Exception {
		long start = System.currentTimeMillis();
		try {
			logger.debug("Intercepting "+ ic.getTarget()+"."+ic.getMethod().getName());
			String params = (String) ic.getParameters().toString();
			if (params == null) ic.setParameters(new String[] { "default" });
			return ic.proceed();
		} catch (Exception e) {
			logger.error(StackTraceManager.getStackTrace(e));
			throw e;
		} finally {
			long time = System.currentTimeMillis() - start;
			logger.debug("Invocation of transaction " +ic.getTarget()+"."+ic.getMethod().getName()+ " took " + time + "ms");
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/AlternativeOriginCredentialsApp.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.List;

import javax.servlet.http.HttpServletRequest;

/**
 * 
 * @author UDA
 *
 */
public interface AlternativeOriginCredentialsApp {
	
	public boolean existAditionalsAppCodes(HttpServletRequest httpRequest); 
	
	public List<String> getAppCodes(HttpServletRequest httpRequest);
	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/AlternativeOriginCredentialsAppImp.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.ArrayList;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

/**
 * 
 * @author UDA
 *
 */
public class AlternativeOriginCredentialsAppImp implements AlternativeOriginCredentialsApp{
	
	private List<String> appCodes;
	private boolean existAditionalsAppCodes = false;
	
	
	public AlternativeOriginCredentialsAppImp(List<String> appCodes){
		existAditionalsAppCodes = true;
		this.appCodes = appCodes;
	}
	
	public AlternativeOriginCredentialsAppImp(String appCode){
		existAditionalsAppCodes = true;
		this.appCodes = new ArrayList<String>();
		this.appCodes.add(appCode);
	}
	
	public List<String> getAppCodes(HttpServletRequest httpRequest){
		return this.appCodes;
	}
	
	public boolean existAditionalsAppCodes(HttpServletRequest httpRequest){
		return existAditionalsAppCodes;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/Credentials.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.io.Serializable;
import java.util.Vector;

import javax.servlet.http.HttpServletRequest;

/**
 * 
 * @author UDA
 *
 */
public interface Credentials extends Serializable {

	//Functions to manage the SubjectCert's data  
	public String toString();	
	public void loadCredentialsData(PerimetralSecurityWrapper perimetralSecurityWrapper, HttpServletRequest request);
	
	//Getters & Setters
	public String getNif();
	public void setNif(String nif);
	
	public String getPolicy();
	public void setPolicy(String policy);

	public String getUserName();
	public void setUserName(String userName);
	
	public String getFullName();
	public void setfullName(String fullName);
	
	public String getSurname();
	public void setSurname(String surname);
	
	public String getName();
	public void setName(String name);
	
	public String getPosition();
	public void setPosition(String position);
	
	public String getUidSession();
	public void setUidSession(String uidSession);
	
	public boolean getIsCertificate();
	public void setIsCertificate(boolean isCertificate);
	
	public String getUdaValidateSessionId();
	public void setUdaValidateSessionId(String udaXLNetsSessionId);
	
	public Vector<String> getUserProfiles();
	public void setUserProfiles(Vector<String> userProfiles);
	
	public boolean getDestroySessionSecuritySystem();
	public void setDestroySessionSecuritySystem(boolean destroySessionSecuritySystem);
	
	//Functions to manage the SubjectCert's data  
	public String getSubjectCert(String data);
	public boolean containsSubjectCert(String id);
	public void deleteSubjectCert(String property);
	public void setSubjectCert(String property, String value);
	
	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/ExcludeFilter.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 
 * @author UDA
 *
 */
public interface ExcludeFilter {
	
	public String getAccessDeniedUrl();
	
	public void setAccessDeniedUrl(String accessDeniedUrl);
	
	public boolean accept(HttpServletRequest httpRequest, HttpServletResponse httpResponse);
	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/MyAccessDeniedHandler.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.io.IOException;
import java.nio.charset.Charset;

import javax.annotation.Resource;
import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.ServletOutputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.web.access.AccessDeniedHandler;

/**
 * 
 * @author UDA
 *
 */

public class MyAccessDeniedHandler implements AccessDeniedHandler {

	//private static final Logger logger = LoggerFactory.getLogger(MyAccessDeniedHandler.class);
	private String errorPage;
	
	@Resource
	private ReloadableResourceBundleMessageSource messageSource;
	
	@Override
	public void handle(HttpServletRequest httpServletRequest,
			HttpServletResponse httpServletResponse,
			AccessDeniedException accessDeniedException)
			throws IOException, ServletException {
		
		if (!(httpServletResponse.isCommitted())){
		
			if (!httpServletRequest.getHeaders("X-Requested-With").hasMoreElements()){
		
				if (this.errorPage != null){
					httpServletRequest.setAttribute("SPRING_SECURITY_403_EXCEPTION", accessDeniedException);
	
					httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
	
					RequestDispatcher dispatcher = httpServletRequest.getRequestDispatcher(this.errorPage);
					dispatcher.forward(httpServletRequest, httpServletResponse);
				} else {
					String content = accessDeniedException.getMessage();
					httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
					httpServletResponse.setContentLength(content.getBytes(Charset.forName(httpServletResponse.getCharacterEncoding())).length);
					httpServletResponse.getWriter().print(content);
					httpServletResponse.flushBuffer();
				}
				
			} else {
				String message = messageSource.getMessage("security.ajaxAccesError", null, LocaleContextHolder.getLocale());
				ServletOutputStream servletOutputStream = httpServletResponse.getOutputStream();
				httpServletResponse.setHeader("LOCATION", this.errorPage);
				
				
				httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
				servletOutputStream.print(message);
				httpServletResponse.flushBuffer();		
			}
		}
		
	}
	
	public void setErrorPage(String errorPage) {
		if ((errorPage != null) && (!(errorPage.startsWith("/")))) {
			throw new IllegalArgumentException("errorPage must begin with '/'");
		}
	 
		this.errorPage = errorPage;
	}

		

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/MyAuthenticatedUserDetailsService.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.Vector;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.AuthenticationUserDetailsService;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.util.Assert;

/**
 * 
 * @author UDA
 *
 */
public class MyAuthenticatedUserDetailsService implements
		AuthenticationUserDetailsService<Authentication> {

	private static final Logger logger = LoggerFactory
			.getLogger(MyAuthenticatedUserDetailsService.class);
	private PerimetralSecurityWrapper perimetralSecurityWrapper;

	@Override
	public UserDetails loadUserDetails(Authentication token)
			throws UsernameNotFoundException {
		Assert.notNull(token.getCredentials());
		logger.trace("User's token is: "+token.toString());
		logger.trace("User's credentials are "+token.getCredentials().toString());

		Credentials Credentials = (Credentials) token
				.getCredentials();
		UserDetails userDetails = null;
		if (Credentials != null) {
			Vector<String> vectorProfilesXLNET = Credentials.getUserProfiles();
			XlnetGrantedAuthority[] profiles = null;
			if (vectorProfilesXLNET != null) {
				profiles = new XlnetGrantedAuthority[vectorProfilesXLNET.size()];
				for (int contadorAuthXLNET = 0; contadorAuthXLNET < vectorProfilesXLNET
						.size(); contadorAuthXLNET++) {
					String authority = "ROLE_"
							+ vectorProfilesXLNET.get(contadorAuthXLNET);
					profiles[contadorAuthXLNET] = new XlnetGrantedAuthority(
							authority);
				}
			}
			userDetails = createuserDetails(token, profiles);
		}
		logger.trace("UserDetails is: "+userDetails.toString());
		
		return userDetails;
	}

	protected MyUserDetails createuserDetails(Authentication token,
			GrantedAuthority[] profiles) {
		return new MyUserDetails(token.getName(), // UserName
				"N/A", // Password
				true, // Enabled
				true, // AccountNonExpired
				true, // CredentialsNonExpired
				true, // Account Not Locked
				profiles); // Profiles.
	}
	
	//Getters & Setters
	public PerimetralSecurityWrapper getPerimetralSecurityWrapper() {
		return perimetralSecurityWrapper;
	}

	public void setPerimetralSecurityWrapper(
			PerimetralSecurityWrapper perimetralSecurityWrapper) {
		this.perimetralSecurityWrapper = perimetralSecurityWrapper;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/MyAuthenticationEntryPoint.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.io.IOException;
import java.net.URL;

import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatus;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import com.ejie.x38.util.ManagementUrl;
import com.ejie.x38.util.StaticsContainer;

/**
 * 
 * @author UDA
 *
 */
public class MyAuthenticationEntryPoint implements AuthenticationEntryPoint,
		Ordered {
	private static final Logger logger = LoggerFactory
			.getLogger(MyAuthenticationEntryPoint.class);

	private int order = Integer.MAX_VALUE;

	private PerimetralSecurityWrapper perimetralSecurityWrapper;

	@Override
	public void commence(HttpServletRequest request,
			HttpServletResponse response, AuthenticationException authException)
			throws IOException, ServletException {
		if (authException != null)
			logger.debug("Authentication Exception: "+ authException.getMessage());
		
		HttpServletResponse httpResponse = (HttpServletResponse) response;
		HttpServletRequest httpRequest = (HttpServletRequest) request;
		
		String url;
		Cookie requestCookies[] = request.getCookies();
		StringBuilder portalData = new StringBuilder("/");
		boolean isAjax = request.getHeaders("X-Requested-With").hasMoreElements();
		boolean isPortal = false;
		
		//valoracion del acelerador
		String originalURL = ManagementUrl.getUrl(httpRequest);
		
		if(StaticsContainer.aplicInPortal){
			if (requestCookies != null){
				for (int i = 0; i < requestCookies.length; i++) {
					if (requestCookies[i].getName().equals("r01PortalInfo")){
						isPortal = true;
						
						portalData.append(requestCookies[i].getValue ());
						StringBuilder host = new StringBuilder(httpRequest.getServerName());
						
						if (originalURL.split(":").length > 1){
							host.append(":");
							host.append(httpRequest.getServerPort());
						}
						
						originalURL = originalURL.replaceAll(host.toString(), host.toString()+portalData.toString());
						break;
					}
		        }
			}
		}
		
		logger.info("XLNET Session isn't valid or not created!");
		
		if (isAjax && StaticsContainer.isXhrRedirectOnError()){
			if (StaticsContainer.getXhrUnauthorizedPage() != null && StaticsContainer.getXhrUnauthorizedPage().equals("referer")) {
				String referer = request.getHeader("Referer");
				
				if (referer.contains(";jsessionid=")) {
					referer = referer.substring(0, referer.indexOf(";jsessionid="));
				}
				
				StaticsContainer.setXhrUnauthorizedPage(getPerimetralSecurityWrapper().getURLLogin(referer, isAjax));
			}
			
			url = this.getUrlAjax(StaticsContainer.getXhrUnauthorizedPage() != null ? StaticsContainer.getXhrUnauthorizedPage() : getPerimetralSecurityWrapper().getURLLogin(originalURL, isAjax), isPortal);
			
			// Se detecta si es una petición AJAX
			httpResponse.setStatus(HttpStatus.UNAUTHORIZED.value());
			httpResponse.setHeader("LOCATION", url);
		}else{
			url = getPerimetralSecurityWrapper().getURLLogin(originalURL , isAjax);
			if(isAjax){
				url = this.getUrlAjax(url, isPortal);
			}
			
			if (!url.matches("^https?://.*$")) {
				url = new URL(httpRequest.getScheme(), httpRequest.getServerName(), httpRequest.getServerPort(), url).toString();
			}
			
			logger.info("Redirecting to next URL:" + url);
			httpResponse.sendRedirect(url);
		}	
	}

	@Override
	public int getOrder() {
		return order;
	}

	// Private 
	private String getUrlAjax(String url, boolean isPortal){
		String sep = url.indexOf('?') > -1 ? "&" : "?";
		return isPortal ? url.concat(sep).concat("R01HNoPortal=true") : url;
	}
	
	// Getters & Setters
	public PerimetralSecurityWrapper getPerimetralSecurityWrapper() {
		return perimetralSecurityWrapper;
	}

	public void setPerimetralSecurityWrapper(
			PerimetralSecurityWrapper perimetralSecurityWrapper) {
		this.perimetralSecurityWrapper = perimetralSecurityWrapper;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/MyLogoutHandler.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.lang.reflect.InvocationTargetException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.logout.LogoutHandler;
import org.springframework.util.Assert;

/**
 * 
 * @author UDA
 *
 */
public class MyLogoutHandler implements LogoutHandler {
	private boolean invalidateHttpSession;
	private boolean invalidateUserSession;
	private PerimetralSecurityWrapper perimetralSecurityWrapper;
	static Logger logger =  LoggerFactory.getLogger(MyLogoutHandler.class);
	
	public PerimetralSecurityWrapper getPerimetralSecurityWrapper() {
		return perimetralSecurityWrapper;
	}

	public void setPerimetralSecurityWrapper(
			PerimetralSecurityWrapper perimetralSecurityWrapper) {
		this.perimetralSecurityWrapper = perimetralSecurityWrapper;
	}

	@Override
	public void logout(HttpServletRequest request,
			HttpServletResponse response, Authentication authentication) {
		
		HttpSession httpSession = request.getSession(false);
		
		//Clear Spring Security Context
		logger.info("XLNET session is invalid. Proceeding to clean the Security Context Holder.");
		
		if(authentication != null){
			authentication.setAuthenticated(false);
		}
		SecurityContextHolder.clearContext();
		
		if(httpSession != null && (httpSession.getAttribute("SPRING_SECURITY_CONTEXT") != null)){
			httpSession.removeAttribute("SPRING_SECURITY_CONTEXT");
		}
		
		logger.info( "SecurityContextHolder cleared!");
		
		//Destroy XLNET session
		if(this.invalidateUserSession){
			Assert.notNull(request, "HttpServletRequest required");			
			getPerimetralSecurityWrapper().logout(request, response);
			try {
				Object credentials = authentication.getCredentials();
				Object uidSession = credentials.getClass().getMethod("getUidSession").invoke(credentials);
				logger.info("XLNetS {} session destroyed!", (String) uidSession);
			} catch (IllegalArgumentException e) {
				e.printStackTrace();
			} catch (SecurityException e) {
				e.printStackTrace();
			} catch (IllegalAccessException e) {
				e.printStackTrace();
			} catch (InvocationTargetException e) {
				e.printStackTrace();
			} catch (NoSuchMethodException e) {
				e.printStackTrace();
			}
		}

		//Invalidate HTTP session
		if (httpSession != null && this.invalidateHttpSession) {
			
			//Cleaning the User Session of Weblogic
			try{ 
				logger.info("Session " +httpSession.getId()+ " invalidated!");
				httpSession.invalidate();
			} catch (IllegalStateException e) {
				logger.info( "The user session isn't valid, it is not necessary delete it");
			}
		}
	}

	public boolean isInvalidateHttpSession() {
		return invalidateHttpSession;
	}

	public void setInvalidateHttpSession(boolean invalidateHttpSession) {
		this.invalidateHttpSession = invalidateHttpSession;
	}

	public boolean isInvalidateUserSession() {
		return invalidateUserSession;
	}

	public void setInvalidateUserSession(boolean invalidateUserSession) {
		this.perimetralSecurityWrapper.setDestroySessionSecuritySystem(invalidateUserSession);			 
		this.invalidateUserSession = invalidateUserSession;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/MyUserDetails.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.util.Assert;

/**
 * 
 * @author UDA
 *
 */
public class MyUserDetails implements UserDetails {

	private static final long serialVersionUID = 1L;
	private String password;
	private String username;
	private Collection<GrantedAuthority> authorities;
	private boolean accountNonExpired;
	private boolean accountNonLocked;
	private boolean credentialsNonExpired;
	private boolean enabled;
	private GrantedAuthority[] profiles;

	public MyUserDetails(String username, String password, boolean enabled,
			boolean accountNonExpired, boolean credentialsNonExpired,
			boolean accountNonLocked, GrantedAuthority[] profiles)
			throws IllegalArgumentException {
		if (((username == null) || "".equals(username)) || (password == null)) {
			throw new IllegalArgumentException(
					"Cannot pass null or empty values to constructor");
		}

		this.username = username;
		this.password = password;
		this.enabled = enabled;
		this.accountNonExpired = accountNonExpired;
		this.credentialsNonExpired = credentialsNonExpired;
		this.accountNonLocked = accountNonLocked;
		setProfiles(profiles);
		setAuthorities(profiles);
	}

	public GrantedAuthority[] getProfiles() {
		return profiles;
	}

	protected void setProfiles(GrantedAuthority[] perfiles) {
		Assert.notNull(perfiles, "Cannot pass a null GrantedAuthority array");
		// Ensure array iteration order is predictable (as per UserDetails.getAuthorities() contract and SEC-xxx)
		List<GrantedAuthority> notNullAuthorities = new ArrayList<GrantedAuthority>();
		for (int i = 0; i < perfiles.length; i++) {
			Assert.notNull(
					perfiles[i],
					"Granted perfiles element "
							+ i
							+ " is null - GrantedAuthority[] cannot contain any null elements");
			notNullAuthorities.add(perfiles[i]);
		}
		this.profiles = (GrantedAuthority[]) notNullAuthorities
				.toArray(new GrantedAuthority[notNullAuthorities.size()]);
	}

	@Override
	public Collection<GrantedAuthority> getAuthorities() {
		return authorities;
	}

	/**
	 * Establishes user permissions, checking that none of them will be null.
	 */
	protected void setAuthorities(GrantedAuthority[] authorities) {
		Assert.notNull(authorities, "Cannot pass a null GrantedAuthority array");

		// Ensure array iteration order is predictable (as per UserDetails.getAuthorities() contract and SEC-xxx)
		List<GrantedAuthority> sorter = new ArrayList<GrantedAuthority>();
		for (int i = 0; i < authorities.length; i++) {
			Assert.notNull(
					authorities[i],
					"Granted authority element "
							+ i
							+ " is null - GrantedAuthority[] cannot contain any null elements");
			sorter.add(authorities[i]);
		}

		this.authorities = sorter;
	}

	@Override
	public String getPassword() {
		return password;
	}

	@Override
	public String getUsername() {
		return username;
	}

	@Override
	public boolean isAccountNonExpired() {
		return accountNonExpired;
	}

	@Override
	public boolean isAccountNonLocked() {
		return this.accountNonLocked;
	}

	@Override
	public boolean isCredentialsNonExpired() {
		return credentialsNonExpired;
	}

	@Override
	public boolean isEnabled() {
		return enabled;
	}

	public boolean equals(Object rhs) {
		if (!(rhs instanceof MyUserDetails) || (rhs == null)) {
			return false;
		}

		MyUserDetails user = (MyUserDetails) rhs;

		// We rely on constructor to guarantee any User has non-null and >0 authorities
		if (user.getProfiles().length != this.getProfiles().length) {
			return false;
		}
		for (int i = 0; i < this.getProfiles().length; i++) {
			if (!this.getProfiles()[i].equals(user.getProfiles()[i])) {
				return false;
			}
		}

		// We rely on constructor to guarantee non-null username and password
		return (this.getPassword().equals(user.getPassword())
				&& this.getUsername().equals(user.getUsername())
				&& (this.isAccountNonExpired() == user.isAccountNonExpired())
				&& (this.isAccountNonLocked() == user.isAccountNonLocked())
				&& (this.isCredentialsNonExpired() == user
						.isCredentialsNonExpired()) && (this.isEnabled() == user
				.isEnabled()));
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append(super.toString()).append(": ");
		sb.append("Username: ").append(this.username).append("; ");
		sb.append("Password: [PROTECTED]; ");
		sb.append("Enabled: ").append(this.enabled).append("; ");
		sb.append("AccountNonExpired: ").append(this.accountNonExpired)
				.append("; ");
		sb.append("credentialsNonExpired: ").append(this.credentialsNonExpired)
				.append("; ");
		sb.append("AccountNonLocked: ").append(this.accountNonLocked)
				.append("; ");

		if (this.getProfiles() != null) {
			sb.append("Granted Profiles: ");

			for (int i = 0; i < this.getProfiles().length; i++) {
				if (i > 0) {
					sb.append(", ");
				}
				sb.append(this.getProfiles()[i].toString());
			}
		} else {
			sb.append("Not granted any profiles");
		}
		sb.append("; ");

		return sb.toString();
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/PerimetralSecurityWrapper.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.HashMap;
import java.util.Vector;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * 
 * @author UDA
 *
 */
public interface PerimetralSecurityWrapper {
	
	public String validateSession(HttpServletRequest httpRequest, HttpServletResponse response) throws SecurityException;
	
	public String getUserConnectedUserName(HttpServletRequest httpRequest);
	
	public HashMap<String, String> getUserDataInfo(HttpServletRequest httpRequest, boolean isCertificate);
	
	public String getUserConnectedUidSession(HttpServletRequest httpRequest);
	
	public String getUdaValidateSessionId(HttpServletRequest httpRequest);
	
	public String getUserPosition(HttpServletRequest httpRequest);

	public String getURLLogin(String originalURL, boolean ajax);

	public String getPolicy(HttpServletRequest httpRequest);
	
	public boolean getIsCertificate(HttpServletRequest httpRequest);
	
	public Vector<String> getUserInstances(HttpServletRequest httpRequest);

	public void logout(HttpServletRequest httpRequest, HttpServletResponse httpResponse);
	
	public String getNif(HttpServletRequest httpRequest);
	 
	public Credentials getCredentials();
	
	public boolean getDestroySessionSecuritySystem();
	
	public void setDestroySessionSecuritySystem(boolean destroySessionSecuritySystem);
	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/PerimetralSecurityWrapperMockImpl.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Vector;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;


import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.MappingJsonFactory;
import com.fasterxml.jackson.databind.ObjectMapper;


import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.UnsatisfiedDependencyException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.context.WebApplicationContext;

import com.ejie.x38.log.LogConstants;

/**
 * 
 * @author UDA
 *
 */
public class PerimetralSecurityWrapperMockImpl implements
		PerimetralSecurityWrapper {
	
	@Autowired
	private WebApplicationContext webApplicationContext;
	
	private static final Logger logger = LoggerFactory
			.getLogger(PerimetralSecurityWrapperMockImpl.class);

	private ArrayList<HashMap<String,Object>> principal;
	private String userChangeUrl;
	private Object specificCredentials = null;
	private String specificCredentialsName = null;
	private boolean destroySessionSecuritySystem = false;

	public String validateSession(HttpServletRequest httpRequest, HttpServletResponse response) throws SecurityException{
		
		Credentials credentials = null; 
		Authentication authentication = null;
		StringBuilder udaMockSessionId = new StringBuilder();
		HttpSession httpSession = httpRequest.getSession(true);
				
		//mock retrieve udaMockUserName cookie
		Cookie requestCookies[] = httpRequest.getCookies ();
		Cookie udaMockUserName = null;			
		
		if (requestCookies != null){
			for (int i = 0; i < requestCookies.length; i++) {
				if (requestCookies[i].getName().equals("udaMockUserName")){
					udaMockUserName = requestCookies[i];
					break;
				}
			}
		}
		
		if (udaMockUserName != null){
			udaMockSessionId.append(udaMockUserName.getValue()); 
			udaMockSessionId.append("-");
			udaMockSessionId.append(httpRequest.getSession(false).getId());
			
			//Getting Authentication credentials
			authentication = SecurityContextHolder.getContext().getAuthentication();
			
			if (authentication != null){
				credentials = (Credentials)authentication.getCredentials();
			}
					
			//If the sessionId changed, disable XLNET caching
			if (credentials != null){
				if(!(credentials.getUdaValidateSessionId().equals(udaMockSessionId.toString()))){
					
					authenticationLogContextClean();
					httpSession.setAttribute("reloadData", "true");
					httpSession.setAttribute("userChange", "true");
											
					if(userChangeUrl != null){
						SecurityContextHolder.clearContext();
						return userChangeUrl;
					}
				}
			}
				
			return "true";
		} else {
			return "false";
		}
	}
	
	public String getUserConnectedUidSession(HttpServletRequest httpRequest) {
		
		if(httpRequest.getSession(false) != null){
			return httpRequest.getSession(false).getId();
		} else {
			return "no session available";
		}
	}

	public String getUserPosition(HttpServletRequest httpRequest){
		
		HashMap<String, Object> user = getUserData(principal, getUserConnectedUserName(httpRequest));
		
		return (String)user.get("position");		
	}
	
	public String getUdaValidateSessionId(HttpServletRequest httpRequest) {
		StringBuilder udaMockSessionId = new StringBuilder();
		
		udaMockSessionId.append(getUserConnectedUserName(httpRequest)); 
		udaMockSessionId.append("-");
		udaMockSessionId.append(httpRequest.getSession(false).getId());
		
		return udaMockSessionId.toString();
	}
	
	public String getUserConnectedUserName(HttpServletRequest httpRequest) {
		
		Cookie requestCookies[] = httpRequest.getCookies ();
		Cookie udaMockUserName = null;			
		
		if (requestCookies != null){
			for (int i = 0; i < requestCookies.length; i++) {
				if (requestCookies[i].getName().equals("udaMockUserName")){
					udaMockUserName = requestCookies[i];
					break;
				}
			}
		}
		
		if(httpRequest.getSession(false).getAttribute("fullName") == null){
			HashMap<String, Object> user = getUserData(principal, udaMockUserName.getValue());
		
			httpRequest.getSession(false).setAttribute("fullName", (String)user.get("fullName"));
		}
		
		return udaMockUserName.getValue();
	}
	
	@SuppressWarnings("unchecked")
	public HashMap<String, String> getUserDataInfo(HttpServletRequest httpRequest, boolean isCertificate){
		//falta la especificacion de datos de las credenciles para el mock
		HashMap<String, Object> user = getUserData(principal, getUserConnectedUserName(httpRequest));
		HashMap<String, String> userData = new HashMap<String, String>();
		
		if(isCertificate && user.get("subjectCert") != null){
			userData = (HashMap<String, String>)user.get("subjectCert");
		}
		
		userData.put("name", (String)user.get("name"));
		userData.put("surname", (String)user.get("surname"));
		userData.put("fullName", (String)user.get("fullName"));
		
		return (userData);
	}

	@SuppressWarnings("unchecked")
	public Vector<String> getUserInstances(HttpServletRequest httpRequest) {
		HashMap<String, Object> user = getUserData(principal, getUserConnectedUserName(httpRequest));
		
		return new Vector<String>((ArrayList<String>)user.get("roles"));	
	}
	
	public String getPolicy(HttpServletRequest httpRequest) {
		HashMap<String, Object> user = getUserData(principal, getUserConnectedUserName(httpRequest));
		
		return (String)user.get("policy");		
	}	
	
	public boolean getIsCertificate(HttpServletRequest httpRequest) {
		HashMap<String, Object> user = getUserData(principal, getUserConnectedUserName(httpRequest));
		
		if (((String)user.get("isCertificate")).equals("false")){
			return false;
		} else {
			return true;
		}
	}
	
	public String getNif(HttpServletRequest httpRequest) {
		HashMap<String, Object> user = getUserData(principal, getUserConnectedUserName(httpRequest));
		
		return (String)user.get("nif");	
	}
	
	public String getURLLogin(String originalURL, boolean ajax) {
		String dataUsers = null;
		ArrayList<HashMap<String, String>> usersNames = new ArrayList<HashMap<String, String>> ();
		Iterator<HashMap<String,Object>> usersIterator = principal.iterator();
		HashMap<String, String> auxObject = new HashMap<String, String>();
		HashMap<String, Object> user;
		
		//Parameters of JSon serialization  
		ObjectMapper mapper = new ObjectMapper();
		StringWriter sw = new StringWriter();
		MappingJsonFactory jsonFactory = new MappingJsonFactory();
		JsonGenerator jsonGenerator;
		
		while ( usersIterator.hasNext() ){
			auxObject = new HashMap<String, String>();
			user = usersIterator.next();
			auxObject.put("text", (String)user.get("fullName"));
			auxObject.put("id", (String)user.get("userName"));
			
			usersNames.add(auxObject);
		}
		
		try {
			jsonGenerator = jsonFactory.createGenerator(sw);
			mapper.writeValue(jsonGenerator, usersNames);
			sw.close();
			dataUsers = sw.getBuffer().toString();
			
			//Deleting the objects of the serialization
			jsonGenerator = null;
			mapper = null;
			jsonFactory = null;
			
		} catch (Exception e) {
			logger.error("Produced a error in the conversion of the mockWrapper usernames. Review your configuration. The response is void.");
			if (!ajax){
				return(webApplicationContext.getServletContext().getContextPath()+"/mockLoginPage?mockUrl="+originalURL+"&userNames=\"\"");
			} else {
				return(webApplicationContext.getServletContext().getContextPath()+"/mockLoginAjaxPage?mockUrl="+originalURL+"&userNames=\"\"");
			}
		}
		
		if (!ajax){
			return(webApplicationContext.getServletContext().getContextPath()+"/mockLoginPage?mockUrl="+originalURL+"&userNames="+dataUsers);
		} else {
			return(webApplicationContext.getServletContext().getContextPath()+"/mockLoginAjaxPage?mockUrl="+originalURL+"&userNames="+dataUsers);
		}
	}

	public void logout(HttpServletRequest httpRequest, HttpServletResponse httpResponse) {
		
		String uidSession = getUserConnectedUidSession(httpRequest);
		logger.info( "Proceeding to destroy uidSession: "+ uidSession);
		
		//Cleaning SpringSecurity context
		springSecurityContextClean();
		
		//Cleaning of the udaMockUserName cookie
		Cookie requestCookies[] = httpRequest.getCookies ();
		Cookie udaMockUserName = null;			
		
		if (requestCookies != null){
			for (int i = 0; i < requestCookies.length; i++) {
				if (requestCookies[i].getName().equals("udaMockUserName")){
					udaMockUserName = requestCookies[i];
					udaMockUserName.setMaxAge(0);
					udaMockUserName.setPath("/");
					httpResponse.addCookie(udaMockUserName);
					break;
				}
			}
		}
		
		

		logger.info( "Session "+uidSession+" destroyed!");
	}
	
	//Cleaner method of SpringSecurity context
	private void springSecurityContextClean(){
		logger.error("Session is invalid. Proceeding to clean the Security Context Holder.");
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		
		if(authentication != null){
			authentication.setAuthenticated(false);
		}
		SecurityContextHolder.clearContext();
	}
	
	//Returns data of the specific user
	private HashMap<String,Object> getUserData(ArrayList<HashMap<String,Object>> principal, String name){
		
		Iterator<HashMap<String,Object>> usersIterator = principal.iterator();
		HashMap<String, Object> user = null;
		
		while ( usersIterator.hasNext() ){
			user = usersIterator.next();
			if (((String)user.get("userName")).equals(name)){
				break;
			}
		}
		
		return user;
	}
	
	//Cleaner method unregister Authentication Configuration
	private void authenticationLogContextClean(){
		MDC.put(LogConstants.SESSION,"N/A");
		MDC.put(LogConstants.USER,"N/A");
		MDC.put(LogConstants.POSITION,"N/A");
	}
	
	//Getters & Setters
	public Object getSpecificCredentials(){
		return this.specificCredentials;
	}
	
	public Credentials getCredentials(){
		if (specificCredentialsName == null){
			return new UserCredentials();
		} else {
			try {
				return (Credentials)Class.forName(specificCredentialsName).newInstance();
			}catch (Exception e) {
				logger.error("getCredentials(): The object specified to the parameter \"SpecificCredentials\" is not correct. The object has not been instantiated", e);
				SecurityException sec = new SecurityException("getCredentials(): The object specified to the parameter \"SpecificCredentials\" is not correct. The object has not been instantiated", e.getCause());
				throw sec;
			}
		}
	}
	
	public boolean getDestroySessionSecuritySystem(){
		return this.destroySessionSecuritySystem;
	}
	
	public ArrayList<HashMap<String,Object>> getPrincipal() {
		return principal;
	}
	
	public void setPrincipal(ArrayList<HashMap<String,Object>> principal) {
		this.principal = principal;
		
		//Data of User Anonymous
		HashMap<String, Object> userAnonymous = new HashMap<String, Object>(); 
		ArrayList<String> roles = new ArrayList<String>();
		HashMap<String,String> subjectCert = new HashMap<String,String>();
		roles.add("UDAANONYMOUS");
		
		userAnonymous.put("userName", "udaAnonymousUser");
		userAnonymous.put("name", "uda");
		userAnonymous.put("surName", "Anonymous User");
		userAnonymous.put("fullName", "Uda Anonymous User");
		userAnonymous.put("nif", "00000000a");
		userAnonymous.put("policy", "udaAnonymousPolicy");
		userAnonymous.put("position", "udaAnonymousPosition");
		userAnonymous.put("isCertificate", "no");
		userAnonymous.put("subjectCert",subjectCert);
		userAnonymous.put("roles", roles);
		
		this.principal.add(userAnonymous);
					
	}
	
	public String getUserChangeUrl() {
		return this.userChangeUrl;
	}
	
	public void setUserChangeUrl(String userChangeUrl) {
		this.userChangeUrl = userChangeUrl;
	}
	
	public void setSpecificCredentials(Object credentials){
		Object specificCredentials = credentials; 
		
		try{
			if(specificCredentials instanceof String){
				specificCredentials = Class.forName((String)credentials).newInstance();
			}
			if(specificCredentials instanceof Credentials){
				this.specificCredentialsName = specificCredentials.getClass().getName();				
			} else {
				throw new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "setSpecificCredentials", "The specified object is not correct to the parameter  \"SpecificCredentials\". The object must be instace of String (className of a Class than extend the \"Credentials\" Class) or one Bean of a Class than extend the \"Credentials\" Class.");
			}
		} catch (Exception e) {
			throw new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "setSpecificCredentials", "The specified object is not correct to the parameter  \"SpecificCredentials\". The object must be instace of String (className of a Class than extend the \"Credentials\" Class) or one Bean of a Class than extend the \"Credentials\" Class.");
		} finally {
			this.specificCredentials = specificCredentials;
		}
	}
		
	public void setDestroySessionSecuritySystem(boolean destroySessionSecuritySystem){
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/PerimetralSecurityWrapperN38Impl.java
================================================
/*
 * Copyright 2012 E.J.I.E., S.A.
 *
 * Licencia con arreglo a la EUPL, VersiÃ³n 1.1 exclusivamente (la Â«LicenciaÂ»);
 * Solo podrÃ¡ usarse esta obra si se respeta la Licencia.
 * Puede obtenerse una copia de la Licencia en
 *
 * http://ec.europa.eu/idabc/eupl.html
 *
 * Salvo cuando lo exija la legislaciÃ³n aplicable o se acuerde por escrito,
 * el programa distribuido con arreglo a la Licencia se distribuye Â«TAL CUALÂ»,
 * SIN GARANTÃ�AS NI CONDICIONES DE NINGÃšN TIPO, ni expresas ni implÃ­citas.
 * VÃ©ase la Licencia en el idioma concreto que rige los permisos y limitaciones
 * que establece la Licencia.
 */
package com.ejie.x38.security;

import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.TimeUnit;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.beans.factory.UnsatisfiedDependencyException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.w3c.dom.Document;

import com.ejie.x38.log.LogConstants;
import com.ejie.x38.util.StaticsContainer;
import com.ejie.x38.util.ThreadStorageManager;

import n38a.exe.N38APISesion;
import n38c.exe.N38API;
import n38i.exe.N38Excepcion;
import n38i.exe.N38ParameterException;

/**
 * 
 * @author UDA
 *
 */
public class PerimetralSecurityWrapperN38Impl implements
		PerimetralSecurityWrapper {

	private static final Logger logger = LoggerFactory
			.getLogger(PerimetralSecurityWrapperN38Impl.class);

	private Long xlnetCachingPeriod = Long.valueOf(0);
	private String xlnetsDomain = null;
	private boolean destroySessionSecuritySystem = false;
	private String userChangeUrl = null;
	private ExcludeFilter excludeFilter = null;
	private UdaCustomJdbcDaoImpl alternativeStorageUserCredentials = null;
	private boolean useXlnetProfiles = false;
	private HashMap<String, String> anonymousProfile = new HashMap<String, String>();
	private AlternativeOriginCredentialsApp alternativeOriginCredentialsApp = null;
	private String specificCredentialsName = null;
	private Object specificCredentials = null;

	public PerimetralSecurityWrapperN38Impl() {
		this.anonymousProfile.put("position", "udaAnonymousPosition");
		this.anonymousProfile.put("userProfiles", "udaAnonymousProfile");
	}

	public synchronized String validateSession(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws SecurityException {

		String udaXLNetsSessionId = getXlnetsUserId(httpRequest);

		// Getting Authentication credentials
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		Credentials credentials = null;

		// Setpoint of the User Session. if the session is not created, it will
		// proceed to create it
		HttpSession httpSession = httpRequest.getSession(true);

		if (authentication != null) {
			credentials = (Credentials) authentication.getCredentials();
		}

		if (credentials != null) {
			if (udaXLNetsSessionId != null) {

				if (excludeFilter != null && (!excludeFilter.accept(httpRequest, httpResponse))) {
					springSecurityContextClean(httpSession);
					return excludeFilter.getAccessDeniedUrl();

					// If the sessionId changed, disable XLNET caching
				} else if (credentials.getUdaValidateSessionId().compareTo(udaXLNetsSessionId.toString()) != 0) {

					logger.info("XLNet's caching of session " + httpSession.getId() + " expired, because the XLNets user has changed");
					authenticationLogContextClean();

					// redirect, if is necesary
					if (userChangeUrl != null) {
						udaXLNetsSessionId = null;
						springSecurityContextClean(httpSession);
						return userChangeUrl;
					}

					// Validate the Object of XLnets
					if (!(isN38ApiValid(httpRequest, httpResponse))) {
						udaXLNetsSessionId = null;
						springSecurityContextClean(httpSession);
						return "false";
					}

					// springSecurityContextClean(httpSession);
					loadReloadData(httpRequest, ThreadStorageManager.getCurrentThreadId());
					httpSession.setAttribute("userChange", "true");

					// If the last XLNET session refresh was performed more than
					// X minutes ago, disable caching
				} else if (httpSession != null && httpSession.getAttribute("udaTimeStamp") != null) {
					if (reloadData(httpRequest)) {
						logger.info("XLNet's caching of session " + httpSession.getId() + " expired, after, at least, " + xlnetCachingPeriod + " Seconds");

						// Validate the Object of XLnets
						if (isN38ApiValid(httpRequest, httpResponse)) {
							loadReloadData(httpRequest, ThreadStorageManager.getCurrentThreadId());
						} else {
							authenticationLogContextClean();
							udaXLNetsSessionId = null;
							springSecurityContextClean(httpSession);
							return "false";
						}
					}
				}
				return "true";

			} else {
				// There isn't a correct session of XLNET
				logger.info("There isn't a correct session of XLNET");
				logout(httpRequest, httpResponse);
				springSecurityContextClean(httpSession);
				udaXLNetsSessionId = null;
				return "false";
			}
		} else {
			logger.info("authentication.getCredentials() null");
			// Validate the Object of XLnets
			if (udaXLNetsSessionId != null && isN38ApiValid(httpRequest, httpResponse)) {
				// The entry is accepting by the security system
				udaXLNetsSessionId = null;
				return "true";
			} else {
				// The entry isn't accepting by the security system
				udaXLNetsSessionId = null;
				return "false";
			}
		}
	}

	/* Methods to recovery the credentials data */

	public String getUserConnectedUserName(HttpServletRequest httpRequest) {
		String userName = null;
		String xlnetUserId = getXlnetsUserId(httpRequest);
		HttpSession httpSession = httpRequest.getSession(false);
		Credentials credentials = null;
		Authentication authentication = null;

		// Getting Authentication credentials
		authentication = SecurityContextHolder.getContext().getAuthentication();

		if (authentication != null) {
			credentials = (Credentials) authentication.getCredentials();
		}

		if (httpSession != null) {
			userName = (String) httpSession.getAttribute("userName");

			if (!(userName == null && credentials == null)) {
				if (userName == null) {
					httpSession.removeAttribute("fullName");
					httpSession.removeAttribute("destroySessionSecuritySystem");
					userName = credentials.getUserName();
				} else {
					httpSession.removeAttribute("userName");
				}
			} else {
				userName = loadXlnetsCredentialInfo(httpRequest, xlnetUserId);
			}
		} else {
			userName = loadXlnetsCredentialInfo(httpRequest, xlnetUserId);
		}

		logger.trace("Connected User's Name is: " + userName);
		return userName;
	}

	public HashMap<String, String> getUserDataInfo(HttpServletRequest httpRequest, boolean isCertificate) {
		HttpSession httpSession = httpRequest.getSession(false);
		String fullName = (String) httpSession.getAttribute("fullName");

		// Returning UserDataInfo
		HashMap<String, String> userData = new HashMap<String, String>();
		HashMap<String, String> userInfo = null;
		N38API n38Api = XlnetCore.getN38API(httpRequest);
		Document xmlSesion;

		if (isCertificate) {
			xmlSesion = XlnetCore.getN38ItemSesion(n38Api);
			userData = XlnetCore.getN38SubjectCert(xmlSesion);
		}

		if (fullName != null) {
			userData.put("fullName", fullName);
			userData.put("name", (String) httpSession.getAttribute("name"));
			userData.put("surname", (String) httpSession.getAttribute("surname"));

			httpSession.removeAttribute("name");
			httpSession.removeAttribute("surname");
		} else {
			try {
				String n38uidOrg = n38Api.n38ItemSesion("n38uidOrg")[0];
				if (!n38uidOrg.equals("0")) {
					// User is in the XLNets's LDap
					userInfo = XlnetCore.getUserDataInfo(n38Api);
					userData.put("name", userInfo.get("name"));
					userData.put("surname", userInfo.get("surname"));
					userData.put("fullName", userInfo.get("fullName"));
					httpSession.setAttribute("fullName", userInfo.get("fullName"));

				} else {
					// User isn't in the XLNets's LDap: certificado o juego de barcos
					userData.put("name", userData.get("GIVENNAME"));
					userData.put("surname", userData.get("SURNAME"));
					// En caso de autenticaciÃ³n mediante juego de barcos el campo CN tendrÃ¡ 
					// el valor de la propiedad dni del xml de sesiÃ³n de XLNetS
					// o, si estuviera vacio el dni, el valor del n38SubjectCert  
					userData.put("fullName", userData.get("CN"));
					httpSession.setAttribute("fullName", userData.get("CN"));
				}

				xmlSesion = null;
				userInfo = null;
			} catch (N38ParameterException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (N38Excepcion e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		logger.trace("Connected User's data is: " + userData.toString());

		return userData;
	}

	public String getUserPosition(HttpServletRequest httpRequest) {
		String userPosition = null;

		userPosition = (String) httpRequest.getSession(false).getAttribute("position");

		httpRequest.getSession(false).removeAttribute("position");

		logger.trace("Connected User's Position is: " + userPosition);
		return userPosition;

	}

	public String getUdaValidateSessionId(HttpServletRequest httpRequest) {
		String udaValidateSessionId = null;

		udaValidateSessionId = (String) httpRequest.getSession(false).getAttribute("udaValidateSessionId");

		// Returning UdaValidateSessionId
		httpRequest.getSession(false).removeAttribute("udaValidateSessionId");

		logger.trace("Connected UserConnectedUidSession is: " + udaValidateSessionId);
		return udaValidateSessionId;

	}

	@SuppressWarnings("unchecked")
	public Vector<String> getUserInstances(HttpServletRequest httpRequest) {
		Vector<String> userInstances = null;

		userInstances = (Vector<String>) httpRequest.getSession(false).getAttribute("userProfiles");

		// Returning UserInstances
		httpRequest.getSession(false).removeAttribute("userProfiles");

		logger.trace("Connected UserConnectedUidSession is: " + userInstances);
		return userInstances;

	}

	public String getUserConnectedUidSession(HttpServletRequest httpRequest) {
		String userConnectedUidSession = null;
		HttpSession httpSession = httpRequest.getSession(false);

		if (httpSession != null) {
			userConnectedUidSession = (String) httpSession.getAttribute("uidSession");

			// Returning UserConnectedUidSession
			httpRequest.getSession(false).removeAttribute("uidSession");

			logger.trace("Connected UserConnectedUidSession is: " + userConnectedUidSession);
		}

		return userConnectedUidSession;
	}

	public String getPolicy(HttpServletRequest httpRequest) {
		String userPolicy = null;

		userPolicy = (String) httpRequest.getSession(false).getAttribute("policy");

		// Returning UserPosition
		httpRequest.getSession(false).removeAttribute("policy");

		logger.trace("Connected User's Policy is: " + userPolicy);
		return userPolicy;
	}

	public boolean getIsCertificate(HttpServletRequest httpRequest) {
		String userIsCertificate = null;
		boolean userBooleanIsCertificate;

		userIsCertificate = (String) httpRequest.getSession(false).getAttribute("isCertificate");

		userBooleanIsCertificate = userIsCertificate.equals("true");
		httpRequest.getSession(false).removeAttribute("isCertificate");

		logger.trace("Connected User's isCertificate is: " + userBooleanIsCertificate);
		return userBooleanIsCertificate;
	}

	public String getNif(HttpServletRequest httpRequest) {
		String userNif = null;

		userNif = (String) httpRequest.getSession(false).getAttribute("nif");

		// Returning UserNif
		httpRequest.getSession(false).removeAttribute("nif");

		logger.trace("Connected User's nif is: " + userNif);
		return userNif;
	}

	/* [END] Methods to recovery the credentials data */

	@Override
	public String getURLLogin(String originalURL, boolean ajax) {
		logger.debug("Original URLLogin is :" + originalURL);
		StringBuilder resultURL = new StringBuilder(StaticsContainer.loginUrl);

		if (originalURL != null && !"".equals(originalURL)) {
			resultURL.append(resultURL.indexOf("?")!=-1?"&":"?");
			resultURL.append("N38API=");
			resultURL.append(originalURL);
		}
		logger.debug("URLLogin is: " + resultURL);

		return resultURL.toString();
	}

	// Method not properly working due to N38 related issues
	@Override
	public void logout(HttpServletRequest httpRequest, HttpServletResponse httpResponse) {

		String uidSession = getUserConnectedUidSession(httpRequest);

		if (uidSession == null) {
			N38API n38Api = XlnetCore.getN38API(httpRequest);
			uidSession = XlnetCore.getParameterSession(n38Api, N38API.NOMBRE_N38UIDSESION);
		}

		logger.info("Proceeding to destroy uidSession: " + uidSession);

		N38APISesion n38ApiSesion = new N38APISesion();
		n38ApiSesion.n38APISesionDestruir(uidSession);

		// Cleaning the cookies of XLNets
		deleteAllXLNetsCookies(httpRequest, httpResponse);

		logger.info("XLNets Session " + uidSession + " destroyed!");

	}

	// Validates the N38API and, if is necessary, cleans the XLNets cookies
	protected boolean isN38ApiValid(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws SecurityException {

		Document xmlSesion = null;
		HttpSession httpSession = httpRequest.getSession(false);
		HashMap<String, String> userInfo = null;

		N38API n38Api = XlnetCore.getN38API(httpRequest);
		n38Api = XlnetCore.getN38API(httpRequest);

		if (n38Api != null) {
			logger.info("Validating the session of XLNets!");

			try {
				xmlSesion = XlnetCore.getN38ItemSesion(n38Api);

				if (XlnetCore.isXlnetSessionContainingErrors(xmlSesion)
						|| XlnetCore.isXlnetSessionContainingWarnings(xmlSesion)) {

					logger.info("The XLNET session is invalid");

					// Deleting security context data
					n38Api = null;
					xmlSesion = null;
					// deleteAllXLNetsCookies(httpRequest, httpResponse);
					logout(httpRequest, httpResponse);
					authenticationLogContextClean();

					return false;
				} else {
					logger.info("XLNET session is valid.");

					String n38uidOrg = n38Api.n38ItemSesion("n38uidOrg")[0];
					if (!n38uidOrg.equals("0")) {
						// User is in the XLNets's LDap
						userInfo = XlnetCore.getUserDataInfo(n38Api);
						httpSession.setAttribute("name", userInfo.get("name"));
						httpSession.setAttribute("surname", userInfo.get("surname"));
						httpSession.setAttribute("fullName", userInfo.get("fullName"));

					} else {
						// User isn't in the XLNets's LDap
						userInfo = XlnetCore.getN38SubjectCert(xmlSesion);
						httpSession.setAttribute("serialNumber", userInfo.get("SERIALNUMBER"));
						httpSession.setAttribute("name", userInfo.get("GIVENNAME"));
						httpSession.setAttribute("surname", userInfo.get("SURNAME"));
						// En caso de autentificarse mediante juego de barcos el
						// campo CN tendrÃ¡ el valor de la propiedad dni del xml
						// de sesiÃ³n de XLNets.
						httpSession.setAttribute("fullName", userInfo.get("CN"));
					}

					if (xlnetsDomain == null) {
						xlnetsDomain = XlnetCore.getN38DominioComunCookie(xmlSesion);
					}

					// Deleting security context data
					n38Api = null;
					xmlSesion = null;

					return true;
				}
			} catch (Exception e) {
				logger.error("isN38ApiValid(): There was an access error in XLNets. it Is possible that you having any problem with the configuration of XLNets or XLNets have some own internal error (Check that the service works correctly).", e);
				SecurityException sec = new SecurityException("isN38ApiValid(): There was an access error in XLNets. it Is possible that you having any problem with the configuration of XLNets or XLNets have some own internal error (Check that the service works correctly).", e.getCause());
				throw sec;
			}
		} else {
			deleteAllXLNetsCookies(httpRequest, httpResponse);
			return false;
		}
	}

	// Cleaner method unregister Authentication Configuration
	private void authenticationLogContextClean() {
		MDC.put(LogConstants.SESSION, "N/A");
		MDC.put(LogConstants.USER, "N/A");
		MDC.put(LogConstants.POSITION, "N/A");
	}

	// Cleaner method of SpringSecurity context
	private void springSecurityContextClean(HttpSession httpSession) {
		logger.info("XLNET session is invalid. Proceeding to clean the Security Context Holder.");
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

		if (authentication != null) {
			authentication.setAuthenticated(false);
		}
		SecurityContextHolder.clearContext();

		if (httpSession.getAttribute("SPRING_SECURITY_CONTEXT") != null) {
			httpSession.removeAttribute("SPRING_SECURITY_CONTEXT");
		}
	}

	// Delete all the security cookies of XLNets
	private void deleteAllXLNetsCookies(HttpServletRequest httpRequest, HttpServletResponse httpResponse) {

		if (xlnetsDomain != null) {
			Cookie requestCookies[] = httpRequest.getCookies();
			Cookie n38Cookie;

			if (requestCookies != null) {
				for (int i = 0; i < requestCookies.length; i++) {
					if (requestCookies[i].getName().split("n38").length > 1) {
						n38Cookie = requestCookies[i];
						n38Cookie.setDomain(xlnetsDomain);
						n38Cookie.setMaxAge(0);
						n38Cookie.setPath("/");
						httpResponse.addCookie(n38Cookie);
					}
				}
			}
		}
	}

	// Recovery the unique User Id
	private String getXlnetsUserId(HttpServletRequest httpRequest) {
		String udaXLNetsSessionId = XlnetCore.getN38ItemSesion(XlnetCore.getN38API(httpRequest), "n38UidSesion");

		if (udaXLNetsSessionId == null) {
			logger.debug("getXlnetsUserId: udaXlnetsSession value => null");
			return null;
		} else {
			logger.debug("getXlnetsUserId: udaXlnetsSession value => " + udaXLNetsSessionId);
			return udaXLNetsSessionId;
		}
	}

	// Recovery and storage of the Credential info of XLNets
	protected String loadXlnetsCredentialInfo(HttpServletRequest httpRequest, String xLNetsUserId) {

		N38API n38Api = XlnetCore.getN38API(httpRequest);
		HttpSession httpSession = httpRequest.getSession(false);
		Document xmlSecurityData = null;
		Vector<String> userProfiles = new Vector<String>();
		String UserName = null;
		String serialNumber = null;
		String policy;

		// Recovering general data of XLNets user credentials
		httpSession.setAttribute("nif", XlnetCore.getParameterSession(n38Api, N38API.NOMBRE_DNI));
		policy = XlnetCore.getParameterSession(n38Api, N38API.NOMBRE_N38CERTIFICADOPOLITICAS);
		httpSession.setAttribute("policy", policy);

		if (!(policy.toLowerCase().equals("no"))) {
			httpSession.setAttribute("isCertificate", "true");
		} else {
			httpSession.setAttribute("isCertificate", "false");
		}
		
		try {
			String n38uidOrg = n38Api.n38ItemSesion("n38uidOrg")[0];
			
			if (!n38uidOrg.equals("0")) {
				// User is in the XLNets's LDap
				UserName = XlnetCore.getParameterSession(n38Api, "n38personasuid");

				// Recovering XLNets user credentials
				httpSession.setAttribute("userName", UserName);
				httpSession.setAttribute("position", XlnetCore.getParameterSession(n38Api, N38API.NOMBRE_N38PUESTOUID));
				httpSession.setAttribute("uidSession", XlnetCore.getParameterSession(n38Api, N38API.NOMBRE_N38UIDSESION));
				httpSession.setAttribute("udaValidateSessionId", xLNetsUserId);

				// Getting user's profiles
				if (this.alternativeOriginCredentialsApp != null && this.alternativeOriginCredentialsApp.existAditionalsAppCodes(httpRequest)) {
					List<String> appCodes = this.alternativeOriginCredentialsApp.getAppCodes(httpRequest);
					Iterator<String> appCodesIterator = appCodes.iterator();
					String appCode;

					while (appCodesIterator.hasNext()) {
						appCode = appCodesIterator.next();
						xmlSecurityData = XlnetCore.getN38ItemSeguridad(n38Api, appCode);
						if (xmlSecurityData != null) {
							userProfiles.addAll(XlnetCore.searchParameterIntoXlnetSesion(xmlSecurityData, XlnetCore.PATH_SUBTIPO_N38INSTANCIA));
						}
					}
				}

				xmlSecurityData = XlnetCore.getN38ItemSeguridad(n38Api, StaticsContainer.webAppName);
				if (xmlSecurityData != null) {
					if (this.useXlnetProfiles){
						userProfiles.addAll(XlnetCore.searchParameterIntoXlnetSesion(XlnetCore.getN38ItemSesion(n38Api), XlnetCore.PATH_XMLSESION_N38PERFILES));
					}
					userProfiles.addAll(XlnetCore.searchParameterIntoXlnetSesion(xmlSecurityData, XlnetCore.PATH_SUBTIPO_N38INSTANCIA));
					
					if (this.alternativeStorageUserCredentials != null) {
						userProfiles.addAll(this.alternativeStorageUserCredentials.loadUserAuthorities(UserName,  XlnetCore.getParameterSession(n38Api, N38API.NOMBRE_DNI), n38Api));
					}
					
				}
				// Set obtain user's profiles
				httpSession.setAttribute("userProfiles", userProfiles);

			} else {
				// User isn't in the XLNets's LDap
				UserName = (String) httpSession.getAttribute("fullName");
				serialNumber = (String) httpSession.getAttribute("serialNumber");

				// Recovering user credentials
				httpSession.setAttribute("userName", UserName);
				httpSession.setAttribute("uidSession", httpSession.getId());
				httpSession.setAttribute("udaValidateSessionId", xLNetsUserId);

				Vector<String> userprofile = new Vector<String>();

				if (this.alternativeStorageUserCredentials == null) {
					userprofile.add(this.anonymousProfile.get("userProfiles"));
					httpSession.setAttribute("position", this.anonymousProfile.get("position"));
				} else {
					userprofile = this.alternativeStorageUserCredentials.loadUserAuthorities(UserName, serialNumber, n38Api);
					httpSession.setAttribute("position", this.alternativeStorageUserCredentials.loadUserPosition(UserName, serialNumber, n38Api));
				}

				// Deleting the serialNumber object
				httpSession.removeAttribute("serialNumber");

				httpSession.setAttribute("userProfiles", userprofile);
			}
		} catch (N38ParameterException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (N38Excepcion e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		httpSession.setAttribute("destroySessionSecuritySystem", this.destroySessionSecuritySystem);

		return UserName;
	}

	private synchronized void loadReloadData(HttpServletRequest httpRequest, Long currentThreadId) {
		HttpSession session = httpRequest.getSession(false);

		if (session != null && session.getAttribute("reloadData") == null) {
			logger.debug("loadReloadData: " + currentThreadId.toString());
			session.setAttribute("reloadData", currentThreadId);
		}
	}

	private synchronized boolean reloadData(HttpServletRequest httpRequest) {
		HttpSession httpSession = httpRequest.getSession(false);

		if (httpSession.getAttribute("credentialsLoading") == null && (System.currentTimeMillis() - Long.valueOf(httpSession.getAttribute("udaTimeStamp") + "")) > xlnetCachingPeriod.longValue()) {
			// Recharging the lifetime of the cache
			httpSession.removeAttribute("udaTimeStamp");
			httpSession.setAttribute("udaTimeStamp", System.currentTimeMillis());
			return true;
		} else {
			return false;
		}
	}

	// Getters & Setters
	public Long getXlnetCachingPeriod() {
		return TimeUnit.SECONDS.convert(this.xlnetCachingPeriod.longValue(), TimeUnit.MILLISECONDS);
	}

	public String getUserChangeUrl() {
		return this.userChangeUrl;
	}

	public UdaCustomJdbcDaoImpl getAlternativeStorageUserCredentials() {
		return this.alternativeStorageUserCredentials;
	}

	public HashMap<String, String> getAnonymousProfile() {
		return this.anonymousProfile;
	}

	public boolean getDestroySessionSecuritySystem() {
		return this.destroySessionSecuritySystem;
	}

	public ExcludeFilter getExcludeFilter() {
		return this.excludeFilter;
	}

	public Object getAlternativeOriginCredentialsApp() {
		return this.alternativeOriginCredentialsApp;
	}

	public Object getSpecificCredentials() {
		return this.specificCredentials;
	}

	public Credentials getCredentials() {
		if (specificCredentialsName == null) {
			return new UserCredentials();
		} else {
			try {
				return (Credentials) Class.forName(specificCredentialsName).getDeclaredConstructor().newInstance();
			} catch (Exception e) {
				logger.error("getCredentials(): The object specified to the parameter \"SpecificCredentials\" is not correct. The object has not been instantiated", e);
				SecurityException sec = new SecurityException("getCredentials(): The object specified to the parameter \"SpecificCredentials\" is not correct. The object has not been instantiated", e.getCause());
				throw sec;
			}
		}
	}

	public void setXlnetCachingPeriod(Long xlnetCachingPeriod) {
		this.xlnetCachingPeriod = TimeUnit.MILLISECONDS.convert(xlnetCachingPeriod.longValue(), TimeUnit.SECONDS);
	}

	public void setUserChangeUrl(String userChangeUrl) {
		this.userChangeUrl = userChangeUrl;
	}

	public void setAlternativeStorageUserCredentials(UdaCustomJdbcDaoImpl alternativeStorageUserCredentials) {
		if (alternativeStorageUserCredentials.getPositionByUserdataQuery() != null && alternativeStorageUserCredentials.getAuthoritiesByUserdataQuery() != null) {
			this.alternativeStorageUserCredentials = alternativeStorageUserCredentials;
		} else {
			// Not being a path to an xml file an exception is raised and does
			// not load
			UnsatisfiedDependencyException exc = new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "alternativeStorageUserCredentials", "The PositionByUserdataQuery parameter and the AuthoritiesByUserdataQuery parameter can't be nulls");
			logger.error("The PositionByUserdataQuery parameter and the AuthoritiesByUserdataQuery parameter can't be nulls.", exc);
			throw exc;
		}
	}

	public void setAnonymousCredentials(HashMap<String, String> anonymousProfile) {
		this.anonymousProfile = anonymousProfile;
	}

	public void setDestroySessionSecuritySystem(boolean destroySessionSecuritySystem) {
		this.destroySessionSecuritySystem = destroySessionSecuritySystem;
	}

	public void setExcludeFilter(ExcludeFilter excludeFilter) {
		this.excludeFilter = excludeFilter;
	}
	
	public boolean isUseXlnetProfiles() {
		return useXlnetProfiles;
	}

	public void setUseXlnetProfiles(boolean useXlnetProfiles) {
		this.useXlnetProfiles = useXlnetProfiles;
	}

	@SuppressWarnings("unchecked")
	public void setAlternativeOriginCredentialsApp(Object alternativeOriginCredentialsApp) {

		AlternativeOriginCredentialsApp alternativeOriginCredentialsAppObject;

		try {
			if (alternativeOriginCredentialsApp instanceof String) {
				alternativeOriginCredentialsAppObject = new AlternativeOriginCredentialsAppImp((String) alternativeOriginCredentialsApp);
			} else if (alternativeOriginCredentialsApp instanceof List<?>) {

				List<Object> validateAlternativeOriginCredentialsApp = (List<Object>) alternativeOriginCredentialsApp;

				for (Object o : validateAlternativeOriginCredentialsApp)
					if (!(o instanceof String))
						throw new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "alternativeOriginCredentialsApp", "The specified object is not correct to the parameter  \"alternativeOriginCredentialsApp\". The object must be instace of String, List <String> or AlternativeOriginCredentialsApp.");

				alternativeOriginCredentialsAppObject = new AlternativeOriginCredentialsAppImp((List<String>) alternativeOriginCredentialsApp);
			} else if (alternativeOriginCredentialsApp instanceof AlternativeOriginCredentialsApp) {
				alternativeOriginCredentialsAppObject = (AlternativeOriginCredentialsApp) alternativeOriginCredentialsApp;
			} else {
				throw new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "alternativeOriginCredentialsApp", "The specified object is not correct to the parameter  \"alternativeOriginCredentialsApp\". The object must be instace of String, List <String> or AlternativeOriginCredentialsApp.");
			}
		} catch (Exception e) {
			// As the specified object is not correct to the parameter
			// "alternativeOriginCredentialsApp", an exception is raised and the
			// application doesn't will deploy an exception is raised and does
			// not load
			UnsatisfiedDependencyException exc = new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "alternativeOriginCredentialsApp", "The specified object is not correct to the parameter  \"alternativeOriginCredentialsApp\". The object must be instace of String, List <String> or AlternativeOriginCredentialsApp.");
			logger.error("The specified object is not correct to the parameter  \"alternativeOriginCredentialsApp\". The object must be instace of String, List <String> or AlternativeOriginCredentialsApp.", exc);
			throw exc;
		}

		this.alternativeOriginCredentialsApp = alternativeOriginCredentialsAppObject;
	}

	public void setSpecificCredentials(Object credentials) {
		Object specificCredentials = credentials;

		try {
			if (specificCredentials instanceof String) {
				specificCredentials = Class.forName((String) credentials).getDeclaredConstructor().newInstance();
			}
			if (specificCredentials instanceof Credentials) {
				this.specificCredentialsName = specificCredentials.getClass().getName();
			} else {
				throw new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "setSpecificCredentials", "The specified object is not correct to the parameter  \"SpecificCredentials\". The object must be instace of String (className of a Class than extend the \"Credentials\" Class) or one Bean of a Class than extend the \"Credentials\" Class.");
			}
		} catch (Exception e) {
			throw new UnsatisfiedDependencyException("security-config", "PerimetralSecurityWrapperN38Impl", "setSpecificCredentials", "The specified object is not correct to the parameter  \"SpecificCredentials\". The object must be instace of String (className of a Class than extend the \"Credentials\" Class) or one Bean of a Class than extend the \"Credentials\" Class.");
		} finally {
			this.specificCredentials = specificCredentials;
		}
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/PerimetralSecurityWrapperOAMImpl.java
================================================
/*
 * Copyright 2022 E.J.I.E., S.A.
 *
 * Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
 * Solo podrá usarse esta obra si se respeta la Licencia.
 * Puede obtenerse una copia de la Licencia en
 *
 * http://ec.europa.eu/idabc/eupl.html
 *
 * Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
 * el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
 * SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
 * Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
 * que establece la Licencia.
 */
package com.ejie.x38.security;

import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.Collections;
import java.util.HashMap;
import java.util.Vector;

import javax.mail.internet.MimeUtility;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

/**
 * @author UDA
 */
public class PerimetralSecurityWrapperOAMImpl implements
        PerimetralSecurityWrapper {

    public static final String HTTP_NAME = "HTTP_NAME";
    public static final String HTTP_SURNAME = "HTTP_SURNAME";
    public static final String HTTP_FULLNAME = "HTTP_FULLNAME";
    public static final String HTTP_USERNAME = "HTTP_USERNAME";
    public static final String HTTP_NIF = "HTTP_NIF";
    public static final String HTTP_POSITION = "HTTP_POSITION";
    public static final String HTTP_GROUPS = "HTTP_GROUPS";
    public static final String HTTP_SESSION_ID = "HTTP_SESSION_ID";
    public static final String HTTP_LOGOUT = "HTTP_LOGOUT";
    private static final Logger logger = LoggerFactory
            .getLogger(PerimetralSecurityWrapperOAMImpl.class);
    private boolean destroySessionSecuritySystem = false;

    public PerimetralSecurityWrapperOAMImpl() {
    }

    public synchronized String validateSession(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
            throws SecurityException {

        // Setpoint of the User Session. if the session is not created, it will proceed to create it
        httpRequest.getSession(true);

        //Gets param OAM request
        String name = getOamName(httpRequest);
        String surname = getOamSurname(httpRequest);
        String fullname = getOamFullName(httpRequest);
        String username = getOamUsername(httpRequest);
        String nif = getOamNif(httpRequest);
        String position = getOamPosition(httpRequest);
        String groups = getOamGroups(httpRequest);

        if (name == null || surname == null || fullname == null || username == null || nif == null ||
                position == null || groups == null) {
            return "false";
        } else {
            return "true";
        }
    }

    /* Methods to recovery the credentials data */

    public String getUserConnectedUserName(HttpServletRequest httpRequest) {
        String userName = null;
        Authentication authentication = null;

        // Getting Authentication credentials
        authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication != null && authentication.getCredentials() != null) {
            userName = ((Credentials) authentication.getCredentials()).getUserName();
        } else {
            userName = getOamUsername(httpRequest);
        }

        logger.trace("Connected User's Name is: " + userName);
        return userName;
    }

    public HashMap<String, String> getUserDataInfo(HttpServletRequest httpRequest, boolean isCertificate) {
        // Returning UserDataInfo
        HashMap<String, String> userData = new HashMap<String, String>();

        userData.put("fullName", decodeOamHeader(httpRequest.getHeader(HTTP_FULLNAME)));
        userData.put("name", decodeOamHeader(httpRequest.getHeader(HTTP_NAME)));
        userData.put("surname", decodeOamHeader(httpRequest.getHeader(HTTP_SURNAME)));

        logger.trace("Connected User's data is: " + userData.toString());

        return userData;
    }

    public String getUserPosition(HttpServletRequest httpRequest) {
        String userPosition = null;
        Authentication authentication = null;

        // Getting Authentication credentials
        authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication != null && authentication.getCredentials() != null) {
            userPosition = ((Credentials) authentication.getCredentials()).getPosition();
        } else {
            userPosition = getOamPosition(httpRequest);
        }

        logger.trace("Connected User's Position is: " + userPosition);
        return userPosition;

    }

    public String getUdaValidateSessionId(HttpServletRequest httpRequest) {
        String udaValidateSessionId = null;

        udaValidateSessionId = (String) httpRequest.getSession(false).getAttribute("udaValidateSessionId");

        // Returning UdaValidateSessionId
        httpRequest.getSession(false).removeAttribute("udaValidateSessionId");

        logger.trace("Connected UserConnectedUidSession is: " + udaValidateSessionId);
        return udaValidateSessionId;
    }

    public Vector<String> getUserInstances(HttpServletRequest httpRequest) {
        Vector<String> userInstances = new Vector<String>();
        Authentication authentication = null;

        // Getting Authentication credentials
        authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication != null && authentication.getCredentials() != null) {
            userInstances = ((Credentials) authentication.getCredentials()).getUserProfiles();
        } else {
            //Bucle para oam.
            String groups = getOamGroups(httpRequest);
            String[] listaGroups = groups.split(":");
            Collections.addAll(userInstances, listaGroups);
        }

        // Returning UserInstances
        logger.trace("Connected UserConnectedUidSession is: " + userInstances);
        return userInstances;

    }

    public String getUserConnectedUidSession(HttpServletRequest httpRequest) {
        String userConnectedUidSession = null;
        Authentication authentication = null;

        // Getting Authentication credentials
        authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication != null && authentication.getCredentials() != null) {
            userConnectedUidSession = ((Credentials) authentication.getCredentials()).getUidSession();
        } else {
            userConnectedUidSession = decodeOamHeader(httpRequest.getHeader(HTTP_SESSION_ID));
        }

        // Si no puede resolver del OAM la cabecera es que algo está pasando con el proxy, mostramos warning
        if (StringUtils.isEmpty(userConnectedUidSession)) {
            logger.warn("The OAM data is not found in the request headers, we need to check that the OAM proxy is " +
                    "working correctly. It will keep retrying until it works or fails with a TOO_MANY_REDIRECTS.");
        }

        logger.trace("Connected UserConnectedUidSession is: " + userConnectedUidSession);
        return userConnectedUidSession;
    }

    public String getPolicy(HttpServletRequest httpRequest) {
        String userPolicy = null;

        userPolicy = (String) httpRequest.getSession(false).getAttribute("policy");

        // Returning UserPosition
        httpRequest.getSession(false).removeAttribute("policy");

        logger.trace("Connected User's Policy is: " + userPolicy);
        return userPolicy;
    }

    public boolean getIsCertificate(HttpServletRequest httpRequest) {
        String userIsCertificate = null;
        boolean userBooleanIsCertificate;

        userIsCertificate = (String) httpRequest.getSession(false).getAttribute("isCertificate");

        userBooleanIsCertificate = "true".equals(userIsCertificate);
        httpRequest.getSession(false).removeAttribute("isCertificate");

        logger.trace("Connected User's isCertificate is: " + userBooleanIsCertificate);
        return userBooleanIsCertificate;
    }

    public String getNif(HttpServletRequest httpRequest) {
        String userNif = null;
        Authentication authentication = null;

        // Getting Authentication credentials
        authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication != null && authentication.getCredentials() != null) {
            userNif = ((Credentials) authentication.getCredentials()).getNif();
        } else {
            userNif = getOamNif(httpRequest);
        }

        logger.trace("Connected User's nif is: " + userNif);
        return userNif;
    }

    /* [END] Methods to recovery the credentials data */

    /**
     * Método para obtener la URL para el sistema de Login, en OAM no es necesario porque
     * el proxy se mete de por medio, por lo tanto devolvemos directamente la URL original
     * a la que se intentaba acceder
     *
     * @param originalURL String con la url original
     * @param ajax        boolean indicando si es una xhr
     * @return String con la url al sistema de login
     */
    @Override
    public String getURLLogin(String originalURL, boolean ajax) {
        logger.debug("Original URLLogin is :" + originalURL);
        logger.debug("URLLogin is: " + originalURL);
        return originalURL;
    }

    /**
     * Método para realizar el borrado de cookies de OAM y las cabeceras de OAM de la request
     *
     * @param httpRequest  HttpServletRequest con la request
     * @param httpResponse HttpServletResponse con la response
     */
    @Override
    public void logout(HttpServletRequest httpRequest, HttpServletResponse httpResponse) {
        try {
            //Invalidate HTTP session
            HttpSession httpSession = httpRequest.getSession(false);
            if (httpSession != null) {
                //Cleaning the User Session of Weblogic
                try {
                    logger.info("Session " + httpSession.getId() + " invalidated!");
                    httpSession.invalidate();
                } catch (IllegalStateException e) {
                    logger.info("The user session isn't valid, it is not necessary delete it");
                }
            }

            httpResponse.sendRedirect(httpRequest.getHeader(HTTP_LOGOUT));
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public boolean getDestroySessionSecuritySystem() {
        return this.destroySessionSecuritySystem;
    }

    public void setDestroySessionSecuritySystem(boolean destroySessionSecuritySystem) {
        this.destroySessionSecuritySystem = destroySessionSecuritySystem;
    }

    public Credentials getCredentials() {
        return new UserCredentials();
    }

    /**
     * Internal method to retrieve the OAM groups
     *
     * @param httpRequest HttpServletRequest with the request
     * @return String with the groups
     */
    private String getOamGroups(HttpServletRequest httpRequest) {
        return decodeOamHeader(httpRequest.getHeader(HTTP_GROUPS));
    }

    /**
     * Internal method to collect the OAM position
     *
     * @param httpRequest HttpServletRequest with the request
     * @return String with the position
     */
    private String getOamPosition(HttpServletRequest httpRequest) {
        return decodeOamHeader(httpRequest.getHeader(HTTP_POSITION));
    }

    /**
     * Internal method to collect the NIF from OAM
     *
     * @param httpRequest HttpServletRequest with the request
     * @return String with the NIF
     */
    private String getOamNif(HttpServletRequest httpRequest) {
        return decodeOamHeader(httpRequest.getHeader(HTTP_NIF));
    }

    /**
     * Internal method to collect the OAM username
     *
     * @param httpRequest HttpServletRequest with the request
     * @return String with the username
     */
    private String getOamUsername(HttpServletRequest httpRequest) {
        return decodeOamHeader(httpRequest.getHeader(HTTP_USERNAME));
    }

    /**
     * Internal method to collect the fullname from OAM
     *
     * @param httpRequest HttpServletRequest with the request
     * @return String with the fullname
     */
    private String getOamFullName(HttpServletRequest httpRequest) {
        return decodeOamHeader(httpRequest.getHeader(HTTP_FULLNAME));
    }

    /**
     * Internal method to collect the surname from OAM
     *
     * @param httpRequest HttpServletRequest with the request
     * @return String with the surname
     */
    private String getOamSurname(HttpServletRequest httpRequest) {
        return decodeOamHeader(httpRequest.getHeader(HTTP_SURNAME));
    }

    /**
     * Internal method to retrieve the name from OAM
     *
     * @param httpRequest HttpServletRequest with the request
     * @return String with the name
     */
    private String getOamName(HttpServletRequest httpRequest) {
        return decodeOamHeader(httpRequest.getHeader(HTTP_NAME));
    }

    /**
     * Internal method to decode the header values inputted by OAM
     *
     * @param headerValue String with the header value
     * @return The decoded header value
     */
    private String decodeOamHeader(String headerValue) {
        try {
            if (StringUtils.isNotEmpty(headerValue)) {
                return "" + MimeUtility.decodeText(headerValue);
            } else {
                return "";
            }
        } catch (UnsupportedEncodingException e) {
            logger.error("Error decoding from OAM '" + headerValue + "'");
            throw new RuntimeException(e);
        }
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/PreAuthenticateProcessingFilter.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.io.IOException;
import java.nio.charset.Charset;

import javax.annotation.Resource;
import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.slf4j.MDC;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.preauth.AbstractPreAuthenticatedProcessingFilter;

import com.ejie.x38.log.LogConstants;
import com.ejie.x38.util.ThreadStorageManager;

/**
 * 
 * @author UDA
 *
 */
public  class PreAuthenticateProcessingFilter extends
		AbstractPreAuthenticatedProcessingFilter {

	@Resource
	private ReloadableResourceBundleMessageSource messageSource;
	
	private static final Logger logger = LoggerFactory
			.getLogger(PreAuthenticateProcessingFilter.class);

	//Semaphore for not concurrent access
//	protected StockUdaSecurityPadlocksImpl stockUdaSecurityPadlocks;
	private PerimetralSecurityWrapper perimetralSecurityWrapper;

	/**
	 * Try to authenticate a pre-authenticated user with Spring Security if the
	 * user has not yet been authenticated.
	 */
	@Override
	public void doFilter(ServletRequest request, ServletResponse response,
			FilterChain chain) throws IOException, ServletException {
		
		boolean isAjax = ((HttpServletRequest)request).getHeaders("X-Requested-With").hasMoreElements();
		logger.info("the request is entering in the security system");

		String valid = getPerimetralSecurityWrapper().validateSession((HttpServletRequest)request, (HttpServletResponse) response);

		if(valid.equals("true")){
			if ((!isAjax) || (((HttpServletRequest)request).getSession(false).getAttribute("userChange") == null)){
				super.doFilter(request, response, chain);
				logger.info("the request is exiting of the security system");
			} else {
				HttpSession httpSession = ((HttpServletRequest)request).getSession(false);

				//Delete security variables
				httpSession.removeAttribute("name");
				httpSession.removeAttribute("surname");
				httpSession.removeAttribute("fullName");
				httpSession.removeAttribute("userName");
				httpSession.removeAttribute("reloadData");
				httpSession.removeAttribute("uidSession");
				httpSession.removeAttribute("userChange");
				httpSession.removeAttribute("destroySessionSecuritySystem");

				String content = messageSource.getMessage("security.ajaxLoadError", null, LocaleContextHolder.getLocale());
				HttpServletResponse httpServletResponse = (HttpServletResponse) response;
				httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
				httpServletResponse.setContentLength(content.getBytes(Charset.forName(httpServletResponse.getCharacterEncoding())).length);
				httpServletResponse.getWriter().print(content);
				httpServletResponse.flushBuffer();
			}			
		
		} else if(valid.equals("false")) {
			chain.doFilter(request, response);
			logger.info("the request is exiting of the security system");
		} else {
			if(!isAjax){ 
				((HttpServletResponse) response).sendRedirect(valid);
				return;
			} else {
				String content = messageSource.getMessage("security.ajaxError", null, LocaleContextHolder.getLocale());
				HttpServletResponse httpServletResponse = (HttpServletResponse) response;
				httpServletResponse.setStatus(HttpServletResponse.SC_FORBIDDEN);
				httpServletResponse.setContentLength(content.getBytes(Charset.forName(httpServletResponse.getCharacterEncoding())).length);
				httpServletResponse.getWriter().print(content);
				httpServletResponse.flushBuffer();
			}
		}
	}
	

	@Override
	protected synchronized Object getPreAuthenticatedCredentials(HttpServletRequest request) {

		Credentials result = this.perimetralSecurityWrapper.getCredentials();
		
		try{ 
			//Load data's credential of user
			result.loadCredentialsData(this.perimetralSecurityWrapper, request);
			
			//Code associated to the security system of UDA. It is very important to operation of the internal gestion of the system.    
			MDC.put(LogConstants.SESSION,result.getUidSession());
			MDC.put(LogConstants.USER,result.getUserName());
			MDC.put(LogConstants.POSITION,result.getPosition());
			
		} finally {
//			stockUdaSecurityPadlocks.setAllowedAccessThread(request.getSession(false).getId(), null);
//			stockUdaSecurityPadlocks.release(request.getSession(false).getId());
			
			request.getSession(false).removeAttribute("credentialsLoading");
			//[END] Code associated to the security system of UDA.
		}

		return result;
	}

	@Override
	protected synchronized Object getPreAuthenticatedPrincipal(HttpServletRequest httpRequest) {
		String principalUser = null;
		HttpSession session = httpRequest.getSession(false);
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		
//		if(!stockUdaSecurityPadlocks.existingSecurityPadlock(session.getId())){
//			stockUdaSecurityPadlocks.createSecurityPadlock(session.getId(), null);
//		}
		
//		if (!stockUdaSecurityPadlocks.allowedAccess(session.getId(), ThreadStorageManager.getCurrentThreadId())){
//			try{
//				stockUdaSecurityPadlocks.acquire(session.getId());
//			} catch (InterruptedException e) {
//				throw new SecurityException("UDA's Security system error", e.getCause());
//			}
//		}
				
		if(isReloadData(httpRequest,ThreadStorageManager.getCurrentThreadId())){
			
			if(authentication != null){
				authentication.setAuthenticated(false);
			}
			
			//if the user changes then the user session is invalidate  
			if (session.getAttribute("userChange") == null){
				logger.info("The cache of user's credentials is expired. Proceeds to recharge the user's credentials");
				setInvalidateSessionOnPrincipalChange(false);
			
			} else {
				logger.info("The incoming user and the authenticated user are not equal. Proceed to load the new user's credentials");
				session.removeAttribute("userChange");
			}
			
			SecurityContextHolder.clearContext();
			return "##udaReloadUser##";
		} else {
//			if (stockUdaSecurityPadlocks.existingSecurityPadlock(session.getId()) && !stockUdaSecurityPadlocks.allowedAccess(session.getId(), ThreadStorageManager.getCurrentThreadId())){
//				stockUdaSecurityPadlocks.release(session.getId());
//			}
			setInvalidateSessionOnPrincipalChange(true);
		}
		
		principalUser = this.perimetralSecurityWrapper.getUserConnectedUserName(httpRequest);
		logger.info( "The incoming user is: "+principalUser);
		
		return principalUser;
	}
	
	private synchronized boolean isReloadData(HttpServletRequest httpRequest, Long currentThreadId){
		HttpSession session = httpRequest.getSession(false);
		Long reloadDataId = null;
		
		logger.debug("The value of reloadData session attribute is {}", session.getAttribute("reloadData"));
		
		try {
			reloadDataId = (Long) session.getAttribute("reloadData");
		} catch (ClassCastException classCastException) {
			try {
				reloadDataId = Long.parseLong(session.getAttribute("reloadData").toString());
			} catch (NumberFormatException numberFormatException) {
				return false;
			}
		}
		
		if(session != null && session.getAttribute("reloadData") != null && currentThreadId.equals(reloadDataId)){
//			if(httpRequest.getHeaders("X-Requested-With").hasMoreElements()){
//				stockUdaSecurityPadlocks.setAllowedAccessThread(session.getId(), ThreadStorageManager.getCurrentThreadId());
//			}
			session.setAttribute("credentialsLoading", "true");
			session.removeAttribute("reloadData");
			return true;
		} else {
			return false;
		}
	}
	
	// Getters & Setters
	public PerimetralSecurityWrapper getPerimetralSecurityWrapper() {
		return this.perimetralSecurityWrapper;
	}

	public void setPerimetralSecurityWrapper(PerimetralSecurityWrapper perimetralSecurityWrapper) {
		this.perimetralSecurityWrapper = perimetralSecurityWrapper;
	}
	
//	public StockUdaSecurityPadlocksImpl getStockUdaSecurityPadlocks() {
//		return this.stockUdaSecurityPadlocks;
//	}
//
//	public void setStockUdaSecurityPadlocks(StockUdaSecurityPadlocksImpl stockUdaSecurityPadlocks) {
//		this.stockUdaSecurityPadlocks = stockUdaSecurityPadlocks;
//	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/StockUdaSecurityPadlocks.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;


/**
 * 
 * @author UDA
 *
 */
public interface StockUdaSecurityPadlocks {
	
	   public void createSecurityPadlock(String sessionId, Long allowedAccessThread);
	   
	   public void createSecurityPadlock(String sessionId, Long allowedAccessThread, int semaphoreLimit);
	   
	   public Long getAllowedAccessThread(String sessionId);
	   
	   public void setAllowedAccessThread(String sessionId, Long accessThread);
	   
	   public boolean existingSecurityPadlock(String sessionId);
	   
	   public boolean allowedAccess(String sessionId, Long accessThread) throws NullPointerException;
	   
	   public void acquire(String sessionId) throws NullPointerException, InterruptedException;
	   
	   public void release(String sessionId) throws NullPointerException;
	   
	   public boolean tryAcquire(String sessionId) throws NullPointerException;
	   
	   public void deleteCredentialLoadObject(String sessionId);
}
 

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/StockUdaSecurityPadlocksImpl.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.HashMap;

/**
 * 
 * @author UDA
 *
 */
public class StockUdaSecurityPadlocksImpl implements StockUdaSecurityPadlocks{
	
	   private final HashMap<String, UdaSecurityPadlock> SecurityPadlocks = new HashMap<String, UdaSecurityPadlock>();
	   
	   // Create fuctions
	   public synchronized void  createSecurityPadlock(String sessionId, Long allowedAccessThread){
		   this.SecurityPadlocks.put(getBaseSessionId(sessionId), new UdaSecurityPadlock(allowedAccessThread));
	   } 
	   
	   public synchronized void createSecurityPadlock(String sessionId, Long allowedAccessThread, int semaphoreLimit){
		   
		   this.SecurityPadlocks.put(getBaseSessionId(sessionId), new UdaSecurityPadlock(allowedAccessThread, semaphoreLimit));
	   }
	   
	   // Modify values
	   public Long getAllowedAccessThread(String sessionId){
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
		   if (udaSecurityPadlock != null){
			   return udaSecurityPadlock.getAllowedAccessThread(); 
		   } else {
			   return null;
		   }
	   }
	   
	   public void setAllowedAccessThread(String sessionId, Long accessThread){
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
		   if (udaSecurityPadlock != null){
			   udaSecurityPadlock.setAllowedAccessThread(accessThread); 
		   } else {
			   createSecurityPadlock(sessionId, accessThread); 
		   }
		   
	   }
	   
	   //Control functions
	   public boolean existingSecurityPadlock(String sessionId){
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
		   if (udaSecurityPadlock != null){
			   return true;
		   } else {
			   return false;
		   }
	   }
	   
	   public boolean allowedAccess(String sessionId, Long accessThread) throws NullPointerException{
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
		   if (udaSecurityPadlock != null){
			   return udaSecurityPadlock.allowedAccess(accessThread);
		   } else {
			   return false;
		   }
			   
	   }
	   
	   public void acquire(String sessionId) throws NullPointerException, InterruptedException{
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
		   if (udaSecurityPadlock != null){
			   udaSecurityPadlock.acquire();
		   } else {
			   throw new NullPointerException("The session id don't have a correlation in the object. It need a previous creation.");
		   }
	   }
	   
	   public void release(String sessionId) throws NullPointerException{
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
		   if (udaSecurityPadlock != null){
			   udaSecurityPadlock.release();
		   } else {
			   throw new NullPointerException("The session id don't have a correlation in the object. It need a previous creation.");
		   }
	   }
	   
	   public boolean tryAcquire(String sessionId) throws NullPointerException{
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
		   if (udaSecurityPadlock != null){
			   return udaSecurityPadlock.tryAcquire();
		   } else {
			   throw new NullPointerException("The session id don't have a correlation in the object. It need a previous creation.");
		   }
	   }
	   
	   // Functions to control the Session's garbage
	   public void deleteCredentialLoadObject(String sessionId){
		   UdaSecurityPadlock udaSecurityPadlock = this.SecurityPadlocks.get(getBaseSessionId(sessionId));
			if (udaSecurityPadlock != null){
				udaSecurityPadlock.freeAllThreads();
				this.SecurityPadlocks.remove(getBaseSessionId(sessionId));
			}
		}
	   
	   private String getBaseSessionId(String sessionId){
		   String[] baseSessionId = sessionId.split("!"); 
		   return baseSessionId[0];
		   
	   }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/UdaAuthenticationProvider.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.core.Ordered;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.AuthenticationUserDetailsService;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
import org.springframework.util.Assert;

/**
 * 
 * @author UDA
 *
 */
public class UdaAuthenticationProvider implements AuthenticationProvider,
		Ordered, InitializingBean {
	private static final Logger logger = LoggerFactory
			.getLogger(UdaAuthenticationProvider.class);

	private AuthenticationUserDetailsService<Authentication> myAuthenticatedUserDetailsService;
	private boolean throwExceptionWhenTokenRejected = false;
	private int order = -1; // default: same as non-ordered
	private static UserCredentials cleanUserCredentials = new UserCredentials(); 

	/**
	 * Authenticate the given PreAuthenticatedAuthenticationToken.
	 * If the principal contained in the authentication object is null, the
	 * request will be ignored to allow other providers to authenticate it.
	 */
	public Authentication authenticate(Authentication authentication)
			throws AuthenticationException {
		if (authentication != null) {
			logger.debug("authentication: "+ authentication.toString());
		} else {
			logger.debug("authentication is NULL!");
		}

		if (!supports(authentication.getClass())) {
			logger.trace("Authentication class [" + authentication.getClass() + "] isn't supported");
			return null;
		}
		logger.trace("Authentication class [" + authentication.getClass()+ "] is supported.");

		final Object principal = authentication.getPrincipal();
		if ( principal == null ||
				(principal instanceof String && StringUtils.isEmpty((String) principal))) {
			logger.trace("No pre-authenticated principal found in request.");
			if (throwExceptionWhenTokenRejected) {
				throw new BadCredentialsException(
						"No pre-authenticated principal found in request.");
			}
			return null;
		}

		if (authentication.getCredentials() == null) {
			logger.trace("No pre-authenticated credentials found in request.");

			if (throwExceptionWhenTokenRejected) {
				throw new BadCredentialsException(
						"No pre-authenticated credentials found in request.");
			}
			return null;
		}

		UserDetails userDetails = myAuthenticatedUserDetailsService
				.loadUserDetails(authentication);

		PreAuthenticatedAuthenticationToken result = new PreAuthenticatedAuthenticationToken(
				principal, authentication.getCredentials(),
				userDetails.getAuthorities());

		result.setDetails(authentication.getDetails());

		return result;
	}

	/**
	 * Indicate that this provider only supports
	 * PreAuthenticatedAuthenticationToken (sub)classes.
	 * 
	 */
	@SuppressWarnings("rawtypes")
	public boolean supports(Class authentication) {
		return PreAuthenticatedAuthenticationToken.class
				.isAssignableFrom(authentication);
	}

	public int getOrder() {
		return order;
	}

	public void setOrder(int i) {
		order = i;
	}

	@Override
	public void afterPropertiesSet() throws Exception {
		Assert.notNull(myAuthenticatedUserDetailsService,
				"An AuthenticationUserDetailsService must be set");
	}

	/**
	 * If true, causes the provider to throw a BadCredentialsException if the
	 * presented authentication request is invalid (contains a null principal or
	 * credentials). Otherwise it will just return null. Defaults to false.
	 */
	public void setThrowExceptionWhenTokenRejected(
			boolean throwExceptionWhenTokenRejected) {
		this.throwExceptionWhenTokenRejected = throwExceptionWhenTokenRejected;
	}

	/**
	 * Set the AuthenticatedUserDetailsServices to be used.
	 * 
	 */
	public void setMyAuthenticatedUserDetailsService(
			AuthenticationUserDetailsService<Authentication> myAuthenticatedUserDetailsService) {
		this.myAuthenticatedUserDetailsService = myAuthenticatedUserDetailsService;
	}
	
	/**
	 * Get the credentials object of the current user.
	 * 
	 */
	public Credentials getUserCredentials() {
		Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
		if(authentication != null && authentication.getCredentials() != null){
			return (Credentials)authentication.getCredentials();
		} else {
			return cleanUserCredentials;
		}	
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/UdaCustomJdbcDaoImpl.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.Vector;

import n38c.exe.N38API;

import org.springframework.security.core.userdetails.jdbc.JdbcDaoImpl;


/**
 * 
 * @author UDA
 *
 */
public abstract class UdaCustomJdbcDaoImpl extends JdbcDaoImpl {
	
	private String positionByUserdataQuery = null;
	private String authoritiesByUserdataQuery = null;
	
	public UdaCustomJdbcDaoImpl(){
		super();
	}
		
	abstract protected String loadUserPosition(String userName, String dni, N38API n38Api);
	
	abstract protected Vector<String> loadUserAuthorities(String userName, String dni, N38API n38Api);
	
	
	//Getters & Setters
	
	protected String getPositionByUserdataQuery() {
		return this.positionByUserdataQuery;
	}
		
	public void setPositionByUserdataQuery(String positionByUserdataQuery)
	{
		this.positionByUserdataQuery = positionByUserdataQuery;
	}	
	
	protected String getAuthoritiesByUserdataQuery() {
		return this.authoritiesByUserdataQuery;
	}
		
	public void setAuthoritiesByUserdataQuery(String authoritiesByUserdataQuery)
	{
		this.authoritiesByUserdataQuery = authoritiesByUserdataQuery;
	}	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/UdaSecurityPadlock.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.concurrent.Semaphore;


/**
 * 
 * @author UDA
 *
 */
 
 public class UdaSecurityPadlock {
	 
   private Semaphore credentialLoad;
   private Long allowedAccessThread; 

   protected UdaSecurityPadlock(Long allowedAccessThread){
	   this.allowedAccessThread = allowedAccessThread;
	   this.credentialLoad = new Semaphore(1,true);
   } 
   
   protected UdaSecurityPadlock(Long allowedAccessThread, int semaphoreLimit){
	   this.allowedAccessThread = allowedAccessThread;
	   this.credentialLoad = new Semaphore(semaphoreLimit,true);
   } 
   
   //Getters & Setters
   protected Long getAllowedAccessThread(){
	   return this.allowedAccessThread;
   }
   
   protected void setAllowedAccessThread(Long accessThread){
	   this.allowedAccessThread = accessThread;
   }
   
   //Control functions
   protected boolean allowedAccess(Long accessThread){
	   return this.allowedAccessThread == accessThread;
   }
   
   protected void acquire() throws InterruptedException{
	   this.credentialLoad.acquire();
   }
   
   protected void freeAllThreads(){
	   this.credentialLoad.release(this.credentialLoad.getQueueLength());
   }
   
   protected void release(){
	   this.credentialLoad.release();
   }
   
   protected boolean tryAcquire(){
   		return (this.credentialLoad.tryAcquire());
   }
 }



================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/UserCredentials.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Vector;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.beanutils.DynaBean;
import org.apache.commons.beanutils.LazyDynaBean;
import org.apache.commons.beanutils.MutableDynaClass;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ejie.x38.util.Constants;

/**
 * 
 * @author UDA
 *
 */
public class UserCredentials implements Credentials {

	private static final long serialVersionUID = 1L;
	
	private static final Logger logger = LoggerFactory
	.getLogger(UserCredentials.class);
	
	private String nif = null;
	private String policy = null;
	private String userName = "NULL";
	private String name = "NULL";
	private String surname = "NULL";
	private String fullName = "NULL";
	private String position = "NULL";
	private String uidSession = null;
	private boolean isCertificate = false;
	private String udaValidateSessionId = null;
	private Vector<String> userProfiles = null;
	private boolean destroySessionSecuritySystem = false;
	private DynaBean subjectCert = null;
	private ArrayList<String> userDataProperties = null;
	
	//Constructor functions
	public UserCredentials(){
		super();
	}

	public UserCredentials(Vector<String> userProfiles, String userName, HashMap<String,String> userData, String nif,
			String uidSession, String position, String udaValidateSessionId, String policy, boolean isCertificate, boolean destroySessionSecuritySystem) {
		
		super();
		
		this.nif = nif;
		this.userName = userName;
		this.uidSession = uidSession;
		this.position = position;
		this.udaValidateSessionId = udaValidateSessionId;
		this.userProfiles = userProfiles;
		this.isCertificate = isCertificate;
		this.policy = policy;
		this.destroySessionSecuritySystem = destroySessionSecuritySystem;
		
		dinamicSubjectCertLoad(userData);
	}
	
	public UserCredentials(Vector<String> userProfiles, String userName, String name, String surname, String fullName, String nif,
			String uidSession, String position, String udaValidateSessionId, String policy, boolean isCertificate, boolean destroySessionSecuritySystem) {
		super();
		this.nif = nif;
		this.userName = userName;
		this.name = name;
		this.surname = surname;
		this.fullName = fullName;
		this.uidSession = uidSession;
		this.position = position;
		this.udaValidateSessionId = udaValidateSessionId;
		this.userProfiles = userProfiles;
		this.isCertificate = isCertificate;
		this.policy = policy;
		this.destroySessionSecuritySystem = destroySessionSecuritySystem;
	}
	
	public UserCredentials(Vector<String> userProfiles, String userName, String nif,
			String uidSession, String position, String udaValidateSessionId, String policy, boolean isCertificate) {
		super();
		this.nif = nif;
		this.userName = userName;
		this.uidSession = uidSession;
		this.position = position;
		this.udaValidateSessionId = udaValidateSessionId;
		this.userProfiles = userProfiles;
		this.isCertificate = isCertificate;
		this.policy = policy;
	}

	//Getters & Setters
	public String getNif() {
		return this.nif;
	}

	public void setNif(String nif) {
		this.nif = nif;
	}
	
	public String getPolicy() {
		return this.policy;
	}

	public void setPolicy(String policy) {
		this.policy = policy;
	}

	public String getUserName() {
		return userName;
	}

	public void setUserName(String userName) {
		this.userName = userName;
	}
	
	public String getFullName() {
		return fullName;
	}

	public void setfullName(String fullName) {
		this.fullName = fullName;
	}
	
	public String getSurname() {
		return surname;
	}

	public void setSurname(String surname) {
		this.surname = surname;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getPosition() {
		return position;
	}
	
	public void setPosition(String position) {
		this.position = position;
	}
	
	public String getUidSession() {
		return uidSession;
	}

	public void setUidSession(String uidSession) {
		this.uidSession = uidSession;
	}
	
	public boolean getIsCertificate() {
		return this.isCertificate;
	}

	public void setIsCertificate(boolean isCertificate) {
		this.isCertificate = isCertificate;
	}
	
	public String getUdaValidateSessionId() {
		return udaValidateSessionId;
	}

	public void setUdaValidateSessionId(String udaXLNetsSessionId) {
		this.udaValidateSessionId = udaXLNetsSessionId;
	}
	
	public Vector<String> getUserProfiles() {
		return userProfiles;
	}

	public void setUserProfiles(Vector<String> userProfiles) {
		this.userProfiles = userProfiles;
	}
	
	public boolean getDestroySessionSecuritySystem() {
		return this.destroySessionSecuritySystem;
	}

	public void setDestroySessionSecuritySystem(boolean destroySessionSecuritySystem) {
		this.destroySessionSecuritySystem = destroySessionSecuritySystem;
	}
	
	public ArrayList<String> getUserDataProperties(){
		return this.userDataProperties;
	}
		
	//Functions of Data gestion
	public String toString() {

		StringBuffer strBuffer = new StringBuffer();

		strBuffer.append("UserCredentials [");
		strBuffer.append("userName=").append(userName).append(";");
		
		if(nif != null){
			strBuffer.append("nif=").append("Object NOT NULL (info protected)").append(";");
		} else {
			strBuffer.append("nif=").append("NULL").append(";");
		}
		
		strBuffer.append("name=").append(name).append(";");
		strBuffer.append("surName=").append(surname).append(";");
		strBuffer.append("fullName=").append(fullName).append(";");
		
		if(uidSession != null){
			strBuffer.append("uidSession=").append("Object NOT NULL (info protected)").append(";");
		} else {
			strBuffer.append("uidSession=").append("NULL").append(";");
		}
		
		strBuffer.append("position=").append(position).append(";");
		
		if(udaValidateSessionId != null){
			strBuffer.append("udaXLNetsSessionId=").append("Object NOT NULL (info protected)").append(";");
		} else {
			strBuffer.append("udaXLNetsSessionId=").append("NULL").append(";");
		}
		
		if (userProfiles != null){
			if (userProfiles.size() > 0){
				strBuffer.append("userProfiles=").append("Object NOT NULL. Its size is ").append(userProfiles.size()).append(" (info protected)").append(";");
			} else {
				strBuffer.append("userProfiles=").append("The user doesn't have permissions").append(";");
			}
		} else {
			strBuffer.append("userProfiles=").append("NULL").append(";");
		}
		
		if(isCertificate){
			strBuffer.append("isCertificate=").append("true").append(";");
		} else {
			strBuffer.append("isCertificate=").append("false").append(";");
		}
		
		if(policy != null){
			strBuffer.append("policy=").append("Object NOT NULL (info protected)").append(";");
		} else {
			strBuffer.append("policy=").append("NULL").append(";");
		}
		
		if(destroySessionSecuritySystem){
			strBuffer.append("destroySessionSecuritySystem=").append("true").append(";");
		} else {
			strBuffer.append("destroySessionSecuritySystem=").append("false").append(";");
		}
		
		if (this.subjectCert != null){
			strBuffer.append("subjectCertData=");
			String property;
			strBuffer.append("{");
			for(int i=0; i < this.userDataProperties.size(); i++){
				property = this.userDataProperties.get(i);
				strBuffer.append(property);
				strBuffer.append(":");
				strBuffer.append(getSubjectCert(property));
				if(i < this.userDataProperties.size()-1){
					strBuffer.append(", ");
				}
			}
			strBuffer.append("}");
		}
		
		strBuffer.append("]");

		return strBuffer.toString();
	}
	
	public void loadCredentialsData(PerimetralSecurityWrapper perimetralSecurityWrapper, HttpServletRequest request){
		this.uidSession = perimetralSecurityWrapper.getUserConnectedUidSession(request);
		this.userName = perimetralSecurityWrapper.getUserConnectedUserName(request);
		this.position = perimetralSecurityWrapper.getUserPosition(request);
		this.userProfiles = perimetralSecurityWrapper.getUserInstances(request);
		this.udaValidateSessionId = perimetralSecurityWrapper.getUdaValidateSessionId(request);
		this.policy = perimetralSecurityWrapper.getPolicy(request);
		this.isCertificate = perimetralSecurityWrapper.getIsCertificate(request);
		this.nif = perimetralSecurityWrapper.getNif(request);
		this.destroySessionSecuritySystem = perimetralSecurityWrapper.getDestroySessionSecuritySystem();
		
		dinamicSubjectCertLoad(perimetralSecurityWrapper.getUserDataInfo(request, this.isCertificate));
		
		afterCredentialsCreation(perimetralSecurityWrapper, request);
		
		logger.info( "The incoming user's Credentials are loading. The data of its credentials is: [uidSession = "+uidSession+" ] [userName = "+userName+" ] [position = "+position+"]");
	}
	
	private void dinamicSubjectCertLoad(HashMap<String, String> userData){
		
		this.name = userData.get("name");
		this.surname = userData.get("surname");
		this.fullName = userData.get("fullName");
		
		userData.remove("name");
		userData.remove("surname");
		userData.remove("fullName");
		
		try{
			
			if(isCertificate){
				// extract and save the subjectCert's info  
				Iterator<Map.Entry<String, String>> userDataIterator = userData.entrySet().iterator();
				Map.Entry<String, String> userDataEntry;
				this.userDataProperties = new ArrayList<String>();
				this.subjectCert = new LazyDynaBean();
				MutableDynaClass subjectCertClass = (MutableDynaClass)this.subjectCert.getDynaClass();
				
				// create the subjectCert's properties
				while (userDataIterator.hasNext()) {
					userDataEntry = userDataIterator.next();
					this.userDataProperties.add(userDataEntry.getKey());
					subjectCertClass.add(userDataEntry.getKey(), String.class);
				}
			
			    // set its properties
			    userDataIterator = userData.entrySet().iterator();
			    
			    while (userDataIterator.hasNext()) {
					userDataEntry = userDataIterator.next();
					this.subjectCert.set(userDataEntry.getKey(), userDataEntry.getValue());
				}
			}
		} catch (Exception exc) {
			logger.error("It was Produced a error in the subjectCert's info load. All gets of subjectCert will be empties (\"\")", exc);
			this.subjectCert = null;
		}
		
	    userData = null;
	}
	
	//Adaptation method for applications
	protected void afterCredentialsCreation(PerimetralSecurityWrapper perimetralSecurityWrapper, HttpServletRequest request){}
	
	//Functions to manage the SubjectCert's data  
	public boolean containsSubjectCert(String id){
		if(!id.equals("")){
			for(int i=0; i < this.userDataProperties.size(); i++){
				if (this.userDataProperties.get(i).equals(id)){
					return true;
				}
			}
		}
		return false;
	}
	
	private void deleteUserDataProperties(String id){
		if(!id.equals("")){
			for(int i=0; i < this.userDataProperties.size(); i++){
				if (this.userDataProperties.get(i).equals(id)){
					this.userDataProperties.remove(i);
				}
			}
		}
	}
	
	public String getSubjectCert(String data){
		if (this.subjectCert != null){
			if(containsSubjectCert(data)){
				return (String)this.subjectCert.get(data);
			} else {
				return Constants.DATA_NOT_APPLICABLE;
			}
		} else {
			return "";
		}
	}
	
	public void setSubjectCert(String property, String value){
		if (this.subjectCert != null){
			if(!containsSubjectCert(property)){
				MutableDynaClass subjectCertClass = (MutableDynaClass)this.subjectCert.getDynaClass();
				subjectCertClass.add(property, String.class);
				this.userDataProperties.add(property);
			}
			this.subjectCert.set(property, value);
		} 
	}
	
	public void deleteSubjectCert(String property){
		if (this.subjectCert != null){
			if(containsSubjectCert(property)){
				deleteUserDataProperties(property);
				MutableDynaClass subjectCertClass = (MutableDynaClass)this.subjectCert.getDynaClass();
				subjectCertClass.remove(property);
			} 
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/XlnetCore.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import java.util.HashMap;
import java.util.Vector;

import javax.naming.InvalidNameException;
import javax.naming.ldap.LdapName;
import javax.naming.ldap.Rdn;
import javax.servlet.http.HttpServletRequest;
import javax.xml.transform.TransformerException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.Document;
import org.w3c.dom.Node;

import com.ejie.x38.util.StackTraceManager;
import com.ejie.x38.util.XmlManager;

import n38c.exe.N38API;
import n38i.exe.N38DocumentPrinter;
import n38i.exe.N38Excepcion;
import n38i.exe.N38ParameterException;

/**
 * 
 * @author UDA
 *
 */
public class XlnetCore {

	private static final Logger logger =  LoggerFactory.getLogger(XlnetCore.class);

	public static final String PATH_SUBTIPO_N38INSTANCIA = "/n38/elementos/elemento/elemento/elemento/parametro[@id='n38uidobjseguridad']/valor";
	public static final String PATH_SUBTIPO_N38SESION = "/n38/elementos/elemento[@subtipo='N38Sesion']/parametro[@id='?']/valor";
	public static final String PATH_SUBTIPO_N38DOMINIOCOMUNCOOKIE = "/n38/elementos/elemento[@subtipo='N38Sesion']/parametro[@id='n38dominiocomuncookie']/valor";
	public static final String PATH_SUBTIPO_N38SUBJECTCERT = "/n38/elementos/elemento[@subtipo='N38Sesion']/parametro[@id='n38subjectcert']/valor";
	public static final String PATH_SUBTIPO_DNI = "/n38/elementos/elemento[@subtipo='N38Sesion']/parametro[@id='dni']/valor";
	public static final String PATH_SUBTIPO_N38PERSONAUID = "n38/elementos/elemento[@subtipo='N38Sesion']/parametro[@id='n38personauid']/valor";
	public static final String PATH_SUBTIPO_ORGANIZATIONALUNIT = "/n38/elementos/elemento[@subtipo='OrganizationalUnit']/parametro[@id='ou']/valor[text()='?']/../../elemento[@subtipo=\"n38itemSeguridad\"]/parametro[@id=\"n38uidobjseguridad\"]/valor";
	public static final String PATH_CHECK_ERROR = "/n38/error";
	public static final String PATH_CHECK_WARNING = "/n38/warning";
	public static final String FILTRO_LDAP_UID = "uid=";
	public static final String PATH_PUESTOUID_SUBTIPO_SN = "/n38/elementos/elemento[@subtipo='n38persona']/parametro[@id='sn']/valor";
	public static final String PATH_PUESTOUID_SUBTIPO_CN = "/n38/elementos/elemento[@subtipo='n38persona']/parametro[@id='cn']/valor";
	public static final String PATH_PUESTOUID_SUBTIPO_GIVENNAME = "/n38/elementos/elemento[@subtipo='n38persona']/parametro[@id='givenname']/valor";
	public static final String PATH_XMLSESION_N38PERFILES = "/n38/elementos/elemento[@subtipo='N38Sesion']/parametro[@id='n38perfiles']/valor";

	/**
	 * Devuelve un objeto N38API a partir del contexto de una petición Request.
	 * Si la request es inválida se propaga una excepción.
	 * 
	 * @param httpRequest
	 *            La request que lleva la validación XLNET.
	 * @return Un objeto N38API con información sobre la sesión XLNET.
	 */
	public static N38API getN38API(HttpServletRequest httpRequest) {
		N38API n38apiRetorno = null;
		if (httpRequest == null)
			throw new IllegalArgumentException(
					"getN38API(): The HttpServletRequest input parameter can't be NULL.");
		n38apiRetorno = new N38API(httpRequest);
		return n38apiRetorno;
	}

	public static Document getN38ItemSesion(N38API n38api) {
		Document documentReturn = null;
		if (n38api == null)
			throw new IllegalArgumentException(
					"getN38ItemSesion(): The N38API input parameter can't be NULL.");

		documentReturn = n38api.n38ItemSesion();
		if (documentReturn != null) {
			logger.trace("N38ItemSesion is: "+ N38DocumentPrinter.print(documentReturn));
		}

		return documentReturn;
	}
	
	public static String getN38ItemSesion(N38API n38api, String parametro) {
		if (n38api == null)
			throw new IllegalArgumentException(
					"getN38ItemSesion(): The N38API input parameter can't be NULL.");
		
		try {
			String[] n38UidSesion = n38api.n38ItemSesion(parametro);
			if (n38UidSesion != null && n38UidSesion.length > 0) {
				logger.trace("N38ItemSesion is: "+ n38UidSesion[0]);
				return n38UidSesion[0];
			}
		} catch (N38ParameterException e) {
			logger.error(StackTraceManager.getStackTrace(e));
		} catch (N38Excepcion e) {
			logger.error("There is no XLNetS session or current has expired (error code {})", e.getCodigo());
		}
		
		return null;
	}

	public static Document getN38ItemSeguridad(N38API n38api, String idItemSeguridad) {
		if (n38api != null) logger.trace("N38API is: "+n38api);
		logger.trace("idItemSeguridad is: "+idItemSeguridad);
		
		Document documentReturn = null;
		if (n38api == null)
			throw new IllegalArgumentException(
					"getN38ItemSeguridad(): The N38API input parameter can't be NULL.");

		documentReturn = n38api.n38ItemSeguridad(idItemSeguridad);

		if (documentReturn != null) {
			logger.trace("N38ItemSeguridad is: "+ N38DocumentPrinter.print(documentReturn));
		}

		return documentReturn;
	}

	public static boolean isXlnetSessionContainingErrors(Document xmlSesion) {
		if (xmlSesion != null)
			logger.trace("XmlSesion is: "+xmlSesion.getTextContent());

		if (xmlSesion == null)
			throw new IllegalArgumentException(
					"isXlnetSessionContainingErrors(): The Document input parameter can't be NULL.");

		boolean bResultado = false;
		try {
			if (XmlManager.searchDomNode(xmlSesion, PATH_CHECK_ERROR) != null) {
				bResultado = true;
				logger.debug("XmlSesion contains errors: "+xmlSesion.getTextContent());
			}else{
				logger.debug("XmlSesion does not contain errors: "+xmlSesion.getTextContent());
			}
		} catch (TransformerException e) {
			logger.error("isXlnetSessionContainingErrors(): XML searching error: "+ StackTraceManager.getStackTrace(e));
			bResultado = true;
		}
		return bResultado;
	}

	public static boolean isXlnetSessionContainingWarnings(Document xmlSesion) {
		if (xmlSesion == null)
			throw new IllegalArgumentException(
					"isXlnetSessionContainingErrors(): The Document input parameter can't be NULL.");

		boolean bResultado = false;
		try {
			if (XmlManager.searchDomNode(xmlSesion, PATH_CHECK_WARNING) != null) {
				bResultado = true;
				logger.debug("XmlSesion contains warnings: "+xmlSesion.getTextContent());
			}else{
				logger.debug("XmlSesion is not containing warnings: "+xmlSesion.getTextContent());
			}
		} catch (TransformerException e) {
			logger.error("isXlnetSessionContainingWarnings(): XML searching error: "+ e.getMessage());
			bResultado = true;
		}

		return bResultado;
	}
	
	public static String getN38DominioComunCookie(Document xmlSesion) {
		
		Node n38DominioComunCookieNode; 
		
		if (xmlSesion != null)
			logger.trace("XmlSesion is: "+xmlSesion.getTextContent());

		if (xmlSesion == null)
			throw new IllegalArgumentException(
					"isXlnetSessionContainingErrors(): The Document input parameter can't be NULL.");

		try {
			
			n38DominioComunCookieNode = XmlManager.searchDomNode(xmlSesion, PATH_SUBTIPO_N38DOMINIOCOMUNCOOKIE);
			return n38DominioComunCookieNode.getFirstChild().getNodeValue();
			
		} catch (TransformerException e) {
			logger.error("isXlnetSessionContainingErrors(): XML searching error: "+ StackTraceManager.getStackTrace(e));
			return null; 
		}
	}
	
	/**
	 * Método para tratar el atributo n38SubjectCert del xml de sesión
	 * Cuando la autenticación se hace con certificado el atributo se informa con el subject del mismo
	 * Si la autenticación se hace con juego de barcos de izenpe -no hay certificado- 
	 * el atributo tiene un literal informativo   
	 * 
	 *  @return Mapa de los atributos del certificado. Si no hay, el CN se informa con DNI de sesión o literal informativo
	 *  
	 * */
	public static HashMap<String, String> getN38SubjectCert(Document xmlSesion) {

		HashMap<String, String> certinfo = null;
		String n38SubjectCert;
		String dni;

		if (xmlSesion != null) {
			logger.trace("XmlSesion is: " + xmlSesion.getTextContent());
		} else {
			throw new IllegalArgumentException(
					"isXlnetSessionContainingErrors(): The Document input parameter can't be NULL.");
		}

		certinfo = new HashMap<String, String>();
		try {
			n38SubjectCert = (XmlManager.searchDomNode(xmlSesion, PATH_SUBTIPO_N38SUBJECTCERT)).getFirstChild()
					.getNodeValue();
			dni = (XmlManager.searchDomNode(xmlSesion, XlnetCore.PATH_SUBTIPO_DNI)).getFirstChild().getNodeValue();
		} catch (TransformerException transfEx) {
			logger.error("getN38SubjectCert(): XML searching error: " + StackTraceManager.getStackTrace(transfEx));
			return null;
		}

		try {
			LdapName ln;
			ln = new LdapName(n38SubjectCert);
			for (Rdn rdn : ln.getRdns()) {
				certinfo.put(rdn.getType(), rdn.getValue().toString());
			}
		} catch (InvalidNameException e) {
			if (dni != null) {
				certinfo.put("CN", dni);
			} else {
				certinfo.put("CN", n38SubjectCert);
			}

		} catch (Exception e) {
			logger.error("getN38SubjectCert(): XML Read and Parser error: " + StackTraceManager.getStackTrace(e));
			return null;
		}
		return certinfo;
	}

	public static Vector<String> searchParameterIntoXlnetSesion(Document xmlSesion, String searchUrl) {
		if (xmlSesion == null)
			throw new IllegalArgumentException(
					"isXlnetSessionContainingErrors(): The Document input parameter can't be NULL.");

		if (searchUrl == null || searchUrl.equals(""))
			throw new IllegalArgumentException(
					"isXlnetSessionContainingErrors(): The String searchUrl input parameter can't be NULL.");

		Vector<String> resultVector = null;

		try {
			resultVector = XmlManager.searchDomVector(xmlSesion, searchUrl);
		} catch (TransformerException e) {
			logger.error("Could not find ["+searchUrl+"] in Document ["+xmlSesion.getTextContent()+"]. Error is: "+ e.getMessage());
			resultVector = null;
		}

		if (resultVector != null) logger.trace("Search ["+searchUrl+"] in Document ["+xmlSesion.getTextContent()+"] obtained results: ["+ resultVector.toString() + "]");
		else logger.trace("Search ["+searchUrl+"] in Document ["+xmlSesion.getTextContent()+"] obtained NO results!");

		return resultVector;
	}
	
	public static String getParameterSession(N38API n38Api, String param){
		String[] result = null;
		
		if (n38Api == null)
			throw new IllegalArgumentException(
					"getN38ItemSeguridad(): The N38API input parameter can't be NULL.");
		
		try {
			result = n38Api.n38ItemSesion(param);
		} catch (N38ParameterException e) {
			logger.error(StackTraceManager.getStackTrace(e));
		} catch (N38Excepcion e) {
			logger.error(StackTraceManager.getStackTrace(e));
		}	
		if(result!=null && result.length>0){
			return result[0];
		}else{
			return null;
		}
	}
	
	public static HashMap<String, String> getUserDataInfo(N38API n38Api){
		HashMap<String, String> result = new HashMap<String, String>();
		
		String n38personauidString;
		Document xmlPersona;
		Document n38ItemSesion;
		
		if (n38Api == null)
			throw new IllegalArgumentException(
					"getN38ItemSeguridad(): The N38API input parameter can't be NULL.");
		
		n38ItemSesion = n38Api.n38ItemSesion();
		
		try {
			n38personauidString = XmlManager.searchDomNode(n38ItemSesion, XlnetCore.PATH_SUBTIPO_N38PERSONAUID).getFirstChild().getNodeValue();
			
		} catch (TransformerException e) {
			logger.error("isXlnetSessionContainingErrors(): XML searching error: "+ StackTraceManager.getStackTrace(e));
			return null; 
		}	
		
		xmlPersona = n38Api.n38ItemObtenerPersonas(FILTRO_LDAP_UID+n38personauidString);
		
		try {
			result.put("name",XmlManager.searchDomNode(xmlPersona, PATH_PUESTOUID_SUBTIPO_GIVENNAME).getFirstChild().getNodeValue());
			result.put("surname",XmlManager.searchDomNode(xmlPersona, PATH_PUESTOUID_SUBTIPO_SN).getFirstChild().getNodeValue());
			result.put("fullName", XmlManager.searchDomNode(xmlPersona, PATH_PUESTOUID_SUBTIPO_CN).getFirstChild().getNodeValue()); 
			
		} catch (TransformerException e) {
			logger.error("isXlnetSessionContainingErrors(): XML searching error: "+ StackTraceManager.getStackTrace(e));
			return null; 
		}			

		return result;
	}	
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/security/XlnetGrantedAuthority.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.security;

import org.springframework.security.core.GrantedAuthority;

/**
 * 
 * @author UDA
 *
 */
public class XlnetGrantedAuthority implements GrantedAuthority {

	private static final long serialVersionUID = 1L;
	private String authority;

	public XlnetGrantedAuthority(String authority) {
		super();
		this.authority = authority;
	}

	@Override
	public String getAuthority() {
		return authority;
	}

	public int compareTo(Object paramT) {
		// final int BEFORE = -1;
		final int EQUAL = 0;
		final int AFTER = 1;

		if (paramT.getClass().isInstance("java.lang.String")) {
			String sParamT = (String) paramT;
			if (sParamT.equals(this.authority))
				return EQUAL;
		}
		return AFTER;
	}

	@Override
	public boolean equals(Object paramT) {
		final boolean EQUAL = true;
		final boolean NOTEQUAL = false;

		if (paramT.toString().equals(this.authority))
			return EQUAL;
		else
			return NOTEQUAL;
	}

	public String toString() {
		return authority;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/CustomSerializer.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.io.IOException;
import java.util.Map.Entry;



import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;

/**
 * Serializador que permite serializar unicamente determinadas propiedades del
 * objeto a procesar. Las propiedades a serializar se especifican enviandose en
 * un mapa de propiedades del thread.
 * 
 * @author UDA
 * 
 */
public class CustomSerializer extends JsonSerializer<Object> {

	protected final Logger logger =  LoggerFactory.getLogger(CustomSerializer.class);

	/**
	 * Realiza la serializacion del objeto pasado por parametro. Se escriben
	 * unicamente en el JSON resultante las propiedades del bean indicadas en el
	 * mapa de parametros almacenado en el thread.
	 * 
	 * @param obj
	 *            Objeto a serializar.
	 * @param jgen
	 *            Clase que define la API publica para escribir contenido JSON.
	 * @param provider
	 *            Proporciona la API para obtener serializadores para serializar
	 *            instancias de tipos especificos.
	 * @throws IOException
	 *             Al producirse un error al escribir contenido JSON.
	 * @throws JsonProcessingException
	 *             Al producirse un error al escribir contenido JSON.
	 */
	@Override
	public void serialize(Object obj, JsonGenerator jgen,
			SerializerProvider provider) throws IOException,
			JsonProcessingException {
		logger.debug("CustomSerializer.serialize()");

		// Se crea un BeanWrapper a partir del objeto a serializar
		BeanWrapper beanWrapper = new BeanWrapperImpl(obj);

		// Inicio del objeto JSON
		jgen.writeStartObject();
		
		// Se recorren las propiedades almacenadas en el mapa del thread
		for (Entry<?, ?> entry : ThreadSafeCache.getMap().entrySet()) {
            
			// Obtenemos el nombre de la propiedad
            String propertyName = (String) entry.getValue();
            
            // Comprobamos si la propiedad existe en el bean y es accesible para lectura
            if(beanWrapper.isReadableProperty(propertyName)){
            	
            	// Se obtiene el valor de la propiedad del bean
            	Object propertyValue = beanWrapper.getPropertyValue(propertyName);
            	
            	// Se escribe en el JSON el key 
            	jgen.writeFieldName((String) entry.getKey());
            
            	// Se escribe en el JSON el value 
				if (propertyValue==null){
					jgen.writeString("");
				}else{
					jgen.writeObject(propertyValue);
				}
            }
		}
		
		// Fin del objeto JSON
		jgen.writeEndObject();
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonBigDecimalDeserializer.java
================================================
package com.ejie.x38.serialization;

import java.io.IOException;
import java.math.BigDecimal;

import org.springframework.context.i18n.LocaleContextHolder;

import com.ejie.x38.util.ObjectConversionManager;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;

public class JsonBigDecimalDeserializer extends JsonDeserializer<BigDecimal>{

	@Override
	public BigDecimal deserialize(JsonParser jsonParser, DeserializationContext ctx)
			throws IOException, JsonProcessingException {
				
			String formatted = jsonParser.getText();
			
			if(LocaleContextHolder.getLocale().getLanguage() == "eu") {
				formatted = formatted.replace(",", "&PUNTO&").replace(".", ",").replace("&PUNTO&", ".");
			}
			
			return ObjectConversionManager.stringToBigDecimal(formatted, LocaleContextHolder.getLocale());
		
	}
	
	
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonBigDecimalSerializer.java
================================================
package com.ejie.x38.serialization;

import java.io.IOException;
import java.math.BigDecimal;

import org.springframework.context.i18n.LocaleContextHolder;

import com.ejie.x38.util.ObjectConversionManager;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;



public class JsonBigDecimalSerializer extends JsonSerializer<BigDecimal> {

	/**
	 *
	 * @param number
	 *            BigDecimal
	 * @param jsonGenerator
	 *            JsonGenerator
	 * @param paramSerializerProvider
	 *            SerializerProvider
	 * @throws IOException
	 *             e
	 * @throws JsonProcessingException
	 *             e
	 *
	 */
	@Override
	public void serialize(BigDecimal number, JsonGenerator jsonGenerator, SerializerProvider paramSerializerProvider)
			throws IOException, JsonProcessingException {
		if(LocaleContextHolder.getLocale().getLanguage() == "eu") {
			String numberStr = ObjectConversionManager.bigDecimalToString(number, number.stripTrailingZeros().scale(), LocaleContextHolder.getLocale());
			numberStr = numberStr.replace(",", "&PUNTO&").replace(".",",").replace("&PUNTO&",".");
			jsonGenerator.writeString(numberStr);			
		} else {
			jsonGenerator.writeString(ObjectConversionManager.bigDecimalToString(number, number.stripTrailingZeros().scale(), LocaleContextHolder.getLocale()));
		}
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonDateDeserializer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Component;

import com.ejie.x38.util.DateTimeManager;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;

/**
 * 
 * Used to serialize Java.util.Date, which is not a common JSON type, so we have
 * to create a custom serialize method;.
 * 
 * @author UDA
 * 
 */
@Component
public class JsonDateDeserializer extends JsonDeserializer<Date> {

	@Override
	public Date deserialize(JsonParser par, DeserializationContext ctx) throws IOException, JsonProcessingException {
		try {
			Locale locale = LocaleContextHolder.getLocale();
			SimpleDateFormat format = DateTimeManager.getDateTimeFormat(locale);

			String dateText = par.getText();

			if (dateText == null || "".equals(dateText)) {
				return null;
			}

			return format.parse(dateText);
		} catch (ParseException e) {
			throw new JsonParseException(par, "JsonDateDeserializer.deserialize", e);
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonDateSerializer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;




import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Component;

import com.ejie.x38.util.DateTimeManager;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;

/**
 * 
 * Used to serialize Java.util.Date, which is not a common JSON
 * type, so we have to create a custom serialize method;.
 *
 * @author UDA
 * 
 */
@Component
public class JsonDateSerializer extends JsonSerializer<Date>{

	@Override
	public void serialize(Date date, JsonGenerator gen, SerializerProvider provider)
			throws IOException, JsonProcessingException {

		Locale locale = LocaleContextHolder.getLocale();

		SimpleDateFormat dateFormat = DateTimeManager.getDateTimeFormat(locale);
		
		String formattedDate = dateFormat.format(date);

		gen.writeString(formattedDate);
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonDateTimeDeserializer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.io.IOException;
import java.sql.Timestamp;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Component;

import com.ejie.x38.util.DateTimeManager;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;

/**
 * 
 * Used to serialize Java.util.Date, which is not a common JSON type, so we have
 * to create a custom serialize method;.
 * 
 * @author UDA
 * 
 */
@Component
public class JsonDateTimeDeserializer extends JsonDeserializer<Timestamp> {

	@Override
	public Timestamp deserialize(JsonParser par, DeserializationContext ctx)
	        throws IOException, JsonProcessingException {
		try {
			Locale locale = LocaleContextHolder.getLocale();
			SimpleDateFormat format = DateTimeManager.getTimestampFormat(locale);

			String dateText = par.getText();

			if (dateText == null || "".equals(dateText)) {
				return null;
			}

			Date date = format.parse(dateText);
			return new Timestamp(date.getTime());
		} catch (ParseException e) {
			throw new JsonParseException(par, "JsonDateTimeDeserializer.deserialize", e);
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonDateTimeSerializer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Component;

import com.ejie.x38.util.DateTimeManager;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;


/**
 * 
 * Used to serialize Java.util.Date, which is not a common JSON
 * type, so we have to create a custom serialize method;.
 *
 * @author UDA
 * 
 */
@Component
public class JsonDateTimeSerializer extends JsonSerializer<Date>{

	@Override
	public void serialize(Date date, JsonGenerator gen, SerializerProvider provider)
			throws IOException, JsonProcessingException {

		Locale locale = LocaleContextHolder.getLocale();

		SimpleDateFormat dateFormat = DateTimeManager.getTimestampFormat(locale);
		
		String formattedDate = dateFormat.format(date);

		gen.writeString(formattedDate);
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonNumberDeserializer.java
================================================
package com.ejie.x38.serialization;

import java.io.IOException;
import java.math.BigDecimal;
import java.text.NumberFormat;
import java.text.ParseException;

import org.springframework.context.i18n.LocaleContextHolder;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;

public class JsonNumberDeserializer extends JsonDeserializer<BigDecimal> {

	@Override
	public BigDecimal deserialize(JsonParser jsonParser, DeserializationContext ctx)
	        throws IOException, JsonProcessingException {
		try {
			NumberFormat numberFormatter = NumberFormat.getInstance(LocaleContextHolder.getLocale());
			String numberText = jsonParser.getText();

			if (numberText == null || "".equals(numberText)) {
				return null;
			}
			
			if(LocaleContextHolder.getLocale().getLanguage() == "eu") {
				numberText = numberText.replace(",", "&PUNTO&").replace(".", ",").replace("&PUNTO&", ".");
			}

			return new BigDecimal(numberFormatter.parse(numberText).doubleValue());
		} catch (ParseException e) {
			throw new JsonParseException(jsonParser, "JsonNumberDeserializer.deserialize", e);
		}
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonNumberSerializer.java
================================================
package com.ejie.x38.serialization;

import java.io.IOException;
import java.math.BigDecimal;
import java.math.RoundingMode;
import java.text.NumberFormat;

import org.springframework.context.i18n.LocaleContextHolder;

import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;


public class JsonNumberSerializer extends JsonSerializer<BigDecimal> {

	@Override
	public void serialize(BigDecimal number, JsonGenerator jsonGenerator,
			SerializerProvider paramSerializerProvider) throws IOException,
			JsonProcessingException {
		
		NumberFormat numberFormatter = NumberFormat.getInstance(LocaleContextHolder.getLocale());
		
		String formatted = numberFormatter.format(number);
		
		if(LocaleContextHolder.getLocale().getLanguage() == "eu") {
			formatted = formatted.replace(",", "&PUNTO&").replace(".", ",").replace("&PUNTO&", ".");
		}
		
		jsonGenerator.writeString(formatted);
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonTimeDeserializer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.io.IOException;
import java.sql.Timestamp;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Component;

import com.ejie.x38.util.DateTimeManager;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;

/**
 * 
 * Used to serialize Java.util.Date, which is not a common JSON type, so we have
 * to create a custom serialize method;.
 * 
 * @author UDA
 * 
 */
@Component
public class JsonTimeDeserializer extends JsonDeserializer<Timestamp> {

	@Override
	public Timestamp deserialize(JsonParser par, DeserializationContext ctx)
	        throws IOException, JsonProcessingException {
		try {
			Locale locale = LocaleContextHolder.getLocale();
			SimpleDateFormat format = DateTimeManager.getTimeFormat(locale);

			String dateText = par.getText();

			if (dateText == null || "".equals(dateText)) {
				return null;
			}

			Date date = format.parse(dateText);
			return new Timestamp(date.getTime());
		} catch (ParseException e) {
			throw new JsonParseException(par, "JsonTimeDeserializer.deserialize", e);
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/JsonTimeSerializer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;




import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Component;

import com.ejie.x38.util.DateTimeManager;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.SerializerProvider;


/**
 * 
 * Used to serialize Java.util.Date, which is not a common JSON
 * type, so we have to create a custom serialize method;.
 *
 * @author UDA
 * 
 */
@Component
public class JsonTimeSerializer extends JsonSerializer<Date>{

	@Override
	public void serialize(Date date, JsonGenerator gen, SerializerProvider provider)
			throws IOException, JsonProcessingException {

		Locale locale = LocaleContextHolder.getLocale();

		SimpleDateFormat dateFormat = DateTimeManager.getTimeFormat(locale);
		
		String formattedDate = dateFormat.format(date);

		gen.writeString(formattedDate);
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/MultiModelDeserializer.java
================================================
/*
 * Copyright 2011 E.J.I.E., S.A.
 *
 * Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
 * Solo podrá usarse esta obra si se respeta la Licencia.
 * Puede obtenerse una copia de la Licencia en
 *
 * http://ec.europa.eu/idabc/eupl.html
 *
 * Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
 * el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
 * SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
 * Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
 * que establece la Licencia.
 */
package com.ejie.x38.serialization;

import java.io.IOException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ejie.x38.util.StackTraceManager;
import com.fasterxml.jackson.core.JsonFactory;
import com.fasterxml.jackson.core.JsonParser;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.DeserializationContext;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.MappingJsonFactory;

/**
 * Deserializador de Jackson que permite la deserializacion de multiples
 * entidades enviadas en un mismo JSON.<br>
 * 
 * El deserializador recibe un JSON que contiene la representacion de las
 * entidades que se deben deserializar junto a una propiedad que contiene la
 * informacion necesaria para llevar a cabo el mapeo. <br>
 * 
 * Esta informacion consiste en la correlacion entre las propiedades del JSON y
 * de las clases Java. El nombre de esta propiedad sera rupEntityMapping.<br>
 * 
 * Este es un ejemplo de un JSON que contiene varias entidades:<br>
 * <br>
 * 
 * <pre>
 * 
 *  {
 * 	usuario:{
 *  		id:"1",nombre:"nombre_usuario",apellido1:"apellido_usuario"
 * 	},
 * 	localidad:{
 * 		code:"1",descEs:"descripcion_cast",descEu:"descripcion_eusk"
 * 	},
 * 	rupEntityMapping:{
 * 		"usuario":"com.ejie.x21a.model.Usuario",
 * 		"localidad":"com.ejie.x21a.model.Localidad"
 *  }
 * }
 * 
 * </pre>
 * 
 * @author UDA
 * 
 */
public class MultiModelDeserializer extends
		JsonDeserializer<Map<String, Object>> {

	protected final Logger logger = LoggerFactory
			.getLogger(MultiModelDeserializer.class);

	/**
	 * Realiza la deserializacion del JSON
	 * 
	 * @param jsonParser
	 *            JsonParser que contiene el objeto JSON a deserializar y
	 *            proporciona los metodos necesarios para su tratamiento.
	 * @param deserializationContext
	 *            DeserializationContext.
	 * @return Map<String, Object> Mapa que contiene los model deserializados.
	 * @throws IOException
	 *             Al producirse un error en el acceso a los datos del JSON.
	 * @throws JsonProcessingException
	 *             Al producirse un error al procesar el JSON.
	 */
	@Override
	public Map<String, Object> deserialize(JsonParser jsonParser,
			DeserializationContext deserializationContext) throws IOException {

		// Creamos una JonFactory que nos permitira el procesado de los objetos JSON 
		JsonFactory jsonFactory = new MappingJsonFactory();
		// Mapa de retorno en el que se van a almacenar los beans
		Map<String, Object> mapaRetorno = new HashMap<String, Object>();
		// Se obtiene una representacion en arbol del json a procesar  
		JsonNode jsonNodeTree = jsonParser.readValueAsTree();
		// Recuperamos el objeto rupMultiModelMappings que define el mapeo de las entidades del json
		JsonNode rupMultiModelMappingsNode = jsonNodeTree.get("rupEntityMapping");
		// Recorremos todas las propiedades del json
		Iterator<Entry<String, JsonNode>> fields = jsonNodeTree.fields();
		while(fields.hasNext()){
			// Procesamos cada propiedad del json
			Entry<String, JsonNode> next = fields.next();
			// Recuperamos el nombre de la propiedad
			String propertyName = next.getKey();
			// Comprobamos que la propiedad corresponde con una de las entidades para las que se ha definido un mapeo
			if (rupMultiModelMappingsNode != null && rupMultiModelMappingsNode.has(propertyName)){
				// Obtenemos el nombre de la clase Java a la que se debe de mapear la propiedad
				String beanType = rupMultiModelMappingsNode.get(propertyName).asText();
				// Creamos un nuevo jsonParser para procesar el json correspondiente a la entidad que se debe mapear
				try (JsonParser entityJsonParser = jsonFactory.createParser(next.getValue().toString());) {
					// Se procesa el objeto json y se obtiene la instancia de la entidad correspondiente.
					Object	obj = entityJsonParser.readValueAs(Class.forName(beanType));
					// Se anyade la entidad en el mapa de retorno
					mapaRetorno.put(propertyName, obj);
				} catch (ClassNotFoundException cnfe) {
					// En caso de producirse un error en el procesado del json se lanza una excepcion
					logger.error(StackTraceManager.getStackTrace(cnfe));
				}
				
			}
		}
		// Se retorna el mapa de retorno que contiene las entidades mapeadas a partir del json procesado.
		return mapaRetorno;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/ThreadSafeCache.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.util.HashMap;
import java.util.Map;

/**
 * 
 * @author UDA
 *
 */
public class ThreadSafeCache {
	
    private static ThreadLocal<Map<String, String>> map = 
        new ThreadLocal<Map<String, String>> () {
            @Override protected Map<String, String> initialValue() {
                return new HashMap<String, String>();
        }
    };

    public static void addValue(String k, String v) {
    	map.get().put(k, v);
    }
    
    public static Map<?, ?> getMap(){
    	return (Map<?, ?>) map.get();
    }
    
    public static void clearCurrentThreadCache(){
    	map.remove();
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/UdaMappingJackson2HttpMessageConverter.java
================================================
/*
 * Copyright 2011 E.J.I.E., S.A.
 *
 * Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
 * Solo podrá usarse esta obra si se respeta la Licencia.
 * Puede obtenerse una copia de la Licencia en
 *
 * http://ec.europa.eu/idabc/eupl.html
 *
 * Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
 * el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
 * SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
 * Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
 * que establece la Licencia.
 */
package com.ejie.x38.serialization;

import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.Charset;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;

import com.ejie.x38.util.StackTraceManager;
import com.fasterxml.jackson.annotation.JsonInclude.Include;
import com.fasterxml.jackson.core.JsonEncoding;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;

/**
 * 
 * Sobreescritura de MappingJacksonHttpMessageConverter que permite leer y
 * escribir objetos JSON mediante el ObjectMapper de Jackson.
 * 
 * Gestiona el uso del ObjectMapper por defecto de Jackson o el personalizado
 * por UDA de acuerdo a las propiedades almacenadas en el thread mediante el
 * Filtro de UDA.
 * 
 * El ObjectMapper personalizado de UDA permite:
 * 
 * - Determinar las propiedades a serializar a partir de la informacion
 * almacenada en la propiedad RUP del thread.
 * 
 * - Deserializar multiples entidades enviadas en un unico objeto JSON.
 * 
 * @author UDA
 * 
 */
public class UdaMappingJackson2HttpMessageConverter extends
		MappingJackson2HttpMessageConverter {

	protected final Logger logger = LoggerFactory
			.getLogger(UdaMappingJackson2HttpMessageConverter.class);

	/**
	 * ObjectMapper personalizado de UDA.
	 */
	private ObjectMapper udaObjectMapper = new ObjectMapper();

	/**
	 * UdaModule utilizado para configurar el ObjectMapper personalizado.
	 */
	private UdaModule udaModule;
	
	/**
	 * Inicializa los componentes necesarios una vez instanciada la clase. En
	 * concreto configura el ObjectMapper personalizado mediante el UdaModule.
	 */
	@PostConstruct
	public void initialize() {
		if (udaModule != null) {
			udaObjectMapper.registerModule(udaModule);
		
			// Se realiza la configuracion del serializador
			if (udaModule.getSerializationFeature()!=null){
				for (SerializationFeature feature : udaModule.getSerializationFeature().keySet()) {
					if (udaModule.getSerializationFeature().get(feature)){
						udaObjectMapper.enable(feature);
						this.getObjectMapper().enable(feature);
					
					}else{
						udaObjectMapper.disable(feature);
						this.getObjectMapper().disable(feature);
					}
				}
			}
			
			// Se realiza la configuracion del deserializador
			if (udaModule.getDeserializationFeature()!=null){
				for (DeserializationFeature feature : udaModule.getDeserializationFeature().keySet()) {
					if (this.udaModule.getDeserializationFeature().get(feature)){
						udaObjectMapper.enable(feature);
						this.getObjectMapper().enable(feature);
						
					}else{
						udaObjectMapper.disable(feature);
						this.getObjectMapper().disable(feature);
					}
				}
			}
			
			// Se realiza la configuracion de las inclusion
			if (udaModule.getSerializationInclusions()!=null){
				for (Include inclusion : udaModule.getSerializationInclusions()) {
					udaObjectMapper.setSerializationInclusion(inclusion);
					this.getObjectMapper().setSerializationInclusion(inclusion);
				}
			}
		}
		
	}

	@Override
	protected void writeInternal(Object object, Type type, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException {
		if (!ThreadSafeCache.getMap().isEmpty() && ThreadSafeCache.getMap().keySet().contains("RUP")) {
			this.writeInternal(object, outputMessage);
		} else {
			super.writeInternal(object, type, outputMessage);
		}
		
	}
	
	@Override
	protected void writeInternal(Object object, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException {
		JsonEncoding encoding = getEncoding(outputMessage.getHeaders().getContentType());
		JsonGenerator jsonGenerator = udaObjectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding);
		try {
			if (!ThreadSafeCache.getMap().isEmpty() && ThreadSafeCache.getMap().keySet().contains("RUP")) {
				logger.info("UDA's Serialization Mechanism is being triggered.");
				udaObjectMapper.writeValue(jsonGenerator, object);
			} else {
				logger.info("Spring's Default Object Mapper searialization is being triggered.");
				super.writeInternal(object, outputMessage);
			}
		} catch (Exception ex) {
			logger.error(StackTraceManager.getStackTrace(ex));
			throw new HttpMessageNotWritableException("Could not write JSON: " + ex.getMessage(), ex);
		}
	}

	@Override
	protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException {

		try {
			if (!ThreadSafeCache.getMap().isEmpty()
					&& ThreadSafeCache.getMap().keySet()
							.contains("RUP_MULTI_ENTITY")) {
				logger.info("UDA's MultiBean deserialization Mechanism is being triggered.");
				return this.udaObjectMapper.readValue(inputMessage.getBody(),
						clazz);
			} else {
				logger.info("Spring's Default Object Mapper deserialization is being triggered.");
				return super.readInternal(clazz, inputMessage);
			}
		} catch (Exception ex) {
			logger.error(StackTraceManager.getStackTrace(ex));
			throw new HttpMessageNotReadableException(
					"Could not deserialize JSON: " + ex.getMessage(), ex);
		}
	}

	private JsonEncoding getEncoding(MediaType contentType) {
		if (contentType != null && contentType.getCharset() != null) {
			Charset charset = contentType.getCharset();
			for (JsonEncoding encoding : JsonEncoding.values()) {
				if (charset.name().equals(encoding.getJavaName())) {
					return encoding;
				}
			}
		}
		return JsonEncoding.UTF8;
	}

	public void setUdaObjectMapper(ObjectMapper udaObjectMapper) {
		this.udaObjectMapper = udaObjectMapper;
	}

	public ObjectMapper getUdaObjectMapper() {
		return this.udaObjectMapper;
	}

	public void setUdaModule(UdaModule udaModule) {
		this.udaModule = udaModule;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/serialization/UdaModule.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.serialization;

import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.annotation.PostConstruct;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.Version;
import com.fasterxml.jackson.databind.DeserializationFeature;
import com.fasterxml.jackson.databind.JsonDeserializer;
import com.fasterxml.jackson.databind.JsonSerializer;
import com.fasterxml.jackson.databind.MapperFeature;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.fasterxml.jackson.databind.module.SimpleModule; 


/**
 * Modulo de Jackson para extender las funcionalidades que proporciona por defecto.
 * 
 * @author UDA
 *
 */
public class UdaModule extends SimpleModule {
	private static final long serialVersionUID = 1L;

	/**
	 * Nombre identificador del modulo.
	 */
	private static final String NAME = "UdaModule";
	
	/**
	 * Version del modulo.
	 */
	private static final Version VERSION = new Version(1, 0, 0, null, null, null);
	
	/**
	 * Conjunto de serializadores a aplicar.
	 */
	private Map<Class<? extends Object>,JsonSerializer<Object>> serializers;
	
	/**
	 * Conjunto de deserializadores a aplicar.
	 */
	private Map<Class<Object>,JsonDeserializer<? extends Object>> deserializers;
	
	/**
	 * Propiedades de configuracion de la serializacion
	 */
	private Map<SerializationFeature,Boolean> serializationFeature;
	
	/**
	 * Propiedades de configuracion de la deserializacion
	 */
	private Map<DeserializationFeature,Boolean> deserializationFeature;
	
	
	/***
	Propiedades de configuracion de los maps para deseralizar y seralizar
	**/
	private Map<MapperFeature, Boolean> mapperFeature;
	
	/**
	 * Propiedades de inclusion de la serializacion.
	 */
	private List< JsonInclude.Include> serializationInclusions;
	
	/**
	 * Constructor por defecto.
	 */
	public UdaModule() {
		super(NAME, VERSION);
	}
	
	/**
	 * Metodo que se ejecuta despues de finalizar el contructor. Se inicializa
	 * el modulo configurando los serializadores y deserializadores indicados.
	 * Se anyade por defecto el deserializador MultiBeanDeserializer para
	 * permitir la deserializacion de multiples entidades no anidadas en la
	 * misma peticion.
	 */
	@PostConstruct
	public void initialize() {
		
		// Se registran los serializadores indicados.
		if(this.serializers!=null){
			Set<Entry<Class<? extends Object>,JsonSerializer<Object>>> serializerEntrySet = this.serializers.entrySet();
			
			for (Iterator<Entry<Class<? extends Object>, JsonSerializer<Object>>> iterator = serializerEntrySet.iterator(); iterator.hasNext();) {
				Entry<Class<? extends Object>, JsonSerializer<Object>> entry = (Entry<Class<? extends Object>, JsonSerializer<Object>>) iterator
						.next();
				this.addSerializer(entry.getKey(), entry.getValue());
			}
		}
		
		// Se registran los deserializadores indicados.
		if(this.deserializers!=null){
			Set<Entry<Class<Object>, JsonDeserializer<? extends Object>>> deserializerEntrySet = this.deserializers.entrySet();
	
			for (Iterator<Entry<Class<Object>, JsonDeserializer<? extends Object>>> iterator = deserializerEntrySet.iterator(); iterator
					.hasNext();) {
				Entry<Class<Object>, JsonDeserializer<? extends Object>> entry = (Entry<Class<Object>, JsonDeserializer<? extends Object>>) iterator
						.next();
				this.addDeserializer(entry.getKey(), entry.getValue());
			}
		}
		
		// Se registra el deserializador MultiBeanDeserializer. Este bean
		// permite la deserializacion de multiples entidades no anidadas en la
		// misma peticion.
		this.addDeserializer(Map.class, new MultiModelDeserializer());
		
	}
	
	/**
	 * Setter para asignar el conjunto de serializadores a aplicar.
	 * 
	 * @param serializers Conjunto de serializadores.
	 */
	public void setSerializers(Map<Class<? extends Object>,JsonSerializer<Object>> serializers) {
		this.serializers = serializers;
	}
	
	/**
	 * Setter para asignar el conjunto de deserializadores a aplicar.
	 * 
	 * @param serializers Conjunto de deserializadores.
	 */
	public void setDeserializers(Map<Class<Object>,JsonDeserializer<? extends Object>> deserializers) {
		this.deserializers = deserializers;
	}

	/**
	 * Getter para obtener las propiedades de configruacion de serializacion realizadas.
	 * 
	 * @return Map<SerializationConfig.Feature, Boolean> Mapa de propiedades de
	 *         configuracion y su estado.
	 */
	public Map<SerializationFeature, Boolean> getSerializationFeature() {
		return serializationFeature;
	}

	/**
	 * Setter para asignar las propiedades de configruacion de serializacion realizadas.
	 * 
	 * @param serializationConfigFeatures Mapa de propiedades de
	 *         configuracion y su estado.
	 */
	public void setSerializationFeature(
			Map<SerializationFeature, Boolean> serializationFeature) {
		this.serializationFeature = serializationFeature;
	}

	/**
	 * Getter para obtener las propiedades de configruacion de deserializacion
	 * realizadas.
	 * 
	 * @return Map<SerializationConfig.Feature, Boolean> Mapa de propiedades de
	 *         configuracio su estado.
	 */
	public Map<DeserializationFeature, Boolean> getDeserializationFeature() {
		return deserializationFeature;
	}

	/**
	 * Setter para asignar las propiedades de configruacion de deserializacion
	 * realizadas.
	 * 
	 * @param deserializationConfigFeatures
	 *            Mapa de propiedades de configuracion y su estado.
	 */
	public void setDeserializationFeature(
			Map<DeserializationFeature, Boolean> deserializationFeature) {
		this.deserializationFeature = deserializationFeature;
	}

	/**
	 * Getter para obtener las inclusiones de serialización de Jackson.
	 * 
	 * @return List<JsonSerialize.Inclusion> Inclusiones de serialización de
	 *         Jackson.
	 */
	
	public List< JsonInclude.Include> getSerializationInclusions() {
		return serializationInclusions;
	}

	/**
	 * Getter para asignar las inclusiones de serialización de Jackson.
	 * 
	 * @param serializationInclusions
	 *            Inclusiones de serialización de Jackson.
	 */
	public void setSerializationInclusions(
			List< JsonInclude.Include> serializationInclusions) {
		this.serializationInclusions = serializationInclusions;
	}

	public Map<MapperFeature, Boolean> getMapperFeature() {
		return mapperFeature;
	}

	public void setMapperFeature(
			Map<MapperFeature, Boolean> mapperFeature) {
		this.mapperFeature = mapperFeature;
	}
	
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/AbstractUrlMethodNameResolver.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import javax.servlet.http.HttpServletRequest;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.util.Assert;
import org.springframework.web.util.UrlPathHelper;

/**
 * Abstract base class for URL-based {@link MethodNameResolver} implementations.
 *
 * <p>Provides infrastructure for mapping handlers to URLs and configurable
 * URL lookup. For information on the latter, see the
 * {@link #setAlwaysUseFullPath} "alwaysUseFullPath"}
 * and {@link #setUrlDecode "urlDecode"} properties.
 *
 * @author Juergen Hoeller
 * @since 14.01.2004
 * @deprecated as of 4.3, in favor of annotation-driven handler methods
 */
@Deprecated
public abstract class AbstractUrlMethodNameResolver implements MethodNameResolver {

	/** Logger available to subclasses */
	protected final Log logger = LogFactory.getLog(getClass());

	private UrlPathHelper urlPathHelper = new UrlPathHelper();


	/**
	 * Set if URL lookup should always use full path within current servlet
	 * context. Else, the path within the current servlet mapping is used
	 * if applicable (i.e. in the case of a ".../*" servlet mapping in web.xml).
	 * Default is "false".
	 * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath
	 */
	public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {
		this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);
	}

	/**
	 * Set if context path and request URI should be URL-decoded.
	 * Both are returned <i>undecoded</i> by the Servlet API,
	 * in contrast to the servlet path.
	 * <p>Uses either the request encoding or the default encoding according
	 * to the Servlet spec (ISO-8859-1).
	 * @see org.springframework.web.util.UrlPathHelper#setUrlDecode
	 */
	public void setUrlDecode(boolean urlDecode) {
		this.urlPathHelper.setUrlDecode(urlDecode);
	}

	/**
	 * Set the UrlPathHelper to use for resolution of lookup paths.
	 * <p>Use this to override the default UrlPathHelper with a custom subclass,
	 * or to share common UrlPathHelper settings across multiple MethodNameResolvers
	 * and HandlerMappings.
	 * @see org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#setUrlPathHelper
	 */
	public void setUrlPathHelper(UrlPathHelper urlPathHelper) {
		Assert.notNull(urlPathHelper, "UrlPathHelper must not be null");
		this.urlPathHelper = urlPathHelper;
	}


	/**
	 * Retrieves the URL path to use for lookup and delegates to
	 * {@code getHandlerMethodNameForUrlPath}.
	 * Converts {@code null} values to NoSuchRequestHandlingMethodExceptions.
	 * @see #getHandlerMethodNameForUrlPath
	 */
	@Override
	public final String getHandlerMethodName(HttpServletRequest request)
			throws NoSuchRequestHandlingMethodException {

		String urlPath = this.urlPathHelper.getLookupPathForRequest(request);
		String name = getHandlerMethodNameForUrlPath(urlPath);
		if (name == null) {
			throw new NoSuchRequestHandlingMethodException(urlPath, request.getMethod(), request.getParameterMap());
		}
		if (logger.isDebugEnabled()) {
			logger.debug("Returning handler method name '" + name + "' for lookup path: " + urlPath);
		}
		return name;
	}

	/**
	 * Return a method name that can handle this request, based on the
	 * given lookup path. Called by {@code getHandlerMethodName}.
	 * @param urlPath the URL path to use for lookup,
	 * according to the settings in this class
	 * @return a method name that can handle this request.
	 * Should return null if no matching method found.
	 * @see #getHandlerMethodName
	 * @see #setAlwaysUseFullPath
	 * @see #setUrlDecode
	 */
	protected abstract String getHandlerMethodNameForUrlPath(String urlPath);

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/AnnotationMethodHandlerAdapter.java
================================================
/*
 * Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.lang.reflect.Method;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.BeanFactoryAware;
import org.springframework.beans.factory.config.BeanExpressionContext;
import org.springframework.beans.factory.config.BeanExpressionResolver;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.core.DefaultParameterNameDiscoverer;
import org.springframework.core.Ordered;
import org.springframework.core.ParameterNameDiscoverer;
import org.springframework.core.annotation.AnnotatedElementUtils;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.ByteArrayHttpMessageConverter;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.converter.StringHttpMessageConverter;
import org.springframework.http.converter.xml.SourceHttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.http.server.ServletServerHttpResponse;
import org.springframework.ui.ExtendedModelMap;
import org.springframework.ui.Model;
import org.springframework.util.AntPathMatcher;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.ObjectUtils;
import org.springframework.util.PathMatcher;
import org.springframework.util.StringUtils;
import org.springframework.validation.support.BindingAwareModelMap;
import org.springframework.web.HttpMediaTypeNotAcceptableException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.HttpSessionRequiredException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.ServletRequestDataBinder;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.SessionAttributes;
import org.springframework.web.bind.support.DefaultSessionAttributeStore;
import org.springframework.web.bind.support.SessionAttributeStore;
import org.springframework.web.bind.support.WebArgumentResolver;
import org.springframework.web.bind.support.WebBindingInitializer;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.RequestScope;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.multipart.MultipartRequest;
import org.springframework.web.servlet.HandlerAdapter;
import org.springframework.web.servlet.HandlerMapping;
import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.View;
import org.springframework.web.servlet.mvc.annotation.ModelAndViewResolver;
import org.springframework.web.servlet.support.RequestContextUtils;
import org.springframework.web.servlet.support.WebContentGenerator;
import org.springframework.web.util.UrlPathHelper;
import org.springframework.web.util.WebUtils;

/**
 * Implementation of the {@link org.springframework.web.servlet.HandlerAdapter} interface
 * that maps handler methods based on HTTP paths, HTTP methods, and request parameters
 * expressed through the {@link RequestMapping} annotation.
 *
 * <p>
 * Supports request parameter binding through the {@link RequestParam} annotation.
 * Also supports the {@link ModelAttribute} annotation for exposing model attribute
 * values to the view, as well as {@link InitBinder} for binder initialization methods
 * and {@link SessionAttributes} for automatic session management of specific attributes.
 *
 * <p>
 * This adapter can be customized through various bean properties.
 * A common use case is to apply shared binder initialization logic through
 * a custom {@link #setWebBindingInitializer WebBindingInitializer}.
 *
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @author Sam Brannen
 * @since 2.5
 * @see #setPathMatcher
 * @see #setMethodNameResolver
 * @see #setWebBindingInitializer
 * @see #setSessionAttributeStore
 * @deprecated as of Spring 3.2, in favor of
 *             {@link org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter
 *             RequestMappingHandlerAdapter}
 */
@Deprecated
public class AnnotationMethodHandlerAdapter extends WebContentGenerator
	implements HandlerAdapter, Ordered, BeanFactoryAware {

    /**
     * Log category to use when no mapped handler is found for a request.
     *
     * @see #pageNotFoundLogger
     */
    public static final String PAGE_NOT_FOUND_LOG_CATEGORY = "org.springframework.web.servlet.PageNotFound";

    /**
     * Additional logger to use when no mapped handler is found for a request.
     *
     * @see #PAGE_NOT_FOUND_LOG_CATEGORY
     */
    protected static final Log pageNotFoundLogger = LogFactory.getLog(PAGE_NOT_FOUND_LOG_CATEGORY);

    private UrlPathHelper urlPathHelper = new UrlPathHelper();

    private PathMatcher pathMatcher = new AntPathMatcher();

    private MethodNameResolver methodNameResolver = new InternalPathMethodNameResolver();

    private WebBindingInitializer webBindingInitializer;

    private SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore();

    private int cacheSecondsForSessionAttributeHandlers = 0;

    private boolean synchronizeOnSession = false;

    private ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();

    private WebArgumentResolver[] customArgumentResolvers;

    private ModelAndViewResolver[] customModelAndViewResolvers;

    private HttpMessageConverter<?>[] messageConverters;

    private int order = Ordered.LOWEST_PRECEDENCE;

    private ConfigurableBeanFactory beanFactory;

    private BeanExpressionContext expressionContext;

    private final Map<Class<?>, ServletHandlerMethodResolver> methodResolverCache = new ConcurrentHashMap<>(64);

    private final Map<Class<?>, Boolean> sessionAnnotatedClassesCache = new ConcurrentHashMap<>(64);

    public AnnotationMethodHandlerAdapter() {
	// no restriction of HTTP methods by default
	super(false);

	// See SPR-7316
	StringHttpMessageConverter stringHttpMessageConverter = new StringHttpMessageConverter();
	stringHttpMessageConverter.setWriteAcceptCharset(false);
	this.messageConverters = new HttpMessageConverter<?>[] { new ByteArrayHttpMessageConverter(),
		stringHttpMessageConverter, new SourceHttpMessageConverter<>(),
		new XmlAwareFormHttpMessageConverter() };
    }

    /**
     * Set if URL lookup should always use the full path within the current servlet
     * context. Else, the path within the current servlet mapping is used if applicable
     * (that is, in the case of a ".../*" servlet mapping in web.xml).
     * <p>
     * Default is "false".
     *
     * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath
     */
    public void setAlwaysUseFullPath(boolean alwaysUseFullPath) {
	this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);
    }

    /**
     * Set if context path and request URI should be URL-decoded. Both are returned
     * <i>undecoded</i> by the Servlet API, in contrast to the servlet path.
     * <p>
     * Uses either the request encoding or the default encoding according
     * to the Servlet spec (ISO-8859-1).
     *
     * @see org.springframework.web.util.UrlPathHelper#setUrlDecode
     */
    public void setUrlDecode(boolean urlDecode) {
	this.urlPathHelper.setUrlDecode(urlDecode);
    }

    /**
     * Set the UrlPathHelper to use for resolution of lookup paths.
     * <p>
     * Use this to override the default UrlPathHelper with a custom subclass,
     * or to share common UrlPathHelper settings across multiple HandlerMappings and HandlerAdapters.
     */
    public void setUrlPathHelper(UrlPathHelper urlPathHelper) {
	Assert.notNull(urlPathHelper, "UrlPathHelper must not be null");
	this.urlPathHelper = urlPathHelper;
    }

    /**
     * Set the PathMatcher implementation to use for matching URL paths against registered URL patterns.
     * <p>
     * Default is {@link org.springframework.util.AntPathMatcher}.
     */
    public void setPathMatcher(PathMatcher pathMatcher) {
	Assert.notNull(pathMatcher, "PathMatcher must not be null");
	this.pathMatcher = pathMatcher;
    }

    /**
     * Set the MethodNameResolver to use for resolving default handler methods
     * (carrying an empty {@code @RequestMapping} annotation).
     * <p>
     * Will only kick in when the handler method cannot be resolved uniquely
     * through the annotation metadata already.
     */
    public void setMethodNameResolver(MethodNameResolver methodNameResolver) {
	this.methodNameResolver = methodNameResolver;
    }

    /**
     * Specify a WebBindingInitializer which will apply pre-configured
     * configuration to every DataBinder that this controller uses.
     */
    public void setWebBindingInitializer(WebBindingInitializer webBindingInitializer) {
	this.webBindingInitializer = webBindingInitializer;
    }

    /**
     * Specify the strategy to store session attributes with.
     * <p>
     * Default is {@link org.springframework.web.bind.support.DefaultSessionAttributeStore},
     * storing session attributes in the HttpSession, using the same attribute name as in the model.
     */
    public void setSessionAttributeStore(SessionAttributeStore sessionAttributeStore) {
	Assert.notNull(sessionAttributeStore, "SessionAttributeStore must not be null");
	this.sessionAttributeStore = sessionAttributeStore;
    }

    /**
     * Cache content produced by {@code @SessionAttributes} annotated handlers
     * for the given number of seconds. Default is 0, preventing caching completely.
     * <p>
     * In contrast to the "cacheSeconds" property which will apply to all general handlers
     * (but not to {@code @SessionAttributes} annotated handlers), this setting will
     * apply to {@code @SessionAttributes} annotated handlers only.
     *
     * @see #setCacheSeconds
     * @see org.springframework.web.bind.annotation.SessionAttributes
     */
    public void setCacheSecondsForSessionAttributeHandlers(int cacheSecondsForSessionAttributeHandlers) {
	this.cacheSecondsForSessionAttributeHandlers = cacheSecondsForSessionAttributeHandlers;
    }

    /**
     * Set if controller execution should be synchronized on the session,
     * to serialize parallel invocations from the same client.
     * <p>
     * More specifically, the execution of the {@code handleRequestInternal}
     * method will get synchronized if this flag is "true". The best available
     * session mutex will be used for the synchronization; ideally, this will
     * be a mutex exposed by HttpSessionMutexListener.
     * <p>
     * The session mutex is guaranteed to be the same object during
     * the entire lifetime of the session, available under the key defined
     * by the {@code SESSION_MUTEX_ATTRIBUTE} constant. It serves as a
     * safe reference to synchronize on for locking on the current session.
     * <p>
     * In many cases, the HttpSession reference itself is a safe mutex
     * as well, since it will always be the same object reference for the
     * same active logical session. However, this is not guaranteed across
     * different servlet containers; the only 100% safe way is a session mutex.
     *
     * @see org.springframework.web.util.HttpSessionMutexListener
     * @see org.springframework.web.util.WebUtils#getSessionMutex(javax.servlet.http.HttpSession)
     */
    public void setSynchronizeOnSession(boolean synchronizeOnSession) {
	this.synchronizeOnSession = synchronizeOnSession;
    }

    /**
     * Set the ParameterNameDiscoverer to use for resolving method parameter names if needed
     * (e.g. for default attribute names).
     * <p>
     * Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.
     */
    public void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {
	this.parameterNameDiscoverer = parameterNameDiscoverer;
    }

    /**
     * Set a custom WebArgumentResolvers to use for special method parameter types.
     * <p>
     * Such a custom WebArgumentResolver will kick in first, having a chance to resolve
     * an argument value before the standard argument handling kicks in.
     */
    public void setCustomArgumentResolver(WebArgumentResolver argumentResolver) {
	this.customArgumentResolvers = new WebArgumentResolver[] { argumentResolver };
    }

    /**
     * Set one or more custom WebArgumentResolvers to use for special method parameter types.
     * <p>
     * Any such custom WebArgumentResolver will kick in first, having a chance to resolve
     * an argument value before the standard argument handling kicks in.
     */
    public void setCustomArgumentResolvers(WebArgumentResolver... argumentResolvers) {
	this.customArgumentResolvers = argumentResolvers;
    }

    /**
     * Set a custom ModelAndViewResolvers to use for special method return types.
     * <p>
     * Such a custom ModelAndViewResolver will kick in first, having a chance to resolve
     * a return value before the standard ModelAndView handling kicks in.
     */
    public void setCustomModelAndViewResolver(ModelAndViewResolver customModelAndViewResolver) {
	this.customModelAndViewResolvers = new ModelAndViewResolver[] { customModelAndViewResolver };
    }

    /**
     * Set one or more custom ModelAndViewResolvers to use for special method return types.
     * <p>
     * Any such custom ModelAndViewResolver will kick in first, having a chance to resolve
     * a return value before the standard ModelAndView handling kicks in.
     */
    public void setCustomModelAndViewResolvers(ModelAndViewResolver... customModelAndViewResolvers) {
	this.customModelAndViewResolvers = customModelAndViewResolvers;
    }

    /**
     * Set the message body converters to use.
     * <p>
     * These converters are used to convert from and to HTTP requests and responses.
     */
    public void setMessageConverters(HttpMessageConverter<?>[] messageConverters) {
	this.messageConverters = messageConverters;
    }

    /**
     * Return the message body converters that this adapter has been configured with.
     */
    public HttpMessageConverter<?>[] getMessageConverters() {
	return messageConverters;
    }

    /**
     * Specify the order value for this HandlerAdapter bean.
     * <p>
     * Default value is {@code Integer.MAX_VALUE}, meaning that it's non-ordered.
     *
     * @see org.springframework.core.Ordered#getOrder()
     */
    public void setOrder(int order) {
	this.order = order;
    }

    @Override
    public int getOrder() {
	return this.order;
    }

    @Override
    public void setBeanFactory(BeanFactory beanFactory) {
	if (beanFactory instanceof ConfigurableBeanFactory) {
	    this.beanFactory = (ConfigurableBeanFactory) beanFactory;
	    this.expressionContext = new BeanExpressionContext(this.beanFactory, new RequestScope());
	}
    }

    @Override
    public boolean supports(Object handler) {
	return getMethodResolver(handler).hasHandlerMethods();
    }

    @Override
    public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)
	    throws Exception {

	Class<?> clazz = ClassUtils.getUserClass(handler);
	Boolean annotatedWithSessionAttributes = this.sessionAnnotatedClassesCache.get(clazz);
	if (annotatedWithSessionAttributes == null) {
	    annotatedWithSessionAttributes = (AnnotationUtils.findAnnotation(clazz, SessionAttributes.class) != null);
	    this.sessionAnnotatedClassesCache.put(clazz, annotatedWithSessionAttributes);
	}

	if (annotatedWithSessionAttributes) {
	    checkAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);
	} else {
	    checkAndPrepare(request, response, true);
	}

	// Execute invokeHandlerMethod in synchronized block if required.
	if (this.synchronizeOnSession) {
	    HttpSession session = request.getSession(false);
	    if (session != null) {
		Object mutex = WebUtils.getSessionMutex(session);
		synchronized (mutex) {
		    return invokeHandlerMethod(request, response, handler);
		}
	    }
	}

	return invokeHandlerMethod(request, response, handler);
    }

    protected ModelAndView invokeHandlerMethod(HttpServletRequest request, HttpServletResponse response, Object handler)
	    throws Exception {

	ServletHandlerMethodResolver methodResolver = getMethodResolver(handler);
	Method handlerMethod = methodResolver.resolveHandlerMethod(request);
	ServletHandlerMethodInvoker methodInvoker = new ServletHandlerMethodInvoker(methodResolver);
	ServletWebRequest webRequest = new ServletWebRequest(request, response);
	ExtendedModelMap implicitModel = new BindingAwareModelMap();

	Object result = methodInvoker.invokeHandlerMethod(handlerMethod, handler, webRequest, implicitModel);
	ModelAndView mav = methodInvoker.getModelAndView(handlerMethod, handler.getClass(), result, implicitModel,
		webRequest);
	methodInvoker.updateModelAttributes(handler, (mav != null ? mav.getModel() : null), implicitModel, webRequest);
	return mav;
    }

    /**
     * This method always returns -1 since an annotated controller can have many methods,
     * each requiring separate lastModified calculations. Instead, an
     * {@link RequestMapping}-annotated method can calculate the lastModified value, call
     * {@link org.springframework.web.context.request.WebRequest#checkNotModified(long)}
     * to check it, and return {@code null} if that returns {@code true}.
     *
     * @see org.springframework.web.context.request.WebRequest#checkNotModified(long)
     */
    @Override
    public long getLastModified(HttpServletRequest request, Object handler) {
	return -1;
    }

    /**
     * Build a HandlerMethodResolver for the given handler type.
     */
    private ServletHandlerMethodResolver getMethodResolver(Object handler) {
	Class<?> handlerClass = ClassUtils.getUserClass(handler);
	ServletHandlerMethodResolver resolver = this.methodResolverCache.get(handlerClass);
	if (resolver == null) {
	    synchronized (this.methodResolverCache) {
		resolver = this.methodResolverCache.get(handlerClass);
		if (resolver == null) {
		    resolver = new ServletHandlerMethodResolver(handlerClass);
		    this.methodResolverCache.put(handlerClass, resolver);
		}
	    }
	}
	return resolver;
    }

    /**
     * Template method for creating a new ServletRequestDataBinder instance.
     * <p>
     * The default implementation creates a standard ServletRequestDataBinder.
     * This can be overridden for custom ServletRequestDataBinder subclasses.
     *
     * @param request
     *            current HTTP request
     * @param target
     *            the target object to bind onto (or {@code null}
     *            if the binder is just used to convert a plain parameter value)
     * @param objectName
     *            the objectName of the target object
     * @return the ServletRequestDataBinder instance to use
     * @throws Exception
     *             in case of invalid state or arguments
     * @see ServletRequestDataBinder#bind(javax.servlet.ServletRequest)
     * @see ServletRequestDataBinder#convertIfNecessary(Object, Class, org.springframework.core.MethodParameter)
     */
    protected ServletRequestDataBinder createBinder(HttpServletRequest request, Object target, String objectName)
	    throws Exception {
	return new ServletRequestDataBinder(target, objectName);
    }

    /**
     * Template method for creating a new HttpInputMessage instance.
     * <p>
     * The default implementation creates a standard {@link ServletServerHttpRequest}.
     * This can be overridden for custom {@code HttpInputMessage} implementations
     *
     * @param servletRequest
     *            current HTTP request
     * @return the HttpInputMessage instance to use
     * @throws Exception
     *             in case of errors
     */
    protected HttpInputMessage createHttpInputMessage(HttpServletRequest servletRequest) throws Exception {
	return new ServletServerHttpRequest(servletRequest);
    }

    /**
     * Template method for creating a new HttpOutputMessage instance.
     * <p>
     * The default implementation creates a standard {@link ServletServerHttpResponse}.
     * This can be overridden for custom {@code HttpOutputMessage} implementations
     *
     * @param servletResponse
     *            current HTTP response
     * @return the HttpInputMessage instance to use
     * @throws Exception
     *             in case of errors
     */
    protected HttpOutputMessage createHttpOutputMessage(HttpServletResponse servletResponse) throws Exception {
	return new ServletServerHttpResponse(servletResponse);
    }

    /**
     * Servlet-specific subclass of {@code HandlerMethodResolver}.
     */
    @SuppressWarnings("deprecation")
    private class ServletHandlerMethodResolver extends HandlerMethodResolver {

	private final Map<Method, RequestMappingInfo> mappings = new HashMap<>();

	private ServletHandlerMethodResolver(Class<?> handlerType) {
	    init(handlerType);
	}

	@Override
	protected boolean isHandlerMethod(Method method) {
	    if (this.mappings.containsKey(method)) {
		return true;
	    }
	    RequestMapping mapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);
	    if (mapping != null) {
		String[] patterns = mapping.value();
		RequestMethod[] methods = new RequestMethod[0];
		String[] params = new String[0];
		String[] headers = new String[0];
		if (!hasTypeLevelMapping() || !Arrays.equals(mapping.method(), getTypeLevelMapping().method())) {
		    methods = mapping.method();
		}
		if (!hasTypeLevelMapping() || !Arrays.equals(mapping.params(), getTypeLevelMapping().params())) {
		    params = mapping.params();
		}
		if (!hasTypeLevelMapping() || !Arrays.equals(mapping.headers(), getTypeLevelMapping().headers())) {
		    headers = mapping.headers();
		}
		RequestMappingInfo mappingInfo = new RequestMappingInfo(patterns, methods, params, headers);
		this.mappings.put(method, mappingInfo);
		return true;
	    }
	    return false;
	}

	public Method resolveHandlerMethod(HttpServletRequest request) throws ServletException {
	    String lookupPath = urlPathHelper.getLookupPathForRequest(request);
	    Comparator<String> pathComparator = pathMatcher.getPatternComparator(lookupPath);
	    Map<RequestSpecificMappingInfo, Method> targetHandlerMethods = new LinkedHashMap<>();
	    Set<String> allowedMethods = new LinkedHashSet<>(7);
	    String resolvedMethodName = null;
	    for (Method handlerMethod : getHandlerMethods()) {
		RequestSpecificMappingInfo mappingInfo = new RequestSpecificMappingInfo(
			this.mappings.get(handlerMethod));
		boolean match = false;
		if (mappingInfo.hasPatterns()) {
		    for (String pattern : mappingInfo.getPatterns()) {
			if (!hasTypeLevelMapping() && !pattern.startsWith("/")) {
			    pattern = "/" + pattern;
			}
			String combinedPattern = getCombinedPattern(pattern, lookupPath, request);
			if (combinedPattern != null) {
			    if (mappingInfo.matches(request)) {
				match = true;
				mappingInfo.addMatchedPattern(combinedPattern);
			    } else {
				if (!mappingInfo.matchesRequestMethod(request)) {
				    allowedMethods.addAll(mappingInfo.methodNames());
				}
				break;
			    }
			}
		    }
		    mappingInfo.sortMatchedPatterns(pathComparator);
		} else if (useTypeLevelMapping(request)) {
		    String[] typeLevelPatterns = getTypeLevelMapping().value();
		    for (String typeLevelPattern : typeLevelPatterns) {
			if (!typeLevelPattern.startsWith("/")) {
			    typeLevelPattern = "/" + typeLevelPattern;
			}
			boolean useSuffixPattern = useSuffixPattern(request);
			if (getMatchingPattern(typeLevelPattern, lookupPath, useSuffixPattern) != null) {
			    if (mappingInfo.matches(request)) {
				match = true;
				mappingInfo.addMatchedPattern(typeLevelPattern);
			    } else {
				if (!mappingInfo.matchesRequestMethod(request)) {
				    allowedMethods.addAll(mappingInfo.methodNames());
				}
				break;
			    }
			}
		    }
		    mappingInfo.sortMatchedPatterns(pathComparator);
		} else {
		    // No paths specified: parameter match sufficient.
		    match = mappingInfo.matches(request);
		    if (match && mappingInfo.getMethodCount() == 0 && mappingInfo.getParamCount() == 0
			    && resolvedMethodName != null && !resolvedMethodName.equals(handlerMethod.getName())) {
			match = false;
		    } else {
			if (!mappingInfo.matchesRequestMethod(request)) {
			    allowedMethods.addAll(mappingInfo.methodNames());
			}
		    }
		}
		if (match) {
		    Method oldMappedMethod = targetHandlerMethods.put(mappingInfo, handlerMethod);
		    if (oldMappedMethod != null && oldMappedMethod != handlerMethod) {
			if (methodNameResolver != null && !mappingInfo.hasPatterns()) {
			    if (!oldMappedMethod.getName().equals(handlerMethod.getName())) {
				if (resolvedMethodName == null) {
				    resolvedMethodName = methodNameResolver.getHandlerMethodName(request);
				}
				if (!resolvedMethodName.equals(oldMappedMethod.getName())) {
				    oldMappedMethod = null;
				}
				if (!resolvedMethodName.equals(handlerMethod.getName())) {
				    if (oldMappedMethod != null) {
					targetHandlerMethods.put(mappingInfo, oldMappedMethod);
					oldMappedMethod = null;
				    } else {
					targetHandlerMethods.remove(mappingInfo);
				    }
				}
			    }
			}
			if (oldMappedMethod != null) {
			    throw new IllegalStateException("Ambiguous handler methods mapped for HTTP path '"
				    + lookupPath + "': {" + oldMappedMethod + ", " + handlerMethod
				    + "}. If you intend to handle the same path in multiple methods, then factor "
				    + "them out into a dedicated handler class with that path mapped at the type level!");
			}
		    }
		}
	    }
	    if (!targetHandlerMethods.isEmpty()) {
		List<RequestSpecificMappingInfo> matches = new ArrayList<>(targetHandlerMethods.keySet());
		RequestSpecificMappingInfoComparator requestMappingInfoComparator = new RequestSpecificMappingInfoComparator(
			pathComparator, request);
		Collections.sort(matches, requestMappingInfoComparator);
		RequestSpecificMappingInfo bestMappingMatch = matches.get(0);
		String bestMatchedPath = bestMappingMatch.bestMatchedPattern();
		if (bestMatchedPath != null) {
		    extractHandlerMethodUriTemplates(bestMatchedPath, lookupPath, request);
		}
		return targetHandlerMethods.get(bestMappingMatch);
	    } else {
		if (!allowedMethods.isEmpty()) {
		    throw new HttpRequestMethodNotSupportedException(request.getMethod(),
			    StringUtils.toStringArray(allowedMethods));
		}
		throw new NoSuchRequestHandlingMethodException(lookupPath, request.getMethod(),
			request.getParameterMap());
	    }
	}

	private boolean useTypeLevelMapping(HttpServletRequest request) {
	    if (!hasTypeLevelMapping() || ObjectUtils.isEmpty(getTypeLevelMapping().value())) {
		return false;
	    }
	    Object value = request.getAttribute(HandlerMapping.INTROSPECT_TYPE_LEVEL_MAPPING);
	    return (value != null) ? (Boolean) value : Boolean.TRUE;
	}

	private boolean useSuffixPattern(HttpServletRequest request) {
	    Object value = request.getAttribute(DefaultAnnotationHandlerMapping.USE_DEFAULT_SUFFIX_PATTERN);
	    return (value != null) ? (Boolean) value : Boolean.TRUE;
	}

	/**
	 * Determines the combined pattern for the given methodLevelPattern and path.
	 * <p>
	 * Uses the following algorithm:
	 * <ol>
	 * <li>If there is a type-level mapping with path information, it is {@linkplain
	 * PathMatcher#combine(String, String) combined} with the method-level pattern.</li>
	 * <li>If there is a {@linkplain HandlerMapping#BEST_MATCHING_PATTERN_ATTRIBUTE best matching pattern}
	 * in the request, it is combined with the method-level pattern.</li>
	 * <li>Otherwise, the method-level pattern is returned.</li>
	 * </ol>
	 */
	private String getCombinedPattern(String methodLevelPattern, String lookupPath, HttpServletRequest request) {
	    boolean useSuffixPattern = useSuffixPattern(request);
	    if (useTypeLevelMapping(request)) {
		String[] typeLevelPatterns = getTypeLevelMapping().value();
		for (String typeLevelPattern : typeLevelPatterns) {
		    if (!typeLevelPattern.startsWith("/")) {
			typeLevelPattern = "/" + typeLevelPattern;
		    }
		    String combinedPattern = pathMatcher.combine(typeLevelPattern, methodLevelPattern);
		    String matchingPattern = getMatchingPattern(combinedPattern, lookupPath, useSuffixPattern);
		    if (matchingPattern != null) {
			return matchingPattern;
		    }
		}
		return null;
	    }
	    String bestMatchingPattern = (String) request.getAttribute(HandlerMapping.BEST_MATCHING_PATTERN_ATTRIBUTE);
	    if (StringUtils.hasText(bestMatchingPattern) && bestMatchingPattern.endsWith("*")) {
		String combinedPattern = pathMatcher.combine(bestMatchingPattern, methodLevelPattern);
		String matchingPattern = getMatchingPattern(combinedPattern, lookupPath, useSuffixPattern);
		if (matchingPattern != null && !matchingPattern.equals(bestMatchingPattern)) {
		    return matchingPattern;
		}
	    }
	    return getMatchingPattern(methodLevelPattern, lookupPath, useSuffixPattern);
	}

	private String getMatchingPattern(String pattern, String lookupPath, boolean useSuffixPattern) {
	    if (pattern.equals(lookupPath)) {
		return pattern;
	    }
	    boolean hasSuffix = pattern.indexOf('.') != -1;
	    if (useSuffixPattern && !hasSuffix) {
		String patternWithSuffix = pattern + ".*";
		if (pathMatcher.match(patternWithSuffix, lookupPath)) {
		    return patternWithSuffix;
		}
	    }
	    if (pathMatcher.match(pattern, lookupPath)) {
		return pattern;
	    }
	    boolean endsWithSlash = pattern.endsWith("/");
	    if (useSuffixPattern && !endsWithSlash) {
		String patternWithSlash = pattern + "/";
		if (pathMatcher.match(patternWithSlash, lookupPath)) {
		    return patternWithSlash;
		}
	    }
	    return null;
	}

	@SuppressWarnings("unchecked")
	private void extractHandlerMethodUriTemplates(String mappedPattern, String lookupPath,
		HttpServletRequest request) {
	    Map<String, String> variables = (Map<String, String>) request
		    .getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);
	    int patternVariableCount = StringUtils.countOccurrencesOf(mappedPattern, "{");
	    if ((variables == null || patternVariableCount != variables.size())
		    && pathMatcher.match(mappedPattern, lookupPath)) {
		variables = pathMatcher.extractUriTemplateVariables(mappedPattern, lookupPath);
		Map<String, String> decodedVariables = urlPathHelper.decodePathVariables(request, variables);
		request.setAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE, decodedVariables);
	    }
	}
    }

    /**
     * Servlet-specific subclass of {@code HandlerMethodInvoker}.
     */
    @SuppressWarnings("deprecation")
    private class ServletHandlerMethodInvoker extends HandlerMethodInvoker {

	private boolean responseArgumentUsed = false;

	private ServletHandlerMethodInvoker(HandlerMethodResolver resolver) {
	    super(resolver, webBindingInitializer, sessionAttributeStore, parameterNameDiscoverer,
		    customArgumentResolvers, messageConverters);
	}

	@Override
	protected void raiseMissingParameterException(String paramName, Class<?> paramType) throws Exception {
	    throw new MissingServletRequestParameterException(paramName, paramType.getSimpleName());
	}

	@Override
	protected void raiseSessionRequiredException(String message) throws Exception {
	    throw new HttpSessionRequiredException(message);
	}

	@Override
	protected WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)
		throws Exception {

	    return AnnotationMethodHandlerAdapter.this
		    .createBinder(webRequest.getNativeRequest(HttpServletRequest.class), target, objectName);
	}

	@Override
	protected void doBind(WebDataBinder binder, NativeWebRequest webRequest) throws Exception {
	    ServletRequestDataBinder servletBinder = (ServletRequestDataBinder) binder;
	    servletBinder.bind(webRequest.getNativeRequest(ServletRequest.class));
	}

	@Override
	protected HttpInputMessage createHttpInputMessage(NativeWebRequest webRequest) throws Exception {
	    HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
	    return AnnotationMethodHandlerAdapter.this.createHttpInputMessage(servletRequest);
	}

	@Override
	protected HttpOutputMessage createHttpOutputMessage(NativeWebRequest webRequest) throws Exception {
	    HttpServletResponse servletResponse = (HttpServletResponse) webRequest.getNativeResponse();
	    return AnnotationMethodHandlerAdapter.this.createHttpOutputMessage(servletResponse);
	}

	@Override
	protected Object resolveDefaultValue(String value) {
	    if (beanFactory == null) {
		return value;
	    }
	    String placeholdersResolved = beanFactory.resolveEmbeddedValue(value);
	    BeanExpressionResolver exprResolver = beanFactory.getBeanExpressionResolver();
	    if (exprResolver == null) {
		return value;
	    }
	    return exprResolver.evaluate(placeholdersResolved, expressionContext);
	}

	@Override
	protected Object resolveCookieValue(String cookieName, Class<?> paramType, NativeWebRequest webRequest)
		throws Exception {

	    HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
	    Cookie cookieValue = WebUtils.getCookie(servletRequest, cookieName);
	    if (Cookie.class.isAssignableFrom(paramType)) {
		return cookieValue;
	    } else if (cookieValue != null) {
		return urlPathHelper.decodeRequestString(servletRequest, cookieValue.getValue());
	    } else {
		return null;
	    }
	}

	@Override
	@SuppressWarnings({ "unchecked" })
	protected String resolvePathVariable(String pathVarName, Class<?> paramType, NativeWebRequest webRequest)
		throws Exception {

	    HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
	    Map<String, String> uriTemplateVariables = (Map<String, String>) servletRequest
		    .getAttribute(HandlerMapping.URI_TEMPLATE_VARIABLES_ATTRIBUTE);
	    if (uriTemplateVariables == null || !uriTemplateVariables.containsKey(pathVarName)) {
		throw new IllegalStateException(
			"Could not find @PathVariable [" + pathVarName + "] in @RequestMapping");
	    }
	    return uriTemplateVariables.get(pathVarName);
	}

	@Override
	protected Object resolveStandardArgument(Class<?> parameterType, NativeWebRequest webRequest) throws Exception {
	    HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
	    HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);

	    if (ServletRequest.class.isAssignableFrom(parameterType)
		    || MultipartRequest.class.isAssignableFrom(parameterType)) {
		Object nativeRequest = webRequest.getNativeRequest(parameterType);
		if (nativeRequest == null) {
		    throw new IllegalStateException(
			    "Current request is not of type [" + parameterType.getName() + "]: " + request);
		}
		return nativeRequest;
	    } else if (ServletResponse.class.isAssignableFrom(parameterType)) {
		this.responseArgumentUsed = true;
		Object nativeResponse = webRequest.getNativeResponse(parameterType);
		if (nativeResponse == null) {
		    throw new IllegalStateException(
			    "Current response is not of type [" + parameterType.getName() + "]: " + response);
		}
		return nativeResponse;
	    } else if (HttpSession.class.isAssignableFrom(parameterType)) {
		return request.getSession();
	    } else if (Principal.class.isAssignableFrom(parameterType)) {
		return request.getUserPrincipal();
	    } else if (Locale.class == parameterType) {
		return RequestContextUtils.getLocale(request);
	    } else if (InputStream.class.isAssignableFrom(parameterType)) {
		return request.getInputStream();
	    } else if (Reader.class.isAssignableFrom(parameterType)) {
		return request.getReader();
	    } else if (OutputStream.class.isAssignableFrom(parameterType)) {
		this.responseArgumentUsed = true;
		return response.getOutputStream();
	    } else if (Writer.class.isAssignableFrom(parameterType)) {
		this.responseArgumentUsed = true;
		return response.getWriter();
	    }
	    return super.resolveStandardArgument(parameterType, webRequest);
	}

	@SuppressWarnings("unchecked")
	public ModelAndView getModelAndView(Method handlerMethod, Class<?> handlerType, Object returnValue,
		ExtendedModelMap implicitModel, ServletWebRequest webRequest) throws Exception {

	    ResponseStatus responseStatus = AnnotatedElementUtils.findMergedAnnotation(handlerMethod,
		    ResponseStatus.class);
	    if (responseStatus != null) {
		HttpStatus statusCode = responseStatus.code();
		String reason = responseStatus.reason();
		if (!StringUtils.hasText(reason)) {
		    webRequest.getResponse().setStatus(statusCode.value());
		} else {
		    webRequest.getResponse().sendError(statusCode.value(), reason);
		}

		// to be picked up by the RedirectView
		webRequest.getRequest().setAttribute(View.RESPONSE_STATUS_ATTRIBUTE, statusCode);

		this.responseArgumentUsed = true;
	    }

	    // Invoke custom resolvers if present...
	    if (customModelAndViewResolvers != null) {
		for (ModelAndViewResolver mavResolver : customModelAndViewResolvers) {
		    ModelAndView mav = mavResolver.resolveModelAndView(handlerMethod, handlerType, returnValue,
			    implicitModel, webRequest);
		    if (mav != ModelAndViewResolver.UNRESOLVED) {
			return mav;
		    }
		}
	    }

	    if (returnValue instanceof HttpEntity) {
		handleHttpEntityResponse((HttpEntity<?>) returnValue, webRequest);
		return null;
	    } else if (AnnotationUtils.findAnnotation(handlerMethod, ResponseBody.class) != null) {
		handleResponseBody(returnValue, webRequest);
		return null;
	    } else if (returnValue instanceof ModelAndView) {
		ModelAndView mav = (ModelAndView) returnValue;
		mav.getModelMap().mergeAttributes(implicitModel);
		return mav;
	    } else if (returnValue instanceof Model) {
		return new ModelAndView().addAllObjects(implicitModel).addAllObjects(((Model) returnValue).asMap());
	    } else if (returnValue instanceof View) {
		return new ModelAndView((View) returnValue).addAllObjects(implicitModel);
	    } else if (AnnotationUtils.findAnnotation(handlerMethod, ModelAttribute.class) != null) {
		addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);
		return new ModelAndView().addAllObjects(implicitModel);
	    } else if (returnValue instanceof Map) {
		return new ModelAndView().addAllObjects(implicitModel).addAllObjects((Map<String, ?>) returnValue);
	    } else if (returnValue instanceof String) {
		return new ModelAndView((String) returnValue).addAllObjects(implicitModel);
	    } else if (returnValue == null) {
		// Either returned null or was 'void' return.
		if (this.responseArgumentUsed || webRequest.isNotModified()) {
		    return null;
		} else {
		    // Assuming view name translation...
		    return new ModelAndView().addAllObjects(implicitModel);
		}
	    } else if (!BeanUtils.isSimpleProperty(returnValue.getClass())) {
		// Assume a single model attribute...
		addReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);
		return new ModelAndView().addAllObjects(implicitModel);
	    } else {
		throw new IllegalArgumentException("Invalid handler method return value: " + returnValue);
	    }
	}

	private void handleResponseBody(Object returnValue, ServletWebRequest webRequest) throws Exception {
	    if (returnValue == null) {
		return;
	    }
	    HttpInputMessage inputMessage = createHttpInputMessage(webRequest);
	    HttpOutputMessage outputMessage = createHttpOutputMessage(webRequest);
	    writeWithMessageConverters(returnValue, inputMessage, outputMessage);
	}

	private void handleHttpEntityResponse(HttpEntity<?> responseEntity, ServletWebRequest webRequest)
		throws Exception {
	    if (responseEntity == null) {
		return;
	    }
	    HttpInputMessage inputMessage = createHttpInputMessage(webRequest);
	    HttpOutputMessage outputMessage = createHttpOutputMessage(webRequest);
	    if (responseEntity instanceof ResponseEntity && outputMessage instanceof ServerHttpResponse) {
		((ServerHttpResponse) outputMessage)
			.setStatusCode(((ResponseEntity<?>) responseEntity).getStatusCode());
	    }
	    HttpHeaders entityHeaders = responseEntity.getHeaders();
	    if (!entityHeaders.isEmpty()) {
		outputMessage.getHeaders().putAll(entityHeaders);
	    }
	    Object body = responseEntity.getBody();
	    if (body != null) {
		writeWithMessageConverters(body, inputMessage, outputMessage);
	    } else {
		// flush headers
		outputMessage.getBody();
	    }
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	private void writeWithMessageConverters(Object returnValue, HttpInputMessage inputMessage,
		HttpOutputMessage outputMessage) throws IOException, HttpMediaTypeNotAcceptableException {

	    List<MediaType> acceptedMediaTypes = inputMessage.getHeaders().getAccept();
	    if (acceptedMediaTypes.isEmpty()) {
		acceptedMediaTypes = Collections.singletonList(MediaType.ALL);
	    }
	    MediaType.sortByQualityValue(acceptedMediaTypes);
	    Class<?> returnValueType = returnValue.getClass();
	    List<MediaType> allSupportedMediaTypes = new ArrayList<>();
	    if (getMessageConverters() != null) {
		for (MediaType acceptedMediaType : acceptedMediaTypes) {
		    for (HttpMessageConverter messageConverter : getMessageConverters()) {
			if (messageConverter.canWrite(returnValueType, acceptedMediaType)) {
			    messageConverter.write(returnValue, acceptedMediaType, outputMessage);
			    if (logger.isDebugEnabled()) {
				MediaType contentType = outputMessage.getHeaders().getContentType();
				if (contentType == null) {
				    contentType = acceptedMediaType;
				}
				logger.debug("Written [" + returnValue + "] as \"" + contentType + "\" using ["
					+ messageConverter + "]");
			    }
			    this.responseArgumentUsed = true;
			    return;
			}
		    }
		}
		for (HttpMessageConverter messageConverter : messageConverters) {
		    allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());
		}
	    }
	    throw new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);
	}
    }

    /**
     * Holder for request mapping metadata.
     */
    static class RequestMappingInfo {

	private final String[] patterns;

	private final RequestMethod[] methods;

	private final String[] params;

	private final String[] headers;

	RequestMappingInfo(String[] patterns, RequestMethod[] methods, String[] params, String[] headers) {
	    this.patterns = (patterns != null ? patterns : new String[0]);
	    this.methods = (methods != null ? methods : new RequestMethod[0]);
	    this.params = (params != null ? params : new String[0]);
	    this.headers = (headers != null ? headers : new String[0]);
	}

	public boolean hasPatterns() {
	    return (this.patterns.length > 0);
	}

	public String[] getPatterns() {
	    return this.patterns;
	}

	public int getMethodCount() {
	    return this.methods.length;
	}

	public int getParamCount() {
	    return this.params.length;
	}

	public int getHeaderCount() {
	    return this.headers.length;
	}

	public boolean matches(HttpServletRequest request) {
	    return matchesRequestMethod(request) && matchesParameters(request) && matchesHeaders(request);
	}

	public boolean matchesHeaders(HttpServletRequest request) {
	    return ServletAnnotationMappingUtils.checkHeaders(this.headers, request);
	}

	public boolean matchesParameters(HttpServletRequest request) {
	    return ServletAnnotationMappingUtils.checkParameters(this.params, request);
	}

	public boolean matchesRequestMethod(HttpServletRequest request) {
	    return ServletAnnotationMappingUtils.checkRequestMethod(this.methods, request);
	}

	public Set<String> methodNames() {
	    Set<String> methodNames = new LinkedHashSet<>(this.methods.length);
	    for (RequestMethod method : this.methods) {
		methodNames.add(method.name());
	    }
	    return methodNames;
	}

	@Override
	public boolean equals(Object obj) {
	    RequestMappingInfo other = (RequestMappingInfo) obj;
	    return (Arrays.equals(this.patterns, other.patterns) && Arrays.equals(this.methods, other.methods)
		    && Arrays.equals(this.params, other.params) && Arrays.equals(this.headers, other.headers));
	}

	@Override
	public int hashCode() {
	    return (Arrays.hashCode(this.patterns) * 23 + Arrays.hashCode(this.methods) * 29
		    + Arrays.hashCode(this.params) * 31 + Arrays.hashCode(this.headers));
	}

	@Override
	public String toString() {
	    StringBuilder builder = new StringBuilder();
	    builder.append(Arrays.asList(this.patterns));
	    if (this.methods.length > 0) {
		builder.append(',');
		builder.append(Arrays.asList(this.methods));
	    }
	    if (this.headers.length > 0) {
		builder.append(',');
		builder.append(Arrays.asList(this.headers));
	    }
	    if (this.params.length > 0) {
		builder.append(',');
		builder.append(Arrays.asList(this.params));
	    }
	    return builder.toString();
	}
    }

    /**
     * Subclass of {@link RequestMappingInfo} that holds request-specific data.
     */
    static class RequestSpecificMappingInfo extends RequestMappingInfo {

	private final List<String> matchedPatterns = new ArrayList<>();

	RequestSpecificMappingInfo(String[] patterns, RequestMethod[] methods, String[] params, String[] headers) {
	    super(patterns, methods, params, headers);
	}

	RequestSpecificMappingInfo(RequestMappingInfo other) {
	    super(other.patterns, other.methods, other.params, other.headers);
	}

	public void addMatchedPattern(String matchedPattern) {
	    matchedPatterns.add(matchedPattern);
	}

	public void sortMatchedPatterns(Comparator<String> pathComparator) {
	    Collections.sort(matchedPatterns, pathComparator);
	}

	public String bestMatchedPattern() {
	    return (!this.matchedPatterns.isEmpty() ? this.matchedPatterns.get(0) : null);
	}
    }

    /**
     * Comparator capable of sorting {@link RequestSpecificMappingInfo}s (RHIs) so that
     * sorting a list with this comparator will result in:
     * <ul>
     * <li>RHIs with {@linkplain AnnotationMethodHandlerAdapter.RequestSpecificMappingInfo#matchedPatterns better
     * matched paths}
     * take precedence over those with a weaker match (as expressed by the
     * {@linkplain PathMatcher#getPatternComparator(String)
     * path pattern comparator}.) Typically, this means that patterns without wild cards and uri templates
     * will be ordered before those without.</li>
     * <li>RHIs with one single {@linkplain RequestMappingInfo#methods request method} will be
     * ordered before those without a method, or with more than one method.</li>
     * <li>RHIs with more {@linkplain RequestMappingInfo#params request parameters} will be ordered
     * before those with less parameters</li>
     * </ol>
     */
    static class RequestSpecificMappingInfoComparator implements Comparator<RequestSpecificMappingInfo> {

	private final Comparator<String> pathComparator;

	private final ServerHttpRequest request;

	RequestSpecificMappingInfoComparator(Comparator<String> pathComparator, HttpServletRequest request) {
	    this.pathComparator = pathComparator;
	    this.request = new ServletServerHttpRequest(request);
	}

	@Override
	public int compare(RequestSpecificMappingInfo info1, RequestSpecificMappingInfo info2) {
	    int pathComparison = pathComparator.compare(info1.bestMatchedPattern(), info2.bestMatchedPattern());
	    if (pathComparison != 0) {
		return pathComparison;
	    }
	    int info1ParamCount = info1.getParamCount();
	    int info2ParamCount = info2.getParamCount();
	    if (info1ParamCount != info2ParamCount) {
		return info2ParamCount - info1ParamCount;
	    }
	    int info1HeaderCount = info1.getHeaderCount();
	    int info2HeaderCount = info2.getHeaderCount();
	    if (info1HeaderCount != info2HeaderCount) {
		return info2HeaderCount - info1HeaderCount;
	    }
	    int acceptComparison = compareAcceptHeaders(info1, info2);
	    if (acceptComparison != 0) {
		return acceptComparison;
	    }
	    int info1MethodCount = info1.getMethodCount();
	    int info2MethodCount = info2.getMethodCount();
	    if (info1MethodCount == 0 && info2MethodCount > 0) {
		return 1;
	    } else if (info2MethodCount == 0 && info1MethodCount > 0) {
		return -1;
	    } else if (info1MethodCount == 1 & info2MethodCount > 1) {
		return -1;
	    } else if (info2MethodCount == 1 & info1MethodCount > 1) {
		return 1;
	    }
	    return 0;
	}

	private int compareAcceptHeaders(RequestMappingInfo info1, RequestMappingInfo info2) {
	    List<MediaType> requestAccepts = request.getHeaders().getAccept();
	    MediaType.sortByQualityValue(requestAccepts);

	    List<MediaType> info1Accepts = getAcceptHeaderValue(info1);
	    List<MediaType> info2Accepts = getAcceptHeaderValue(info2);

	    for (MediaType requestAccept : requestAccepts) {
		int pos1 = indexOfIncluded(info1Accepts, requestAccept);
		int pos2 = indexOfIncluded(info2Accepts, requestAccept);
		if (pos1 != pos2) {
		    return pos2 - pos1;
		}
	    }
	    return 0;
	}

	private int indexOfIncluded(List<MediaType> infoAccepts, MediaType requestAccept) {
	    for (int i = 0; i < infoAccepts.size(); i++) {
		MediaType info1Accept = infoAccepts.get(i);
		if (requestAccept.includes(info1Accept)) {
		    return i;
		}
	    }
	    return -1;
	}

	private List<MediaType> getAcceptHeaderValue(RequestMappingInfo info) {
	    for (String header : info.headers) {
		int separator = header.indexOf('=');
		if (separator != -1) {
		    String key = header.substring(0, separator);
		    String value = header.substring(separator + 1);
		    if ("Accept".equalsIgnoreCase(key)) {
			return MediaType.parseMediaTypes(value);
		    }
		}
	    }
	    return Collections.emptyList();
	}
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/BeanFactoryLocator.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import org.springframework.beans.BeansException;

/**
 * Defines a contract for the lookup, use, and release of a
 * {@link org.springframework.beans.factory.BeanFactory},
 * or a {@code BeanFactory} subclass such as an
 * {@link org.springframework.context.ApplicationContext}.
 *
 * <p>
 * Where this interface is implemented as a singleton class such as
 * {@link SingletonBeanFactoryLocator}, the Spring team <strong>strongly</strong>
 * suggests that it be used sparingly and with caution. By far the vast majority
 * of the code inside an application is best written in a Dependency Injection
 * style, where that code is served out of a
 * {@code BeanFactory}/{@code ApplicationContext} container, and has
 * its own dependencies supplied by the container when it is created. However,
 * even such a singleton implementation sometimes has its use in the small glue
 * layers of code that is sometimes needed to tie other code together. For
 * example, third party code may try to construct new objects directly, without
 * the ability to force it to get these objects out of a {@code BeanFactory}.
 * If the object constructed by the third party code is just a small stub or
 * proxy, which then uses an implementation of this class to get a
 * {@code BeanFactory} from which it gets the real object, to which it
 * delegates, then proper Dependency Injection has been achieved.
 *
 * <p>
 * As another example, in a complex J2EE app with multiple layers, with each
 * layer having its own {@code ApplicationContext} definition (in a
 * hierarchy), a class like {@code SingletonBeanFactoryLocator} may be used
 * to demand load these contexts.
 *
 * @author Colin Sampaleanu
 * @see org.springframework.beans.factory.BeanFactory
 * @see org.springframework.context.access.DefaultLocatorFactory
 * @see org.springframework.context.ApplicationContext
 */
public interface BeanFactoryLocator {

    /**
     * Use the {@link org.springframework.beans.factory.BeanFactory} (or derived
     * interface such as {@link org.springframework.context.ApplicationContext})
     * specified by the {@code factoryKey} parameter.
     * <p>
     * The definition is possibly loaded/created as needed.
     *
     * @param factoryKey
     *            a resource name specifying which {@code BeanFactory} the
     *            {@code BeanFactoryLocator} must return for usage. The actual meaning of the
     *            resource name is specific to the implementation of {@code BeanFactoryLocator}.
     * @return the {@code BeanFactory} instance, wrapped as a {@link BeanFactoryReference} object
     * @throws BeansException
     *             if there is an error loading or accessing the {@code BeanFactory}
     */
    BeanFactoryReference useBeanFactory(String factoryKey) throws BeansException;

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/BeanFactoryReference.java
================================================
/*
 * Copyright 2002-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import org.springframework.beans.factory.BeanFactory;

/**
 * Used to track a reference to a {@link BeanFactory} obtained through
 * a {@link BeanFactoryLocator}.
 *
 * <p>It is safe to call {@link #release()} multiple times, but
 * {@link #getFactory()} must not be called after calling release.
 *
 * @author Colin Sampaleanu
 * @see BeanFactoryLocator
 * @see org.springframework.context.access.ContextBeanFactoryReference
 */
public interface BeanFactoryReference {

	/**
	 * Return the {@link BeanFactory} instance held by this reference.
	 * @throws IllegalStateException if invoked after {@code release()} has been called
	 */
	BeanFactory getFactory();

	/**
	 * Indicate that the {@link BeanFactory} instance referred to by this object is not
	 * needed any longer by the client code which obtained the {@link BeanFactoryReference}.
	 * <p>Depending on the actual implementation of {@link BeanFactoryLocator}, and
	 * the actual type of {@code BeanFactory}, this may possibly not actually
	 * do anything; alternately in the case of a 'closeable' {@code BeanFactory}
	 * or derived class (such as {@link org.springframework.context.ApplicationContext})
	 * may 'close' it, or may 'close' it once no more references remain.
	 * <p>In an EJB usage scenario this would normally be called from
	 * {@code ejbRemove()} and {@code ejbPassivate()}.
	 * <p>This is safe to call multiple times.
	 * @see BeanFactoryLocator
	 * @see org.springframework.context.access.ContextBeanFactoryReference
	 * @see org.springframework.context.ConfigurableApplicationContext#close()
	 */
	void release();

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/BootstrapException.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import org.springframework.beans.FatalBeanException;

/**
 * Exception thrown if a bean factory could not be loaded by a bootstrap class.
 *
 * @author Rod Johnson
 * @since 02.12.2002
 */
@SuppressWarnings("serial")
public class BootstrapException extends FatalBeanException {

    /**
     * Create a new BootstrapException with the specified message.
     *
     * @param msg
     *            the detail message
     */
    public BootstrapException(String msg) {
	super(msg);
    }

    /**
     * Create a new BootstrapException with the specified message
     * and root cause.
     *
     * @param msg
     *            the detail message
     * @param cause
     *            the root cause
     */
    public BootstrapException(String msg, Throwable cause) {
	super(msg, cause);
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/ContextSingletonBeanFactoryLocator.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.context.ConfigurableApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternUtils;

/**
 * <p>
 * Variant of {@link com.ejie.x38.spring.context.access.SingletonBeanFactoryLocator}
 * which creates its internal bean factory reference as an
 * {@link org.springframework.context.ApplicationContext} instead of
 * SingletonBeanFactoryLocator's simple BeanFactory. For almost all usage scenarios,
 * this will not make a difference, since within that ApplicationContext or BeanFactory
 * you are still free to define either BeanFactory or ApplicationContext instances.
 * The main reason one would need to use this class is if bean post-processing
 * (or other ApplicationContext specific features are needed in the bean reference
 * definition itself).
 *
 * <p>
 * <strong>Note:</strong> This class uses <strong>classpath*:beanRefContext.xml</strong>
 * as the default resource location for the bean factory reference definition files.
 * It is not possible nor legal to share definitions with SingletonBeanFactoryLocator
 * at the same time.
 *
 * @author Colin Sampaleanu
 * @author Juergen Hoeller
 * @see com.ejie.x38.spring.context.access.SingletonBeanFactoryLocator
 * @see org.springframework.context.access.DefaultLocatorFactory
 */
public class ContextSingletonBeanFactoryLocator extends SingletonBeanFactoryLocator {

    private static final String DEFAULT_RESOURCE_LOCATION = "classpath*:beanRefContext.xml";

    /** The keyed singleton instances */
    private static final Map<String, BeanFactoryLocator> instances = new HashMap<>();

    /**
     * Returns an instance which uses the default "classpath*:beanRefContext.xml", as
     * the name of the definition file(s). All resources returned by the current
     * thread's context class loader's {@code getResources} method with this
     * name will be combined to create a definition, which is just a BeanFactory.
     *
     * @return the corresponding BeanFactoryLocator instance
     * @throws BeansException
     *             in case of factory loading failure
     */
    public static BeanFactoryLocator getInstance() throws BeansException {
	return ContextSingletonBeanFactoryLocator.getInstance(null);
    }

    /**
     * Returns an instance which uses the specified selector, as the name of the
     * definition file(s). In the case of a name with a Spring "classpath*:" prefix,
     * or with no prefix, which is treated the same, the current thread's context class
     * loader's {@code getResources} method will be called with this value to get
     * all resources having that name. These resources will then be combined to form a
     * definition. In the case where the name uses a Spring "classpath:" prefix, or
     * a standard URL prefix, then only one resource file will be loaded as the
     * definition.
     *
     * @param selector
     *            the location of the resource(s) which will be read and
     *            combined to form the definition for the BeanFactoryLocator instance.
     *            Any such files must form a valid ApplicationContext definition.
     * @return the corresponding BeanFactoryLocator instance
     * @throws BeansException
     *             in case of factory loading failure
     */
    public static BeanFactoryLocator getInstance(String selector) throws BeansException {
	String resourceLocation = selector;
	if (resourceLocation == null) {
	    resourceLocation = DEFAULT_RESOURCE_LOCATION;
	}

	// For backwards compatibility, we prepend "classpath*:" to the selector name if there
	// is no other prefix (i.e. "classpath*:", "classpath:", or some URL prefix).
	if (!ResourcePatternUtils.isUrl(resourceLocation)) {
	    resourceLocation = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resourceLocation;
	}

	synchronized (instances) {
	    if (logger.isTraceEnabled()) {
		logger.trace("ContextSingletonBeanFactoryLocator.getInstance(): instances.hashCode="
			+ instances.hashCode() + ", instances=" + instances);
	    }
	    BeanFactoryLocator bfl = instances.get(resourceLocation);
	    if (bfl == null) {
		bfl = new ContextSingletonBeanFactoryLocator(resourceLocation);
		instances.put(resourceLocation, bfl);
	    }
	    return bfl;
	}
    }

    /**
     * Constructor which uses the specified name as the resource name
     * of the definition file(s).
     *
     * @param resourceLocation
     *            the Spring resource location to use
     *            (either a URL or a "classpath:" / "classpath*:" pseudo URL)
     */
    protected ContextSingletonBeanFactoryLocator(String resourceLocation) {
	super(resourceLocation);
    }

    /**
     * Overrides the default method to create definition object as an ApplicationContext
     * instead of the default BeanFactory. This does not affect what can actually
     * be loaded by that definition.
     * <p>
     * The default implementation simply builds a
     * {@link org.springframework.context.support.ClassPathXmlApplicationContext}.
     */
    @Override
    protected BeanFactory createDefinition(String resourceLocation, String factoryKey) {
	return new ClassPathXmlApplicationContext(new String[] { resourceLocation }, false);
    }

    /**
     * Overrides the default method to refresh the ApplicationContext, invoking
     * {@link ConfigurableApplicationContext#refresh ConfigurableApplicationContext.refresh()}.
     */
    @Override
    protected void initializeDefinition(BeanFactory groupDef) {
	if (groupDef instanceof ConfigurableApplicationContext) {
	    ((ConfigurableApplicationContext) groupDef).refresh();
	}
    }

    /**
     * Overrides the default method to operate on an ApplicationContext, invoking
     * {@link ConfigurableApplicationContext#refresh ConfigurableApplicationContext.close()}.
     */
    @Override
    protected void destroyDefinition(BeanFactory groupDef, String selector) {
	if (groupDef instanceof ConfigurableApplicationContext) {
	    if (logger.isTraceEnabled()) {
		logger.trace("Context group with selector '" + selector
			+ "' being released, as there are no more references to it");
	    }
	    ((ConfigurableApplicationContext) groupDef).close();
	}
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/DefaultAnnotationHandlerMapping.java
================================================
/*
 * Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.Set;

import javax.servlet.http.HttpServletRequest;

import org.springframework.context.ApplicationContext;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.stereotype.Controller;
import org.springframework.util.ReflectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.ServletRequestBindingException;
import org.springframework.web.bind.UnsatisfiedServletRequestParameterException;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.servlet.handler.AbstractDetectingUrlHandlerMapping;

/**
 * Implementation of the {@link org.springframework.web.servlet.HandlerMapping}
 * interface that maps handlers based on HTTP paths expressed through the
 * {@link RequestMapping} annotation at the type or method level.
 *
 * <p>
 * Registered by default in {@link org.springframework.web.servlet.DispatcherServlet}
 * on Java 5+. <b>NOTE:</b> If you define custom HandlerMapping beans in your
 * DispatcherServlet context, you need to add a DefaultAnnotationHandlerMapping bean
 * explicitly, since custom HandlerMapping beans replace the default mapping strategies.
 * Defining a DefaultAnnotationHandlerMapping also allows for registering custom
 * interceptors:
 *
 * <pre class="code">
 * &lt;bean class="org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping"&gt;
 *   &lt;property name="interceptors"&gt;
 *     ...
 *   &lt;/property&gt;
 * &lt;/bean&gt;
 * </pre>
 *
 * Annotated controllers are usually marked with the {@link Controller} stereotype
 * at the type level. This is not strictly necessary when {@link RequestMapping} is
 * applied at the type level (since such a handler usually implements the
 * {@link org.springframework.web.servlet.mvc.Controller} interface). However,
 * {@link Controller} is required for detecting {@link RequestMapping} annotations
 * at the method level if {@link RequestMapping} is not present at the type level.
 *
 * <p>
 * <b>NOTE:</b> Method-level mappings are only allowed to narrow the mapping
 * expressed at the class level (if any). HTTP paths need to uniquely map onto
 * specific handler beans, with any given HTTP path only allowed to be mapped
 * onto one specific handler bean (not spread across multiple handler beans).
 * It is strongly recommended to co-locate related handler methods into the same bean.
 *
 * <p>
 * The {@link AnnotationMethodHandlerAdapter} is responsible for processing
 * annotated handler methods, as mapped by this HandlerMapping. For
 * {@link RequestMapping} at the type level, specific HandlerAdapters such as
 * {@link org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter} apply.
 *
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @since 2.5
 * @see RequestMapping
 * @see AnnotationMethodHandlerAdapter
 * @deprecated as of Spring 3.2, in favor of
 *             {@link org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping
 *             RequestMappingHandlerMapping}
 */
@Deprecated
public class DefaultAnnotationHandlerMapping extends AbstractDetectingUrlHandlerMapping {

    static final String USE_DEFAULT_SUFFIX_PATTERN = DefaultAnnotationHandlerMapping.class.getName()
	    + ".useDefaultSuffixPattern";

    private boolean useDefaultSuffixPattern = true;

    private final Map<Class<?>, RequestMapping> cachedMappings = new HashMap<>();

    /**
     * Set whether to register paths using the default suffix pattern as well:
     * i.e. whether "/users" should be registered as "/users.*" and "/users/" too.
     * <p>
     * Default is "true". Turn this convention off if you intend to interpret
     * your {@code @RequestMapping} paths strictly.
     * <p>
     * Note that paths which include a ".xxx" suffix or end with "/" already will not be
     * transformed using the default suffix pattern in any case.
     */
    public void setUseDefaultSuffixPattern(boolean useDefaultSuffixPattern) {
	this.useDefaultSuffixPattern = useDefaultSuffixPattern;
    }

    /**
     * Checks for presence of the {@link org.springframework.web.bind.annotation.RequestMapping}
     * annotation on the handler class and on any of its methods.
     */
    @Override
    protected String[] determineUrlsForHandler(String beanName) {
	ApplicationContext context = getApplicationContext();
	Class<?> handlerType = context.getType(beanName);
	RequestMapping mapping = context.findAnnotationOnBean(beanName, RequestMapping.class);
	if (mapping != null) {
	    // @RequestMapping found at type level
	    this.cachedMappings.put(handlerType, mapping);
	    Set<String> urls = new LinkedHashSet<>();
	    String[] typeLevelPatterns = mapping.value();
	    if (typeLevelPatterns.length > 0) {
		// @RequestMapping specifies paths at type level
		String[] methodLevelPatterns = determineUrlsForHandlerMethods(handlerType, true);
		for (String typeLevelPattern : typeLevelPatterns) {
		    if (!typeLevelPattern.startsWith("/")) {
			typeLevelPattern = "/" + typeLevelPattern;
		    }
		    boolean hasEmptyMethodLevelMappings = false;
		    for (String methodLevelPattern : methodLevelPatterns) {
			if (methodLevelPattern == null) {
			    hasEmptyMethodLevelMappings = true;
			} else {
			    String combinedPattern = getPathMatcher().combine(typeLevelPattern, methodLevelPattern);
			    addUrlsForPath(urls, combinedPattern);
			}
		    }
		    if (hasEmptyMethodLevelMappings
			    || org.springframework.web.servlet.mvc.Controller.class.isAssignableFrom(handlerType)) {
			addUrlsForPath(urls, typeLevelPattern);
		    }
		}
		return StringUtils.toStringArray(urls);
	    } else {
		// actual paths specified by @RequestMapping at method level
		return determineUrlsForHandlerMethods(handlerType, false);
	    }
	} else if (AnnotationUtils.findAnnotation(handlerType, Controller.class) != null) {
	    // @RequestMapping to be introspected at method level
	    return determineUrlsForHandlerMethods(handlerType, false);
	} else {
	    return null;
	}
    }

    /**
     * Derive URL mappings from the handler's method-level mappings.
     *
     * @param handlerType
     *            the handler type to introspect
     * @param hasTypeLevelMapping
     *            whether the method-level mappings are nested
     *            within a type-level mapping
     * @return the array of mapped URLs
     */
    protected String[] determineUrlsForHandlerMethods(Class<?> handlerType, final boolean hasTypeLevelMapping) {
	String[] subclassResult = determineUrlsForHandlerMethods(handlerType);
	if (subclassResult != null) {
	    return subclassResult;
	}

	final Set<String> urls = new LinkedHashSet<>();
	Set<Class<?>> handlerTypes = new LinkedHashSet<>();
	handlerTypes.add(handlerType);
	handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));
	for (Class<?> currentHandlerType : handlerTypes) {
	    ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
		@Override
		public void doWith(Method method) {
		    RequestMapping mapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);
		    if (mapping != null) {
			String[] mappedPatterns = mapping.value();
			if (mappedPatterns.length > 0) {
			    for (String mappedPattern : mappedPatterns) {
				if (!hasTypeLevelMapping && !mappedPattern.startsWith("/")) {
				    mappedPattern = "/" + mappedPattern;
				}
				addUrlsForPath(urls, mappedPattern);
			    }
			} else if (hasTypeLevelMapping) {
			    // empty method-level RequestMapping
			    urls.add(null);
			}
		    }
		}
	    }, ReflectionUtils.USER_DECLARED_METHODS);
	}
	return StringUtils.toStringArray(urls);
    }

    /**
     * Derive URL mappings from the handler's method-level mappings.
     *
     * @param handlerType
     *            the handler type to introspect
     * @return the array of mapped URLs
     */
    protected String[] determineUrlsForHandlerMethods(Class<?> handlerType) {
	return null;
    }

    /**
     * Add URLs and/or URL patterns for the given path.
     *
     * @param urls
     *            the Set of URLs for the current bean
     * @param path
     *            the currently introspected path
     */
    protected void addUrlsForPath(Set<String> urls, String path) {
	urls.add(path);
	if (this.useDefaultSuffixPattern && path.indexOf('.') == -1 && !path.endsWith("/")) {
	    urls.add(path + ".*");
	    urls.add(path + "/");
	}
    }

    /**
     * Validate the given annotated handler against the current request.
     *
     * @see #validateMapping
     */
    @Override
    protected void validateHandler(Object handler, HttpServletRequest request) throws Exception {
	RequestMapping mapping = this.cachedMappings.get(handler.getClass());
	if (mapping == null) {
	    mapping = AnnotationUtils.findAnnotation(handler.getClass(), RequestMapping.class);
	}
	if (mapping != null) {
	    validateMapping(mapping, request);
	}
	request.setAttribute(USE_DEFAULT_SUFFIX_PATTERN, this.useDefaultSuffixPattern);
    }

    /**
     * Validate the given type-level mapping metadata against the current request,
     * checking HTTP request method and parameter conditions.
     *
     * @param mapping
     *            the mapping metadata to validate
     * @param request
     *            current HTTP request
     * @throws Exception
     *             if validation failed
     */
    protected void validateMapping(RequestMapping mapping, HttpServletRequest request) throws Exception {
	RequestMethod[] mappedMethods = mapping.method();
	if (!ServletAnnotationMappingUtils.checkRequestMethod(mappedMethods, request)) {
	    String[] supportedMethods = new String[mappedMethods.length];
	    for (int i = 0; i < mappedMethods.length; i++) {
		supportedMethods[i] = mappedMethods[i].name();
	    }
	    throw new HttpRequestMethodNotSupportedException(request.getMethod(), supportedMethods);
	}

	String[] mappedParams = mapping.params();
	if (!ServletAnnotationMappingUtils.checkParameters(mappedParams, request)) {
	    throw new UnsatisfiedServletRequestParameterException(mappedParams, request.getParameterMap());
	}

	String[] mappedHeaders = mapping.headers();
	if (!ServletAnnotationMappingUtils.checkHeaders(mappedHeaders, request)) {
	    throw new ServletRequestBindingException("Header conditions \""
		    + StringUtils.arrayToDelimitedString(mappedHeaders, ", ") + "\" not met for actual request");
	}
    }

    @Override
    protected boolean supportsTypeLevelMappings() {
	return true;
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/HandlerMethodInvocationException.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.lang.reflect.Method;

import org.springframework.core.NestedRuntimeException;

/**
 * Exception indicating that the execution of an annotated MVC handler method failed.
 *
 * @author Juergen Hoeller
 * @since 2.5.6
 * @see HandlerMethodInvoker#invokeHandlerMethod
 * @deprecated as of 4.3, in favor of the {@code HandlerMethod}-based MVC infrastructure
 */
@Deprecated
@SuppressWarnings("serial")
public class HandlerMethodInvocationException extends NestedRuntimeException {

	/**
	 * Create a new HandlerMethodInvocationException for the given Method handle and cause.
	 * @param handlerMethod the handler method handle
	 * @param cause the cause of the invocation failure
	 */
	public HandlerMethodInvocationException(Method handlerMethod, Throwable cause) {
		super("Failed to invoke handler method [" + handlerMethod + "]", cause);
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/HandlerMethodInvoker.java
================================================
/*
 * Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.lang.annotation.Annotation;
import java.lang.reflect.Array;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.BridgeMethodResolver;
import org.springframework.core.Conventions;
import org.springframework.core.GenericTypeResolver;
import org.springframework.core.MethodParameter;
import org.springframework.core.ParameterNameDiscoverer;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.core.annotation.SynthesizingMethodParameter;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.ui.ExtendedModelMap;
import org.springframework.ui.Model;
import org.springframework.util.Assert;
import org.springframework.util.ClassUtils;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.util.ReflectionUtils;
import org.springframework.validation.BindException;
import org.springframework.validation.BindingResult;
import org.springframework.validation.Errors;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.HttpMediaTypeNotSupportedException;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.CookieValue;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ValueConstants;
import org.springframework.web.bind.support.DefaultSessionAttributeStore;
import org.springframework.web.bind.support.SessionAttributeStore;
import org.springframework.web.bind.support.SessionStatus;
import org.springframework.web.bind.support.SimpleSessionStatus;
import org.springframework.web.bind.support.WebArgumentResolver;
import org.springframework.web.bind.support.WebBindingInitializer;
import org.springframework.web.bind.support.WebRequestDataBinder;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.multipart.MultipartRequest;

/**
 * Support class for invoking an annotated handler method. Operates on the introspection
 * results of a {@link HandlerMethodResolver} for a specific handler type.
 *
 * <p>Used by {@link org.springframework.com.ejie.x38.spring.context.AnnotationMethodHandlerAdapter}
 * and {@link com.ejie.x38.spring.context.portlet.mvc.annotation.AnnotationMethodHandlerAdapter}.
 *
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @since 2.5.2
 * @see #invokeHandlerMethod
 * @deprecated as of 4.3, in favor of the {@code HandlerMethod}-based MVC infrastructure
 */
@Deprecated
public class HandlerMethodInvoker {

	private static final String MODEL_KEY_PREFIX_STALE = SessionAttributeStore.class.getName() + ".STALE.";

	/** We'll create a lot of these objects, so we don't want a new logger every time. */
	private static final Log logger = LogFactory.getLog(HandlerMethodInvoker.class);

	private final HandlerMethodResolver methodResolver;

	private final WebBindingInitializer bindingInitializer;

	private final SessionAttributeStore sessionAttributeStore;

	private final ParameterNameDiscoverer parameterNameDiscoverer;

	private final WebArgumentResolver[] customArgumentResolvers;

	private final HttpMessageConverter<?>[] messageConverters;

	private final SimpleSessionStatus sessionStatus = new SimpleSessionStatus();


	public HandlerMethodInvoker(HandlerMethodResolver methodResolver) {
		this(methodResolver, null);
	}

	public HandlerMethodInvoker(HandlerMethodResolver methodResolver, WebBindingInitializer bindingInitializer) {
		this(methodResolver, bindingInitializer, new DefaultSessionAttributeStore(), null, null, null);
	}

	public HandlerMethodInvoker(HandlerMethodResolver methodResolver, WebBindingInitializer bindingInitializer,
			SessionAttributeStore sessionAttributeStore, ParameterNameDiscoverer parameterNameDiscoverer,
			WebArgumentResolver[] customArgumentResolvers, HttpMessageConverter<?>[] messageConverters) {

		this.methodResolver = methodResolver;
		this.bindingInitializer = bindingInitializer;
		this.sessionAttributeStore = sessionAttributeStore;
		this.parameterNameDiscoverer = parameterNameDiscoverer;
		this.customArgumentResolvers = customArgumentResolvers;
		this.messageConverters = messageConverters;
	}


	public final Object invokeHandlerMethod(Method handlerMethod, Object handler,
			NativeWebRequest webRequest, ExtendedModelMap implicitModel) throws Exception {

		Method handlerMethodToInvoke = BridgeMethodResolver.findBridgedMethod(handlerMethod);
		try {
			boolean debug = logger.isDebugEnabled();
			for (String attrName : this.methodResolver.getActualSessionAttributeNames()) {
				Object attrValue = this.sessionAttributeStore.retrieveAttribute(webRequest, attrName);
				if (attrValue != null) {
					implicitModel.addAttribute(attrName, attrValue);
				}
			}
			for (Method attributeMethod : this.methodResolver.getModelAttributeMethods()) {
				Method attributeMethodToInvoke = BridgeMethodResolver.findBridgedMethod(attributeMethod);
				Object[] args = resolveHandlerArguments(attributeMethodToInvoke, handler, webRequest, implicitModel);
				if (debug) {
					logger.debug("Invoking model attribute method: " + attributeMethodToInvoke);
				}
				String attrName = AnnotationUtils.findAnnotation(attributeMethod, ModelAttribute.class).value();
				if (!"".equals(attrName) && implicitModel.containsAttribute(attrName)) {
					continue;
				}
				ReflectionUtils.makeAccessible(attributeMethodToInvoke);
				Object attrValue = attributeMethodToInvoke.invoke(handler, args);
				if ("".equals(attrName)) {
					Class<?> resolvedType = GenericTypeResolver.resolveReturnType(attributeMethodToInvoke, handler.getClass());
					attrName = Conventions.getVariableNameForReturnType(attributeMethodToInvoke, resolvedType, attrValue);
				}
				if (!implicitModel.containsAttribute(attrName)) {
					implicitModel.addAttribute(attrName, attrValue);
				}
			}
			Object[] args = resolveHandlerArguments(handlerMethodToInvoke, handler, webRequest, implicitModel);
			if (debug) {
				logger.debug("Invoking request handler method: " + handlerMethodToInvoke);
			}
			ReflectionUtils.makeAccessible(handlerMethodToInvoke);
			return handlerMethodToInvoke.invoke(handler, args);
		}
		catch (IllegalStateException ex) {
			// Internal assertion failed (e.g. invalid signature):
			// throw exception with full handler method context...
			throw new HandlerMethodInvocationException(handlerMethodToInvoke, ex);
		}
		catch (InvocationTargetException ex) {
			// User-defined @ModelAttribute/@InitBinder/@RequestMapping method threw an exception...
			ReflectionUtils.rethrowException(ex.getTargetException());
			return null;
		}
	}

	public final void updateModelAttributes(Object handler, Map<String, Object> mavModel,
			ExtendedModelMap implicitModel, NativeWebRequest webRequest) throws Exception {

		if (this.methodResolver.hasSessionAttributes() && this.sessionStatus.isComplete()) {
			for (String attrName : this.methodResolver.getActualSessionAttributeNames()) {
				this.sessionAttributeStore.cleanupAttribute(webRequest, attrName);
			}
		}

		// Expose model attributes as session attributes, if required.
		// Expose BindingResults for all attributes, making custom editors available.
		Map<String, Object> model = (mavModel != null ? mavModel : implicitModel);
		if (model != null) {
			try {
				String[] originalAttrNames = model.keySet().toArray(new String[model.size()]);
				for (String attrName : originalAttrNames) {
					Object attrValue = model.get(attrName);
					boolean isSessionAttr = this.methodResolver.isSessionAttribute(
							attrName, (attrValue != null ? attrValue.getClass() : null));
					if (isSessionAttr) {
						if (this.sessionStatus.isComplete()) {
							implicitModel.put(MODEL_KEY_PREFIX_STALE + attrName, Boolean.TRUE);
						}
						else if (!implicitModel.containsKey(MODEL_KEY_PREFIX_STALE + attrName)) {
							this.sessionAttributeStore.storeAttribute(webRequest, attrName, attrValue);
						}
					}
					if (!attrName.startsWith(BindingResult.MODEL_KEY_PREFIX) &&
							(isSessionAttr || isBindingCandidate(attrValue))) {
						String bindingResultKey = BindingResult.MODEL_KEY_PREFIX + attrName;
						if (mavModel != null && !model.containsKey(bindingResultKey)) {
							WebDataBinder binder = createBinder(webRequest, attrValue, attrName);
							initBinder(handler, attrName, binder, webRequest);
							mavModel.put(bindingResultKey, binder.getBindingResult());
						}
					}
				}
			}
			catch (InvocationTargetException ex) {
				// User-defined @InitBinder method threw an exception...
				ReflectionUtils.rethrowException(ex.getTargetException());
			}
		}
	}


	private Object[] resolveHandlerArguments(Method handlerMethod, Object handler,
			NativeWebRequest webRequest, ExtendedModelMap implicitModel) throws Exception {

		Class<?>[] paramTypes = handlerMethod.getParameterTypes();
		Object[] args = new Object[paramTypes.length];

		for (int i = 0; i < args.length; i++) {
			MethodParameter methodParam = new SynthesizingMethodParameter(handlerMethod, i);
			methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);
			GenericTypeResolver.resolveParameterType(methodParam, handler.getClass());
			String paramName = null;
			String headerName = null;
			boolean requestBodyFound = false;
			String cookieName = null;
			String pathVarName = null;
			String attrName = null;
			boolean required = false;
			String defaultValue = null;
			boolean validate = false;
			Object[] validationHints = null;
			int annotationsFound = 0;
			Annotation[] paramAnns = methodParam.getParameterAnnotations();

			for (Annotation paramAnn : paramAnns) {
				if (RequestParam.class.isInstance(paramAnn)) {
					RequestParam requestParam = (RequestParam) paramAnn;
					paramName = requestParam.name();
					required = requestParam.required();
					defaultValue = parseDefaultValueAttribute(requestParam.defaultValue());
					annotationsFound++;
				}
				else if (RequestHeader.class.isInstance(paramAnn)) {
					RequestHeader requestHeader = (RequestHeader) paramAnn;
					headerName = requestHeader.name();
					required = requestHeader.required();
					defaultValue = parseDefaultValueAttribute(requestHeader.defaultValue());
					annotationsFound++;
				}
				else if (RequestBody.class.isInstance(paramAnn)) {
					requestBodyFound = true;
					annotationsFound++;
				}
				else if (CookieValue.class.isInstance(paramAnn)) {
					CookieValue cookieValue = (CookieValue) paramAnn;
					cookieName = cookieValue.name();
					required = cookieValue.required();
					defaultValue = parseDefaultValueAttribute(cookieValue.defaultValue());
					annotationsFound++;
				}
				else if (PathVariable.class.isInstance(paramAnn)) {
					PathVariable pathVar = (PathVariable) paramAnn;
					pathVarName = pathVar.value();
					annotationsFound++;
				}
				else if (ModelAttribute.class.isInstance(paramAnn)) {
					ModelAttribute attr = (ModelAttribute) paramAnn;
					attrName = attr.value();
					annotationsFound++;
				}
				else if (Value.class.isInstance(paramAnn)) {
					defaultValue = ((Value) paramAnn).value();
				}
				else {
					Validated validatedAnn = AnnotationUtils.getAnnotation(paramAnn, Validated.class);
					if (validatedAnn != null || paramAnn.annotationType().getSimpleName().startsWith("Valid")) {
						validate = true;
						Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(paramAnn));
						validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[]{hints});
					}
				}
			}

			if (annotationsFound > 1) {
				throw new IllegalStateException("Handler parameter annotations are exclusive choices - " +
						"do not specify more than one such annotation on the same parameter: " + handlerMethod);
			}

			if (annotationsFound == 0) {
				Object argValue = resolveCommonArgument(methodParam, webRequest);
				if (argValue != WebArgumentResolver.UNRESOLVED) {
					args[i] = argValue;
				}
				else if (defaultValue != null) {
					args[i] = resolveDefaultValue(defaultValue);
				}
				else {
					Class<?> paramType = methodParam.getParameterType();
					if (Model.class.isAssignableFrom(paramType) || Map.class.isAssignableFrom(paramType)) {
						if (!paramType.isAssignableFrom(implicitModel.getClass())) {
							throw new IllegalStateException("Argument [" + paramType.getSimpleName() + "] is of type " +
									"Model or Map but is not assignable from the actual model. You may need to switch " +
									"newer MVC infrastructure classes to use this argument.");
						}
						args[i] = implicitModel;
					}
					else if (SessionStatus.class.isAssignableFrom(paramType)) {
						args[i] = this.sessionStatus;
					}
					else if (HttpEntity.class.isAssignableFrom(paramType)) {
						args[i] = resolveHttpEntityRequest(methodParam, webRequest);
					}
					else if (Errors.class.isAssignableFrom(paramType)) {
						throw new IllegalStateException("Errors/BindingResult argument declared " +
								"without preceding model attribute. Check your handler method signature!");
					}
					else if (BeanUtils.isSimpleProperty(paramType)) {
						paramName = "";
					}
					else {
						attrName = "";
					}
				}
			}

			if (paramName != null) {
				args[i] = resolveRequestParam(paramName, required, defaultValue, methodParam, webRequest, handler);
			}
			else if (headerName != null) {
				args[i] = resolveRequestHeader(headerName, required, defaultValue, methodParam, webRequest, handler);
			}
			else if (requestBodyFound) {
				args[i] = resolveRequestBody(methodParam, webRequest, handler);
			}
			else if (cookieName != null) {
				args[i] = resolveCookieValue(cookieName, required, defaultValue, methodParam, webRequest, handler);
			}
			else if (pathVarName != null) {
				args[i] = resolvePathVariable(pathVarName, methodParam, webRequest, handler);
			}
			else if (attrName != null) {
				WebDataBinder binder =
						resolveModelAttribute(attrName, methodParam, implicitModel, webRequest, handler);
				boolean assignBindingResult = (args.length > i + 1 && Errors.class.isAssignableFrom(paramTypes[i + 1]));
				if (binder.getTarget() != null) {
					doBind(binder, webRequest, validate, validationHints, !assignBindingResult);
				}
				args[i] = binder.getTarget();
				if (assignBindingResult) {
					args[i + 1] = binder.getBindingResult();
					i++;
				}
				implicitModel.putAll(binder.getBindingResult().getModel());
			}
		}

		return args;
	}

	protected void initBinder(Object handler, String attrName, WebDataBinder binder, NativeWebRequest webRequest)
			throws Exception {

		if (this.bindingInitializer != null) {
			this.bindingInitializer.initBinder(binder, webRequest);
		}
		if (handler != null) {
			Set<Method> initBinderMethods = this.methodResolver.getInitBinderMethods();
			if (!initBinderMethods.isEmpty()) {
				boolean debug = logger.isDebugEnabled();
				for (Method initBinderMethod : initBinderMethods) {
					Method methodToInvoke = BridgeMethodResolver.findBridgedMethod(initBinderMethod);
					String[] targetNames = AnnotationUtils.findAnnotation(initBinderMethod, InitBinder.class).value();
					if (targetNames.length == 0 || Arrays.asList(targetNames).contains(attrName)) {
						Object[] initBinderArgs =
								resolveInitBinderArguments(handler, methodToInvoke, binder, webRequest);
						if (debug) {
							logger.debug("Invoking init-binder method: " + methodToInvoke);
						}
						ReflectionUtils.makeAccessible(methodToInvoke);
						Object returnValue = methodToInvoke.invoke(handler, initBinderArgs);
						if (returnValue != null) {
							throw new IllegalStateException(
									"InitBinder methods must not have a return value: " + methodToInvoke);
						}
					}
				}
			}
		}
	}

	private Object[] resolveInitBinderArguments(Object handler, Method initBinderMethod,
			WebDataBinder binder, NativeWebRequest webRequest) throws Exception {

		Class<?>[] initBinderParams = initBinderMethod.getParameterTypes();
		Object[] initBinderArgs = new Object[initBinderParams.length];

		for (int i = 0; i < initBinderArgs.length; i++) {
			MethodParameter methodParam = new SynthesizingMethodParameter(initBinderMethod, i);
			methodParam.initParameterNameDiscovery(this.parameterNameDiscoverer);
			GenericTypeResolver.resolveParameterType(methodParam, handler.getClass());
			String paramName = null;
			boolean paramRequired = false;
			String paramDefaultValue = null;
			String pathVarName = null;
			Annotation[] paramAnns = methodParam.getParameterAnnotations();

			for (Annotation paramAnn : paramAnns) {
				if (RequestParam.class.isInstance(paramAnn)) {
					RequestParam requestParam = (RequestParam) paramAnn;
					paramName = requestParam.name();
					paramRequired = requestParam.required();
					paramDefaultValue = parseDefaultValueAttribute(requestParam.defaultValue());
					break;
				}
				else if (ModelAttribute.class.isInstance(paramAnn)) {
					throw new IllegalStateException(
							"@ModelAttribute is not supported on @InitBinder methods: " + initBinderMethod);
				}
				else if (PathVariable.class.isInstance(paramAnn)) {
					PathVariable pathVar = (PathVariable) paramAnn;
					pathVarName = pathVar.value();
				}
			}

			if (paramName == null && pathVarName == null) {
				Object argValue = resolveCommonArgument(methodParam, webRequest);
				if (argValue != WebArgumentResolver.UNRESOLVED) {
					initBinderArgs[i] = argValue;
				}
				else {
					Class<?> paramType = initBinderParams[i];
					if (paramType.isInstance(binder)) {
						initBinderArgs[i] = binder;
					}
					else if (BeanUtils.isSimpleProperty(paramType)) {
						paramName = "";
					}
					else {
						throw new IllegalStateException("Unsupported argument [" + paramType.getName() +
								"] for @InitBinder method: " + initBinderMethod);
					}
				}
			}

			if (paramName != null) {
				initBinderArgs[i] =
						resolveRequestParam(paramName, paramRequired, paramDefaultValue, methodParam, webRequest, null);
			}
			else if (pathVarName != null) {
				initBinderArgs[i] = resolvePathVariable(pathVarName, methodParam, webRequest, null);
			}
		}

		return initBinderArgs;
	}

	@SuppressWarnings("unchecked")
	private Object resolveRequestParam(String paramName, boolean required, String defaultValue,
			MethodParameter methodParam, NativeWebRequest webRequest, Object handlerForInitBinderCall)
			throws Exception {

		Class<?> paramType = methodParam.getParameterType();
		if (Map.class.isAssignableFrom(paramType) && paramName.length() == 0) {
			return resolveRequestParamMap((Class<? extends Map<?, ?>>) paramType, webRequest);
		}
		if (paramName.length() == 0) {
			paramName = getRequiredParameterName(methodParam);
		}
		Object paramValue = null;
		MultipartRequest multipartRequest = webRequest.getNativeRequest(MultipartRequest.class);
		if (multipartRequest != null) {
			List<MultipartFile> files = multipartRequest.getFiles(paramName);
			if (!files.isEmpty()) {
				paramValue = (files.size() == 1 ? files.get(0) : files);
			}
		}
		if (paramValue == null) {
			String[] paramValues = webRequest.getParameterValues(paramName);
			if (paramValues != null) {
				paramValue = (paramValues.length == 1 ? paramValues[0] : paramValues);
			}
		}
		if (paramValue == null) {
			if (defaultValue != null) {
				paramValue = resolveDefaultValue(defaultValue);
			}
			else if (required) {
				raiseMissingParameterException(paramName, paramType);
			}
			paramValue = checkValue(paramName, paramValue, paramType);
		}
		WebDataBinder binder = createBinder(webRequest, null, paramName);
		initBinder(handlerForInitBinderCall, paramName, binder, webRequest);
		return binder.convertIfNecessary(paramValue, paramType, methodParam);
	}

	private Map<String, ?> resolveRequestParamMap(Class<? extends Map<?, ?>> mapType, NativeWebRequest webRequest) {
		Map<String, String[]> parameterMap = webRequest.getParameterMap();
		if (MultiValueMap.class.isAssignableFrom(mapType)) {
			MultiValueMap<String, String> result = new LinkedMultiValueMap<String, String>(parameterMap.size());
			for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
				for (String value : entry.getValue()) {
					result.add(entry.getKey(), value);
				}
			}
			return result;
		}
		else {
			Map<String, String> result = new LinkedHashMap<String, String>(parameterMap.size());
			for (Map.Entry<String, String[]> entry : parameterMap.entrySet()) {
				if (entry.getValue().length > 0) {
					result.put(entry.getKey(), entry.getValue()[0]);
				}
			}
			return result;
		}
	}

	@SuppressWarnings("unchecked")
	private Object resolveRequestHeader(String headerName, boolean required, String defaultValue,
			MethodParameter methodParam, NativeWebRequest webRequest, Object handlerForInitBinderCall)
			throws Exception {

		Class<?> paramType = methodParam.getParameterType();
		if (Map.class.isAssignableFrom(paramType)) {
			return resolveRequestHeaderMap((Class<? extends Map<?, ?>>) paramType, webRequest);
		}
		if (headerName.length() == 0) {
			headerName = getRequiredParameterName(methodParam);
		}
		Object headerValue = null;
		String[] headerValues = webRequest.getHeaderValues(headerName);
		if (headerValues != null) {
			headerValue = (headerValues.length == 1 ? headerValues[0] : headerValues);
		}
		if (headerValue == null) {
			if (defaultValue != null) {
				headerValue = resolveDefaultValue(defaultValue);
			}
			else if (required) {
				raiseMissingHeaderException(headerName, paramType);
			}
			headerValue = checkValue(headerName, headerValue, paramType);
		}
		WebDataBinder binder = createBinder(webRequest, null, headerName);
		initBinder(handlerForInitBinderCall, headerName, binder, webRequest);
		return binder.convertIfNecessary(headerValue, paramType, methodParam);
	}

	private Map<String, ?> resolveRequestHeaderMap(Class<? extends Map<?, ?>> mapType, NativeWebRequest webRequest) {
		if (MultiValueMap.class.isAssignableFrom(mapType)) {
			MultiValueMap<String, String> result;
			if (HttpHeaders.class.isAssignableFrom(mapType)) {
				result = new HttpHeaders();
			}
			else {
				result = new LinkedMultiValueMap<String, String>();
			}
			for (Iterator<String> iterator = webRequest.getHeaderNames(); iterator.hasNext();) {
				String headerName = iterator.next();
				for (String headerValue : webRequest.getHeaderValues(headerName)) {
					result.add(headerName, headerValue);
				}
			}
			return result;
		}
		else {
			Map<String, String> result = new LinkedHashMap<String, String>();
			for (Iterator<String> iterator = webRequest.getHeaderNames(); iterator.hasNext();) {
				String headerName = iterator.next();
				String headerValue = webRequest.getHeader(headerName);
				result.put(headerName, headerValue);
			}
			return result;
		}
	}

	/**
	 * Resolves the given {@link RequestBody @RequestBody} annotation.
	 */
	protected Object resolveRequestBody(MethodParameter methodParam, NativeWebRequest webRequest, Object handler)
			throws Exception {

		return readWithMessageConverters(methodParam, createHttpInputMessage(webRequest), methodParam.getParameterType());
	}

	private HttpEntity<?> resolveHttpEntityRequest(MethodParameter methodParam, NativeWebRequest webRequest)
			throws Exception {

		HttpInputMessage inputMessage = createHttpInputMessage(webRequest);
		Class<?> paramType = getHttpEntityType(methodParam);
		Object body = readWithMessageConverters(methodParam, inputMessage, paramType);
		return new HttpEntity<Object>(body, inputMessage.getHeaders());
	}

	@SuppressWarnings({ "unchecked", "rawtypes" })
	private Object readWithMessageConverters(MethodParameter methodParam, HttpInputMessage inputMessage, Class<?> paramType)
			throws Exception {

		MediaType contentType = inputMessage.getHeaders().getContentType();
		if (contentType == null) {
			StringBuilder builder = new StringBuilder(ClassUtils.getShortName(methodParam.getParameterType()));
			String paramName = methodParam.getParameterName();
			if (paramName != null) {
				builder.append(' ');
				builder.append(paramName);
			}
			throw new HttpMediaTypeNotSupportedException(
					"Cannot extract parameter (" + builder.toString() + "): no Content-Type found");
		}

		List<MediaType> allSupportedMediaTypes = new ArrayList<MediaType>();
		if (this.messageConverters != null) {
			for (HttpMessageConverter<?> messageConverter : this.messageConverters) {
				allSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());
				if (messageConverter.canRead(paramType, contentType)) {
					if (logger.isDebugEnabled()) {
						logger.debug("Reading [" + paramType.getName() + "] as \"" + contentType
								+"\" using [" + messageConverter + "]");
					}
					return messageConverter.read((Class) paramType, inputMessage);
				}
			}
		}
		throw new HttpMediaTypeNotSupportedException(contentType, allSupportedMediaTypes);
	}

	private Class<?> getHttpEntityType(MethodParameter methodParam) {
		Assert.isAssignable(HttpEntity.class, methodParam.getParameterType());
		ParameterizedType type = (ParameterizedType) methodParam.getGenericParameterType();
		if (type.getActualTypeArguments().length == 1) {
			Type typeArgument = type.getActualTypeArguments()[0];
			if (typeArgument instanceof Class) {
				return (Class<?>) typeArgument;
			}
			else if (typeArgument instanceof GenericArrayType) {
				Type componentType = ((GenericArrayType) typeArgument).getGenericComponentType();
				if (componentType instanceof Class) {
					// Surely, there should be a nicer way to do this
					Object array = Array.newInstance((Class<?>) componentType, 0);
					return array.getClass();
				}
			}
		}
		throw new IllegalArgumentException(
				"HttpEntity parameter (" + methodParam.getParameterName() + ") is not parameterized");

	}

	private Object resolveCookieValue(String cookieName, boolean required, String defaultValue,
			MethodParameter methodParam, NativeWebRequest webRequest, Object handlerForInitBinderCall)
			throws Exception {

		Class<?> paramType = methodParam.getParameterType();
		if (cookieName.length() == 0) {
			cookieName = getRequiredParameterName(methodParam);
		}
		Object cookieValue = resolveCookieValue(cookieName, paramType, webRequest);
		if (cookieValue == null) {
			if (defaultValue != null) {
				cookieValue = resolveDefaultValue(defaultValue);
			}
			else if (required) {
				raiseMissingCookieException(cookieName, paramType);
			}
			cookieValue = checkValue(cookieName, cookieValue, paramType);
		}
		WebDataBinder binder = createBinder(webRequest, null, cookieName);
		initBinder(handlerForInitBinderCall, cookieName, binder, webRequest);
		return binder.convertIfNecessary(cookieValue, paramType, methodParam);
	}

	/**
	 * Resolves the given {@link CookieValue @CookieValue} annotation.
	 * <p>Throws an UnsupportedOperationException by default.
	 */
	protected Object resolveCookieValue(String cookieName, Class<?> paramType, NativeWebRequest webRequest)
			throws Exception {

		throw new UnsupportedOperationException("@CookieValue not supported");
	}

	private Object resolvePathVariable(String pathVarName, MethodParameter methodParam,
			NativeWebRequest webRequest, Object handlerForInitBinderCall) throws Exception {

		Class<?> paramType = methodParam.getParameterType();
		if (pathVarName.length() == 0) {
			pathVarName = getRequiredParameterName(methodParam);
		}
		String pathVarValue = resolvePathVariable(pathVarName, paramType, webRequest);
		WebDataBinder binder = createBinder(webRequest, null, pathVarName);
		initBinder(handlerForInitBinderCall, pathVarName, binder, webRequest);
		return binder.convertIfNecessary(pathVarValue, paramType, methodParam);
	}

	/**
	 * Resolves the given {@link PathVariable @PathVariable} annotation.
	 * <p>Throws an UnsupportedOperationException by default.
	 */
	protected String resolvePathVariable(String pathVarName, Class<?> paramType, NativeWebRequest webRequest)
			throws Exception {

		throw new UnsupportedOperationException("@PathVariable not supported");
	}

	private String getRequiredParameterName(MethodParameter methodParam) {
		String name = methodParam.getParameterName();
		if (name == null) {
			throw new IllegalStateException(
					"No parameter name specified for argument of type [" + methodParam.getParameterType().getName() +
							"], and no parameter name information found in class file either.");
		}
		return name;
	}

	private Object checkValue(String name, Object value, Class<?> paramType) {
		if (value == null) {
			if (boolean.class == paramType) {
				return Boolean.FALSE;
			}
			else if (paramType.isPrimitive()) {
				throw new IllegalStateException("Optional " + paramType + " parameter '" + name +
						"' is not present but cannot be translated into a null value due to being declared as a " +
						"primitive type. Consider declaring it as object wrapper for the corresponding primitive type.");
			}
		}
		return value;
	}

	private WebDataBinder resolveModelAttribute(String attrName, MethodParameter methodParam,
			ExtendedModelMap implicitModel, NativeWebRequest webRequest, Object handler) throws Exception {

		// Bind request parameter onto object...
		String name = attrName;
		if ("".equals(name)) {
			name = Conventions.getVariableNameForParameter(methodParam);
		}
		Class<?> paramType = methodParam.getParameterType();
		Object bindObject;
		if (implicitModel.containsKey(name)) {
			bindObject = implicitModel.get(name);
		}
		else if (this.methodResolver.isSessionAttribute(name, paramType)) {
			bindObject = this.sessionAttributeStore.retrieveAttribute(webRequest, name);
			if (bindObject == null) {
				raiseSessionRequiredException("Session attribute '" + name + "' required - not found in session");
			}
		}
		else {
			bindObject = BeanUtils.instantiateClass(paramType);
		}
		WebDataBinder binder = createBinder(webRequest, bindObject, name);
		initBinder(handler, name, binder, webRequest);
		return binder;
	}


	/**
	 * Determine whether the given value qualifies as a "binding candidate", i.e. might potentially be subject to
	 * bean-style data binding later on.
	 */
	protected boolean isBindingCandidate(Object value) {
		return (value != null && !value.getClass().isArray() && !(value instanceof Collection) &&
				!(value instanceof Map) && !BeanUtils.isSimpleValueType(value.getClass()));
	}

	protected void raiseMissingParameterException(String paramName, Class<?> paramType) throws Exception {
		throw new IllegalStateException("Missing parameter '" + paramName + "' of type [" + paramType.getName() + "]");
	}

	protected void raiseMissingHeaderException(String headerName, Class<?> paramType) throws Exception {
		throw new IllegalStateException("Missing header '" + headerName + "' of type [" + paramType.getName() + "]");
	}

	protected void raiseMissingCookieException(String cookieName, Class<?> paramType) throws Exception {
		throw new IllegalStateException(
				"Missing cookie value '" + cookieName + "' of type [" + paramType.getName() + "]");
	}

	protected void raiseSessionRequiredException(String message) throws Exception {
		throw new IllegalStateException(message);
	}

	protected WebDataBinder createBinder(NativeWebRequest webRequest, Object target, String objectName)
			throws Exception {

		return new WebRequestDataBinder(target, objectName);
	}

	private void doBind(WebDataBinder binder, NativeWebRequest webRequest, boolean validate,
			Object[] validationHints, boolean failOnErrors) throws Exception {

		doBind(binder, webRequest);
		if (validate) {
			binder.validate(validationHints);
		}
		if (failOnErrors && binder.getBindingResult().hasErrors()) {
			throw new BindException(binder.getBindingResult());
		}
	}

	protected void doBind(WebDataBinder binder, NativeWebRequest webRequest) throws Exception {
		((WebRequestDataBinder) binder).bind(webRequest);
	}

	/**
	 * Return a {@link HttpInputMessage} for the given {@link NativeWebRequest}.
	 * <p>Throws an UnsupportedOperation1Exception by default.
	 */
	protected HttpInputMessage createHttpInputMessage(NativeWebRequest webRequest) throws Exception {
		throw new UnsupportedOperationException("@RequestBody not supported");
	}

	/**
	 * Return a {@link HttpOutputMessage} for the given {@link NativeWebRequest}.
	 * <p>Throws an UnsupportedOperationException by default.
	 */
	protected HttpOutputMessage createHttpOutputMessage(NativeWebRequest webRequest) throws Exception {
		throw new UnsupportedOperationException("@Body not supported");
	}

	protected String parseDefaultValueAttribute(String value) {
		return (ValueConstants.DEFAULT_NONE.equals(value) ? null : value);
	}

	protected Object resolveDefaultValue(String value) {
		return value;
	}

	protected Object resolveCommonArgument(MethodParameter methodParameter, NativeWebRequest webRequest)
			throws Exception {

		// Invoke custom argument resolvers if present...
		if (this.customArgumentResolvers != null) {
			for (WebArgumentResolver argumentResolver : this.customArgumentResolvers) {
				Object value = argumentResolver.resolveArgument(methodParameter, webRequest);
				if (value != WebArgumentResolver.UNRESOLVED) {
					return value;
				}
			}
		}

		// Resolution of standard parameter types...
		Class<?> paramType = methodParameter.getParameterType();
		Object value = resolveStandardArgument(paramType, webRequest);
		if (value != WebArgumentResolver.UNRESOLVED && !ClassUtils.isAssignableValue(paramType, value)) {
			throw new IllegalStateException("Standard argument type [" + paramType.getName() +
					"] resolved to incompatible value of type [" + (value != null ? value.getClass() : null) +
					"]. Consider declaring the argument type in a less specific fashion.");
		}
		return value;
	}

	protected Object resolveStandardArgument(Class<?> parameterType, NativeWebRequest webRequest) throws Exception {
		if (WebRequest.class.isAssignableFrom(parameterType)) {
			return webRequest;
		}
		return WebArgumentResolver.UNRESOLVED;
	}

	protected final void addReturnValueAsModelAttribute(Method handlerMethod, Class<?> handlerType,
			Object returnValue, ExtendedModelMap implicitModel) {

		ModelAttribute attr = AnnotationUtils.findAnnotation(handlerMethod, ModelAttribute.class);
		String attrName = (attr != null ? attr.value() : "");
		if ("".equals(attrName)) {
			Class<?> resolvedType = GenericTypeResolver.resolveReturnType(handlerMethod, handlerType);
			attrName = Conventions.getVariableNameForReturnType(handlerMethod, resolvedType, returnValue);
		}
		implicitModel.addAttribute(attrName, returnValue);
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/HandlerMethodResolver.java
================================================
/*
 * Copyright 2002-2015 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.core.BridgeMethodResolver;
import org.springframework.core.annotation.AnnotationUtils;
import org.springframework.util.ClassUtils;
import org.springframework.util.ReflectionUtils;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.SessionAttributes;

/**
 * Support class for resolving web method annotations in a handler type.
 * Processes {@code @RequestMapping}, {@code @InitBinder},
 * {@code @ModelAttribute} and {@code @SessionAttributes}.
 *
 * <p>Used by {@link org.springframework.com.ejie.x38.spring.context.AnnotationMethodHandlerAdapter}
 * and {@link com.ejie.x38.spring.context.portlet.mvc.annotation.AnnotationMethodHandlerAdapter}.
 *
 * @author Juergen Hoeller
 * @since 2.5.2
 * @see org.springframework.web.bind.annotation.RequestMapping
 * @see org.springframework.web.bind.annotation.InitBinder
 * @see org.springframework.web.bind.annotation.ModelAttribute
 * @see org.springframework.web.bind.annotation.SessionAttributes
 * @deprecated as of 4.3, in favor of the {@code HandlerMethod}-based MVC infrastructure
 */
@Deprecated
public class HandlerMethodResolver {

	private final Set<Method> handlerMethods = new LinkedHashSet<Method>();

	private final Set<Method> initBinderMethods = new LinkedHashSet<Method>();

	private final Set<Method> modelAttributeMethods = new LinkedHashSet<Method>();

	private RequestMapping typeLevelMapping;

	private boolean sessionAttributesFound;

	private final Set<String> sessionAttributeNames = new HashSet<String>();

	private final Set<Class<?>> sessionAttributeTypes = new HashSet<Class<?>>();

	private final Set<String> actualSessionAttributeNames =
			Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>(4));


	/**
	 * Initialize a new HandlerMethodResolver for the specified handler type.
	 * @param handlerType the handler class to introspect
	 */
	public void init(final Class<?> handlerType) {
		Set<Class<?>> handlerTypes = new LinkedHashSet<Class<?>>();
		Class<?> specificHandlerType = null;
		if (!Proxy.isProxyClass(handlerType)) {
			handlerTypes.add(handlerType);
			specificHandlerType = handlerType;
		}
		handlerTypes.addAll(Arrays.asList(handlerType.getInterfaces()));
		for (Class<?> currentHandlerType : handlerTypes) {
			final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);
			ReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {
				@Override
				public void doWith(Method method) {
					Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);
					Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);
					if (isHandlerMethod(specificMethod) &&
							(bridgedMethod == specificMethod || !isHandlerMethod(bridgedMethod))) {
						handlerMethods.add(specificMethod);
					}
					else if (isInitBinderMethod(specificMethod) &&
							(bridgedMethod == specificMethod || !isInitBinderMethod(bridgedMethod))) {
						initBinderMethods.add(specificMethod);
					}
					else if (isModelAttributeMethod(specificMethod) &&
							(bridgedMethod == specificMethod || !isModelAttributeMethod(bridgedMethod))) {
						modelAttributeMethods.add(specificMethod);
					}
				}
			}, ReflectionUtils.USER_DECLARED_METHODS);
		}
		this.typeLevelMapping = AnnotationUtils.findAnnotation(handlerType, RequestMapping.class);
		SessionAttributes sessionAttributes = AnnotationUtils.findAnnotation(handlerType, SessionAttributes.class);
		this.sessionAttributesFound = (sessionAttributes != null);
		if (this.sessionAttributesFound) {
			this.sessionAttributeNames.addAll(Arrays.asList(sessionAttributes.names()));
			this.sessionAttributeTypes.addAll(Arrays.asList(sessionAttributes.types()));
		}
	}

	protected boolean isHandlerMethod(Method method) {
		return AnnotationUtils.findAnnotation(method, RequestMapping.class) != null;
	}

	protected boolean isInitBinderMethod(Method method) {
		return AnnotationUtils.findAnnotation(method, InitBinder.class) != null;
	}

	protected boolean isModelAttributeMethod(Method method) {
		return AnnotationUtils.findAnnotation(method, ModelAttribute.class) != null;
	}


	public final boolean hasHandlerMethods() {
		return !this.handlerMethods.isEmpty();
	}

	public final Set<Method> getHandlerMethods() {
		return this.handlerMethods;
	}

	public final Set<Method> getInitBinderMethods() {
		return this.initBinderMethods;
	}

	public final Set<Method> getModelAttributeMethods() {
		return this.modelAttributeMethods;
	}

	public boolean hasTypeLevelMapping() {
		return (this.typeLevelMapping != null);
	}

	public RequestMapping getTypeLevelMapping() {
		return this.typeLevelMapping;
	}

	public boolean hasSessionAttributes() {
		return this.sessionAttributesFound;
	}

	public boolean isSessionAttribute(String attrName, Class<?> attrType) {
		if (this.sessionAttributeNames.contains(attrName) || this.sessionAttributeTypes.contains(attrType)) {
			this.actualSessionAttributeNames.add(attrName);
			return true;
		}
		else {
			return false;
		}
	}

	public Set<String> getActualSessionAttributeNames() {
		return this.actualSessionAttributeNames;
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/InternalPathMethodNameResolver.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Simple implementation of {@link MethodNameResolver} that maps URL to
 * method name. Although this is the default implementation used by the
 * {@link MultiActionController} class (because it requires no configuration),
 * it's bit naive for most applications. In particular, we don't usually
 * want to tie URL to implementation methods.
 *
 * <p>
 * Maps the resource name after the last slash, ignoring an extension.
 * E.g. "/foo/bar/baz.html" to "baz", assuming a "/foo/bar/baz.html"
 * controller mapping to the corresponding MultiActionController handler.
 * method. Doesn't support wildcards.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @deprecated as of 4.3, in favor of annotation-driven handler methods
 */
@Deprecated
public class InternalPathMethodNameResolver extends AbstractUrlMethodNameResolver {

    private String prefix = "";

    private String suffix = "";

    /** Request URL path String --> method name String */
    private final Map<String, String> methodNameCache = new ConcurrentHashMap<>(16);

    /**
     * Specify a common prefix for handler method names.
     * Will be prepended to the internal path found in the URL:
     * e.g. internal path "baz", prefix "my" -> method name "mybaz".
     */
    public void setPrefix(String prefix) {
	this.prefix = (prefix != null ? prefix : "");
    }

    /**
     * Return the common prefix for handler method names.
     */
    protected String getPrefix() {
	return this.prefix;
    }

    /**
     * Specify a common suffix for handler method names.
     * Will be appended to the internal path found in the URL:
     * e.g. internal path "baz", suffix "Handler" -> method name "bazHandler".
     */
    public void setSuffix(String suffix) {
	this.suffix = (suffix != null ? suffix : "");
    }

    /**
     * Return the common suffix for handler method names.
     */
    protected String getSuffix() {
	return this.suffix;
    }

    /**
     * Extracts the method name indicated by the URL path.
     *
     * @see #extractHandlerMethodNameFromUrlPath
     * @see #postProcessHandlerMethodName
     */
    @Override
    protected String getHandlerMethodNameForUrlPath(String urlPath) {
	String methodName = this.methodNameCache.get(urlPath);
	if (methodName == null) {
	    methodName = extractHandlerMethodNameFromUrlPath(urlPath);
	    methodName = postProcessHandlerMethodName(methodName);
	    this.methodNameCache.put(urlPath, methodName);
	}
	return methodName;
    }

    /**
     * Extract the handler method name from the given request URI.
     * Delegates to {@code WebUtils.extractFilenameFromUrlPath(String)}.
     *
     * @param uri
     *            the request URI (e.g. "/index.html")
     * @return the extracted URI filename (e.g. "index")
     * @see org.springframework.web.util.WebUtils#extractFilenameFromUrlPath
     */
    protected String extractHandlerMethodNameFromUrlPath(String uri) {
	return WebUtils.extractFilenameFromUrlPath(uri);
    }

    /**
     * Build the full handler method name based on the given method name
     * as indicated by the URL path.
     * <p>
     * The default implementation simply applies prefix and suffix.
     * This can be overridden, for example, to manipulate upper case
     * / lower case, etc.
     *
     * @param methodName
     *            the original method name, as indicated by the URL path
     * @return the full method name to use
     * @see #getPrefix()
     * @see #getSuffix()
     */
    protected String postProcessHandlerMethodName(String methodName) {
	return getPrefix() + methodName + getSuffix();
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/MethodNameResolver.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import javax.servlet.http.HttpServletRequest;

/**
 * Interface that parameterizes the MultiActionController class
 * using the <b>Strategy</b> GoF Design pattern, allowing
 * the mapping from incoming request to handler method name
 * to be varied without affecting other application code.
 *
 * <p>Illustrates how delegation can be more flexible than subclassing.
 *
 * @author Rod Johnson
 * @see MultiActionController#setMethodNameResolver
 * @deprecated as of 4.3, in favor of annotation-driven handler methods
 */
@Deprecated
public interface MethodNameResolver {

	/**
	 * Return a method name that can handle this request. Such
	 * mappings are typically, but not necessarily, based on URL.
	 * @param request current HTTP request
	 * @return a method name that can handle this request.
	 * Never returns {@code null}; throws exception if not resolvable.
	 * @throws NoSuchRequestHandlingMethodException if no handler method
	 * can be found for the given request
	 */
	String getHandlerMethodName(HttpServletRequest request) throws NoSuchRequestHandlingMethodException;

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/NoSuchRequestHandlingMethodException.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.util.Map;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;

import org.springframework.core.style.StylerUtils;
import org.springframework.web.util.UrlPathHelper;

/**
 * Exception thrown when there is no handler method ("action" method)
 * for a specific HTTP request.
 *
 * @author Rod Johnson
 * @author Juergen Hoeller
 * @see MethodNameResolver#getHandlerMethodName(javax.servlet.http.HttpServletRequest)
 * @deprecated as of 4.3, in favor of annotation-driven handler methods
 */
@Deprecated
@SuppressWarnings("serial")
public class NoSuchRequestHandlingMethodException extends ServletException {

    private String methodName;

    /**
     * Create a new NoSuchRequestHandlingMethodException for the given request.
     *
     * @param request
     *            the offending HTTP request
     */
    public NoSuchRequestHandlingMethodException(HttpServletRequest request) {
	this(new UrlPathHelper().getRequestUri(request), request.getMethod(), request.getParameterMap());
    }

    /**
     * Create a new NoSuchRequestHandlingMethodException.
     *
     * @param urlPath
     *            the request URI that has been used for handler lookup
     * @param method
     *            the HTTP request method of the request
     * @param parameterMap
     *            the request's parameters as map
     */
    public NoSuchRequestHandlingMethodException(String urlPath, String method, Map<String, String[]> parameterMap) {
	super("No matching handler method found for servlet request: path '" + urlPath + "', method '" + method
		+ "', parameters " + StylerUtils.style(parameterMap));
    }

    /**
     * Create a new NoSuchRequestHandlingMethodException for the given request.
     *
     * @param methodName
     *            the name of the handler method that wasn't found
     * @param controllerClass
     *            the class the handler method was expected to be in
     */
    public NoSuchRequestHandlingMethodException(String methodName, Class<?> controllerClass) {
	super("No request handling method with name '" + methodName + "' in class [" + controllerClass.getName() + "]");
	this.methodName = methodName;
    }

    /**
     * Return the name of the offending method, if known.
     */
    public String getMethodName() {
	return this.methodName;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/ServletAnnotationMappingUtils.java
================================================
/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.util.Iterator;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.springframework.http.MediaType;
import org.springframework.util.ObjectUtils;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.util.WebUtils;

/**
 * Helper class for annotation-based request mapping.
 *
 * @author Juergen Hoeller
 * @author Arjen Poutsma
 * @author Rossen Stoyanchev
 * @since 2.5.2
 * @deprecated as of Spring 3.2, together with {@link DefaultAnnotationHandlerMapping},
 *             {@link AnnotationMethodHandlerAdapter}, and {@link AnnotationMethodHandlerExceptionResolver}.
 */
@Deprecated
abstract class ServletAnnotationMappingUtils {

    /**
     * Check whether the given request matches the specified request methods.
     *
     * @param methods
     *            the HTTP request methods to check against
     * @param request
     *            the current HTTP request to check
     */
    public static boolean checkRequestMethod(RequestMethod[] methods, HttpServletRequest request) {
	String inputMethod = request.getMethod();
	if (ObjectUtils.isEmpty(methods) && !RequestMethod.OPTIONS.name().equals(inputMethod)) {
	    return true;
	}
	for (RequestMethod method : methods) {
	    if (method.name().equals(inputMethod)) {
		return true;
	    }
	}
	return false;
    }

    /**
     * Check whether the given request matches the specified parameter conditions.
     *
     * @param params
     *            the parameter conditions, following
     *            {@link org.springframework.web.bind.annotation.RequestMapping#params() RequestMapping.#params()}
     * @param request
     *            the current HTTP request to check
     */
    public static boolean checkParameters(String[] params, HttpServletRequest request) {
	if (!ObjectUtils.isEmpty(params)) {
	    for (String param : params) {
		int separator = param.indexOf('=');
		if (separator == -1) {
		    if (param.startsWith("!")) {
			if (WebUtils.hasSubmitParameter(request, param.substring(1))) {
			    return false;
			}
		    } else if (!WebUtils.hasSubmitParameter(request, param)) {
			return false;
		    }
		} else {
		    boolean negated = separator > 0 && param.charAt(separator - 1) == '!';
		    String key = !negated ? param.substring(0, separator) : param.substring(0, separator - 1);
		    String value = param.substring(separator + 1);
		    boolean match = value.equals(request.getParameter(key));
		    if (negated) {
			match = !match;
		    }
		    if (!match) {
			return false;
		    }
		}
	    }
	}
	return true;
    }

    /**
     * Check whether the given request matches the specified header conditions.
     *
     * @param headers
     *            the header conditions, following
     *            {@link org.springframework.web.bind.annotation.RequestMapping#headers() RequestMapping.headers()}
     * @param request
     *            the current HTTP request to check
     */
    public static boolean checkHeaders(String[] headers, HttpServletRequest request) {
	if (!ObjectUtils.isEmpty(headers)) {
	    for (String header : headers) {
		int separator = header.indexOf('=');
		if (separator == -1) {
		    if (header.startsWith("!")) {
			if (request.getHeader(header.substring(1)) != null) {
			    return false;
			}
		    } else if (request.getHeader(header) == null) {
			return false;
		    }
		} else {
		    boolean negated = (separator > 0 && header.charAt(separator - 1) == '!');
		    String key = !negated ? header.substring(0, separator) : header.substring(0, separator - 1);
		    String value = header.substring(separator + 1);
		    if (ServletAnnotationMappingUtils.isMediaTypeHeader(key)) {
			List<MediaType> requestMediaTypes = MediaType.parseMediaTypes(request.getHeader(key));
			List<MediaType> valueMediaTypes = MediaType.parseMediaTypes(value);
			boolean found = false;
			for (Iterator<MediaType> valIter = valueMediaTypes.iterator(); valIter.hasNext() && !found;) {
			    MediaType valueMediaType = valIter.next();
			    for (Iterator<MediaType> reqIter = requestMediaTypes.iterator(); reqIter.hasNext()
				    && !found;) {
				MediaType requestMediaType = reqIter.next();
				if (valueMediaType.includes(requestMediaType)) {
				    found = true;
				}
			    }

			}
			if (negated) {
			    found = !found;
			}
			if (!found) {
			    return false;
			}
		    } else {
			boolean match = value.equals(request.getHeader(key));
			if (negated) {
			    match = !match;
			}
			if (!match) {
			    return false;
			}
		    }
		}
	    }
	}
	return true;
    }

    private static boolean isMediaTypeHeader(String headerName) {
	return ("Accept".equalsIgnoreCase(headerName) || "Content-Type".equalsIgnoreCase(headerName));
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/SingletonBeanFactoryLocator.java
================================================
/*
 * Copyright 2002-2012 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.FatalBeanException;
import org.springframework.beans.factory.BeanDefinitionStoreException;
import org.springframework.beans.factory.BeanFactory;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;
import org.springframework.beans.factory.support.DefaultListableBeanFactory;
import org.springframework.beans.factory.xml.XmlBeanDefinitionReader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternResolver;
import org.springframework.core.io.support.ResourcePatternUtils;

/**
 * <p>
 * Keyed-singleton implementation of {@link BeanFactoryLocator},
 * which accesses shared Spring {@link BeanFactory} instances.
 * </p>
 *
 * <p>
 * Please see the warning in BeanFactoryLocator's javadoc about appropriate usage
 * of singleton style BeanFactoryLocator implementations. It is the opinion of the
 * Spring team that the use of this class and similar classes is unnecessary except
 * (sometimes) for a small amount of glue code. Excessive usage will lead to code
 * that is more tightly coupled, and harder to modify or test.
 * </p>
 *
 * <p>
 * In this implementation, a BeanFactory is built up from one or more XML
 * definition file fragments, accessed as resources. The default resource name
 * searched for is 'classpath*:beanRefFactory.xml', with the Spring-standard
 * 'classpath*:' prefix ensuring that if the classpath contains multiple copies
 * of this file (perhaps one in each component jar) they will be combined. To
 * override the default resource name, instead of using the no-arg
 * {@link #getInstance()} method, use the {@link #getInstance(String selector)}
 * variant, which will treat the 'selector' argument as the resource name to
 * search for.
 * </p>
 *
 * <p>
 * The purpose of this 'outer' BeanFactory is to create and hold a copy of one
 * or more 'inner' BeanFactory or ApplicationContext instances, and allow those
 * to be obtained either directly or via an alias. As such, this class provides
 * both singleton style access to one or more BeanFactories/ApplicationContexts,
 * and also a level of indirection, allowing multiple pieces of code, which are
 * not able to work in a Dependency Injection fashion, to refer to and use the
 * same target BeanFactory/ApplicationContext instance(s), by different names.
 * <p>
 *
 * <p>
 * Consider an example application scenario:
 *
 * <ul>
 * <li>{@code com.mycompany.myapp.util.applicationContext.xml} -
 * ApplicationContext definition file which defines beans for 'util' layer.
 * <li>{@code com.mycompany.myapp.dataaccess-applicationContext.xml} -
 * ApplicationContext definition file which defines beans for 'data access' layer.
 * Depends on the above.
 * <li>{@code com.mycompany.myapp.services.applicationContext.xml} -
 * ApplicationContext definition file which defines beans for 'services' layer.
 * Depends on the above.
 * </ul>
 *
 * <p>
 * In an ideal scenario, these would be combined to create one ApplicationContext,
 * or created as three hierarchical ApplicationContexts, by one piece of code
 * somewhere at application startup (perhaps a Servlet filter), from which all other
 * code in the application would flow, obtained as beans from the context(s). However
 * when third party code enters into the picture, things can get problematic. If the
 * third party code needs to create user classes, which should normally be obtained
 * from a Spring BeanFactory/ApplicationContext, but can handle only newInstance()
 * style object creation, then some extra work is required to actually access and
 * use object from a BeanFactory/ApplicationContext. One solutions is to make the
 * class created by the third party code be just a stub or proxy, which gets the
 * real object from a BeanFactory/ApplicationContext, and delegates to it. However,
 * it is not normally workable for the stub to create the BeanFactory on each
 * use, as depending on what is inside it, that can be an expensive operation.
 * Additionally, there is a fairly tight coupling between the stub and the name of
 * the definition resource for the BeanFactory/ApplicationContext. This is where
 * SingletonBeanFactoryLocator comes in. The stub can obtain a
 * SingletonBeanFactoryLocator instance, which is effectively a singleton, and
 * ask it for an appropriate BeanFactory. A subsequent invocation (assuming the
 * same class loader is involved) by the stub or another piece of code, will obtain
 * the same instance. The simple aliasing mechanism allows the context to be asked
 * for by a name which is appropriate for (or describes) the user. The deployer can
 * match alias names to actual context names.
 *
 * <p>
 * Another use of SingletonBeanFactoryLocator, is to demand-load/use one or more
 * BeanFactories/ApplicationContexts. Because the definition can contain one of more
 * BeanFactories/ApplicationContexts, which can be independent or in a hierarchy, if
 * they are set to lazy-initialize, they will only be created when actually requested
 * for use.
 *
 * <p>
 * Given the above-mentioned three ApplicationContexts, consider the simplest
 * SingletonBeanFactoryLocator usage scenario, where there is only one single
 * {@code beanRefFactory.xml} definition file:
 *
 * <pre class="code">
 * &lt;?xml version="1.0" encoding="UTF-8"?>
 * &lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
 *
 * &lt;beans>
 *
 *   &lt;bean id="com.mycompany.myapp"
 *         class="org.springframework.context.support.ClassPathXmlApplicationContext">
 *     &lt;constructor-arg>
 *       &lt;list>
 *         &lt;value>com/mycompany/myapp/util/applicationContext.xml&lt;/value>
 *         &lt;value>com/mycompany/myapp/dataaccess/applicationContext.xml&lt;/value>
 *         &lt;value>com/mycompany/myapp/dataaccess/services.xml&lt;/value>
 *       &lt;/list>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 *
 * &lt;/beans>
 * </pre>
 *
 * The client code is as simple as:
 *
 * <pre class="code">
 * BeanFactoryLocator bfl = SingletonBeanFactoryLocator.getInstance();
 * BeanFactoryReference bf = bfl.useBeanFactory("com.mycompany.myapp");
 * // now use some bean from factory
 * MyClass zed = bf.getFactory().getBean("mybean");
 * </pre>
 *
 * Another relatively simple variation of the {@code beanRefFactory.xml} definition file could be:
 *
 * <pre class="code">
 * &lt;?xml version="1.0" encoding="UTF-8"?>
 * &lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
 *
 * &lt;beans>
 *
 *   &lt;bean id="com.mycompany.myapp.util" lazy-init="true"
 *         class="org.springframework.context.support.ClassPathXmlApplicationContext">
 *     &lt;constructor-arg>
 *       &lt;value>com/mycompany/myapp/util/applicationContext.xml&lt;/value>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 *
 *   &lt;!-- child of above -->
 *   &lt;bean id="com.mycompany.myapp.dataaccess" lazy-init="true"
 *         class="org.springframework.context.support.ClassPathXmlApplicationContext">
 *     &lt;constructor-arg>
 *       &lt;list>&lt;value>com/mycompany/myapp/dataaccess/applicationContext.xml&lt;/value>&lt;/list>
 *     &lt;/constructor-arg>
 *     &lt;constructor-arg>
 *       &lt;ref bean="com.mycompany.myapp.util"/>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 *
 *   &lt;!-- child of above -->
 *   &lt;bean id="com.mycompany.myapp.services" lazy-init="true"
 *         class="org.springframework.context.support.ClassPathXmlApplicationContext">
 *     &lt;constructor-arg>
 *       &lt;list>&lt;value>com/mycompany/myapp/dataaccess.services.xml&lt;/value>&lt;/value>
 *     &lt;/constructor-arg>
 *     &lt;constructor-arg>
 *       &lt;ref bean="com.mycompany.myapp.dataaccess"/>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 *
 *   &lt;!-- define an alias -->
 *   &lt;bean id="com.mycompany.myapp.mypackage"
 *         class="java.lang.String">
 *     &lt;constructor-arg>
 *       &lt;value>com.mycompany.myapp.services&lt;/value>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 *
 * &lt;/beans>
 * </pre>
 *
 * <p>
 * In this example, there is a hierarchy of three contexts created. The (potential)
 * advantage is that if the lazy flag is set to true, a context will only be created
 * if it's actually used. If there is some code that is only needed some of the time,
 * this mechanism can save some resources. Additionally, an alias to the last context
 * has been created. Aliases allow usage of the idiom where client code asks for a
 * context with an id which represents the package or module the code is in, and the
 * actual definition file(s) for the SingletonBeanFactoryLocator maps that id to
 * a real context id.
 *
 * <p>
 * A final example is more complex, with a {@code beanRefFactory.xml} for every module.
 * All the files are automatically combined to create the final definition.
 *
 * <p>
 * {@code beanRefFactory.xml} file inside jar for util module:
 *
 * <pre class="code">
 * &lt;?xml version="1.0" encoding="UTF-8"?>
 * &lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
 *
 * &lt;beans>
 *   &lt;bean id="com.mycompany.myapp.util" lazy-init="true"
 *        class="org.springframework.context.support.ClassPathXmlApplicationContext">
 *     &lt;constructor-arg>
 *       &lt;value>com/mycompany/myapp/util/applicationContext.xml&lt;/value>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 * &lt;/beans>
 * </pre>
 *
 * {@code beanRefFactory.xml} file inside jar for data-access module:<br>
 *
 * <pre class="code">
 * &lt;?xml version="1.0" encoding="UTF-8"?>
 * &lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
 *
 * &lt;beans>
 *   &lt;!-- child of util -->
 *   &lt;bean id="com.mycompany.myapp.dataaccess" lazy-init="true"
 *        class="org.springframework.context.support.ClassPathXmlApplicationContext">
 *     &lt;constructor-arg>
 *       &lt;list>&lt;value>com/mycompany/myapp/dataaccess/applicationContext.xml&lt;/value>&lt;/list>
 *     &lt;/constructor-arg>
 *     &lt;constructor-arg>
 *       &lt;ref bean="com.mycompany.myapp.util"/>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 * &lt;/beans>
 * </pre>
 *
 * {@code beanRefFactory.xml} file inside jar for services module:
 *
 * <pre class="code">
 * &lt;?xml version="1.0" encoding="UTF-8"?>
 * &lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
 *
 * &lt;beans>
 *   &lt;!-- child of data-access -->
 *   &lt;bean id="com.mycompany.myapp.services" lazy-init="true"
 *        class="org.springframework.context.support.ClassPathXmlApplicationContext">
 *     &lt;constructor-arg>
 *       &lt;list>&lt;value>com/mycompany/myapp/dataaccess/services.xml&lt;/value>&lt;/list>
 *     &lt;/constructor-arg>
 *     &lt;constructor-arg>
 *       &lt;ref bean="com.mycompany.myapp.dataaccess"/>
 *     &lt;/constructor-arg>
 *   &lt;/bean>
 * &lt;/beans>
 * </pre>
 *
 * {@code beanRefFactory.xml} file inside jar for mypackage module. This doesn't
 * create any of its own contexts, but allows the other ones to be referred to be
 * a name known to this module:
 *
 * <pre class="code">
 * &lt;?xml version="1.0" encoding="UTF-8"?>
 * &lt;!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">
 *
 * &lt;beans>
 *   &lt;!-- define an alias for "com.mycompany.myapp.services" -->
 *   &lt;alias name="com.mycompany.myapp.services" alias="com.mycompany.myapp.mypackage"/&gt;
 * &lt;/beans>
 * </pre>
 *
 * @author Colin Sampaleanu
 * @author Juergen Hoeller
 * @see com.ejie.x38.spring.context.access.ContextSingletonBeanFactoryLocator
 * @see org.springframework.context.access.DefaultLocatorFactory
 */
public class SingletonBeanFactoryLocator implements BeanFactoryLocator {

    private static final String DEFAULT_RESOURCE_LOCATION = "classpath*:beanRefFactory.xml";

    protected static final Log logger = LogFactory.getLog(SingletonBeanFactoryLocator.class);

    /** The keyed BeanFactory instances */
    private static final Map<String, BeanFactoryLocator> instances = new HashMap<>();

    /**
     * Returns an instance which uses the default "classpath*:beanRefFactory.xml",
     * as the name of the definition file(s). All resources returned by calling the
     * current thread context ClassLoader's {@code getResources} method with
     * this name will be combined to create a BeanFactory definition set.
     *
     * @return the corresponding BeanFactoryLocator instance
     * @throws BeansException
     *             in case of factory loading failure
     */
    public static BeanFactoryLocator getInstance() throws BeansException {
	return SingletonBeanFactoryLocator.getInstance(null);
    }

    /**
     * Returns an instance which uses the specified selector, as the name of the
     * definition file(s). In the case of a name with a Spring 'classpath*:' prefix,
     * or with no prefix, which is treated the same, the current thread context
     * ClassLoader's {@code getResources} method will be called with this value
     * to get all resources having that name. These resources will then be combined to
     * form a definition. In the case where the name uses a Spring 'classpath:' prefix,
     * or a standard URL prefix, then only one resource file will be loaded as the
     * definition.
     *
     * @param selector
     *            the name of the resource(s) which will be read and
     *            combined to form the definition for the BeanFactoryLocator instance.
     *            Any such files must form a valid BeanFactory definition.
     * @return the corresponding BeanFactoryLocator instance
     * @throws BeansException
     *             in case of factory loading failure
     */
    public static BeanFactoryLocator getInstance(String selector) throws BeansException {
	String resourceLocation = selector;
	if (resourceLocation == null) {
	    resourceLocation = DEFAULT_RESOURCE_LOCATION;
	}

	// For backwards compatibility, we prepend 'classpath*:' to the selector name if there
	// is no other prefix (i.e. classpath*:, classpath:, or some URL prefix.
	if (!ResourcePatternUtils.isUrl(resourceLocation)) {
	    resourceLocation = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX + resourceLocation;
	}

	synchronized (instances) {
	    if (logger.isTraceEnabled()) {
		logger.trace("SingletonBeanFactoryLocator.getInstance(): instances.hashCode=" + instances.hashCode()
			+ ", instances=" + instances);
	    }
	    BeanFactoryLocator bfl = instances.get(resourceLocation);
	    if (bfl == null) {
		bfl = new SingletonBeanFactoryLocator(resourceLocation);
		instances.put(resourceLocation, bfl);
	    }
	    return bfl;
	}
    }

    // We map BeanFactoryGroup objects by String keys, and by the definition object.
    private final Map<String, BeanFactoryGroup> bfgInstancesByKey = new HashMap<>();

    private final Map<BeanFactory, BeanFactoryGroup> bfgInstancesByObj = new HashMap<>();

    private final String resourceLocation;

    /**
     * Constructor which uses the specified name as the resource name
     * of the definition file(s).
     *
     * @param resourceLocation
     *            the Spring resource location to use
     *            (either a URL or a "classpath:" / "classpath*:" pseudo URL)
     */
    protected SingletonBeanFactoryLocator(String resourceLocation) {
	this.resourceLocation = resourceLocation;
    }

    @Override
    public BeanFactoryReference useBeanFactory(String factoryKey) throws BeansException {
	synchronized (this.bfgInstancesByKey) {
	    BeanFactoryGroup bfg = this.bfgInstancesByKey.get(this.resourceLocation);

	    if (bfg != null) {
		bfg.refCount++;
	    } else {
		// This group definition doesn't exist, we need to try to load it.
		if (logger.isTraceEnabled()) {
		    logger.trace("Factory group with resource name [" + this.resourceLocation
			    + "] requested. Creating new instance.");
		}

		// Create the BeanFactory but don't initialize it.
		BeanFactory groupContext = createDefinition(this.resourceLocation, factoryKey);

		// Record its existence now, before instantiating any singletons.
		bfg = new BeanFactoryGroup();
		bfg.definition = groupContext;
		bfg.refCount = 1;
		this.bfgInstancesByKey.put(this.resourceLocation, bfg);
		this.bfgInstancesByObj.put(groupContext, bfg);

		// Now initialize the BeanFactory. This may cause a re-entrant invocation
		// of this method, but since we've already added the BeanFactory to our
		// mappings, the next time it will be found and simply have its
		// reference count incremented.
		try {
		    initializeDefinition(groupContext);
		} catch (BeansException ex) {
		    this.bfgInstancesByKey.remove(this.resourceLocation);
		    this.bfgInstancesByObj.remove(groupContext);
		    throw new BootstrapException("Unable to initialize group definition. " + "Group resource name ["
			    + this.resourceLocation + "], factory key [" + factoryKey + "]", ex);
		}
	    }

	    try {
		BeanFactory beanFactory;
		if (factoryKey != null) {
		    beanFactory = bfg.definition.getBean(factoryKey, BeanFactory.class);
		} else {
		    beanFactory = bfg.definition.getBean(BeanFactory.class);
		}
		return new CountingBeanFactoryReference(beanFactory, bfg.definition);
	    } catch (BeansException ex) {
		throw new BootstrapException("Unable to return specified BeanFactory instance: factory key ["
			+ factoryKey + "], from group with resource name [" + this.resourceLocation + "]", ex);
	    }

	}
    }

    /**
     * Actually creates definition in the form of a BeanFactory, given a resource name
     * which supports standard Spring resource prefixes ('classpath:', 'classpath*:', etc.)
     * This is split out as a separate method so that subclasses can override the actual
     * type used (to be an ApplicationContext, for example).
     * <p>
     * The default implementation simply builds a
     * {@link org.springframework.beans.factory.support.DefaultListableBeanFactory}
     * and populates it using an
     * {@link org.springframework.beans.factory.xml.XmlBeanDefinitionReader}.
     * <p>
     * This method should not instantiate any singletons. That function is performed
     * by {@link #initializeDefinition initializeDefinition()}, which should also be
     * overridden if this method is.
     *
     * @param resourceLocation
     *            the resource location for this factory group
     * @param factoryKey
     *            the bean name of the factory to obtain
     * @return the corresponding BeanFactory reference
     */
    protected BeanFactory createDefinition(String resourceLocation, String factoryKey) {
	DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
	XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
	ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();

	try {
	    Resource[] configResources = resourcePatternResolver.getResources(resourceLocation);
	    if (configResources.length == 0) {
		throw new FatalBeanException("Unable to find resource for specified definition. "
			+ "Group resource name [" + this.resourceLocation + "], factory key [" + factoryKey + "]");
	    }
	    reader.loadBeanDefinitions(configResources);
	} catch (IOException ex) {
	    throw new BeanDefinitionStoreException(
		    "Error accessing bean definition resource [" + this.resourceLocation + "]", ex);
	} catch (BeanDefinitionStoreException ex) {
	    throw new FatalBeanException("Unable to load group definition: " + "group resource name ["
		    + this.resourceLocation + "], factory key [" + factoryKey + "]", ex);
	}

	return factory;
    }

    /**
     * Instantiate singletons and do any other normal initialization of the factory.
     * Subclasses that override {@link #createDefinition createDefinition()} should
     * also override this method.
     *
     * @param groupDef
     *            the factory returned by {@link #createDefinition createDefinition()}
     */
    protected void initializeDefinition(BeanFactory groupDef) {
	if (groupDef instanceof ConfigurableListableBeanFactory) {
	    ((ConfigurableListableBeanFactory) groupDef).preInstantiateSingletons();
	}
    }

    /**
     * Destroy definition in separate method so subclass may work with other definition types.
     *
     * @param groupDef
     *            the factory returned by {@link #createDefinition createDefinition()}
     * @param selector
     *            the resource location for this factory group
     */
    protected void destroyDefinition(BeanFactory groupDef, String selector) {
	if (groupDef instanceof ConfigurableBeanFactory) {
	    if (logger.isTraceEnabled()) {
		logger.trace("Factory group with selector '" + selector
			+ "' being released, as there are no more references to it");
	    }
	    ((ConfigurableBeanFactory) groupDef).destroySingletons();
	}
    }

    /**
     * We track BeanFactory instances with this class.
     */
    private static class BeanFactoryGroup {

	private BeanFactory definition;

	private int refCount = 0;
    }

    /**
     * BeanFactoryReference implementation for this locator.
     */
    private class CountingBeanFactoryReference implements BeanFactoryReference {

	private BeanFactory beanFactory;

	private BeanFactory groupContextRef;

	public CountingBeanFactoryReference(BeanFactory beanFactory, BeanFactory groupContext) {
	    this.beanFactory = beanFactory;
	    this.groupContextRef = groupContext;
	}

	@Override
	public BeanFactory getFactory() {
	    return this.beanFactory;
	}

	// Note that it's legal to call release more than once!
	@Override
	public void release() throws FatalBeanException {
	    synchronized (bfgInstancesByKey) {
		BeanFactory savedRef = this.groupContextRef;
		if (savedRef != null) {
		    this.groupContextRef = null;
		    BeanFactoryGroup bfg = bfgInstancesByObj.get(savedRef);
		    if (bfg != null) {
			bfg.refCount--;
			if (bfg.refCount == 0) {
			    destroyDefinition(savedRef, resourceLocation);
			    bfgInstancesByKey.remove(resourceLocation);
			    bfgInstancesByObj.remove(savedRef);
			}
		    } else {
			// This should be impossible.
			logger.warn("Tried to release a SingletonBeanFactoryLocator group definition "
				+ "more times than it has actually been used. Resource name [" + resourceLocation
				+ "]");
		    }
		}
	    }
	}
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/SourceHttpMessageConverter.java
================================================
/*
 * Copyright 2002-2016 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.StringReader;
import java.util.HashSet;
import java.util.Set;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLResolver;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stax.StAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.w3c.dom.Document;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import org.springframework.http.HttpInputMessage;
import org.springframework.http.HttpOutputMessage;
import org.springframework.http.MediaType;
import org.springframework.http.converter.AbstractHttpMessageConverter;
import org.springframework.http.converter.HttpMessageConversionException;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.http.converter.HttpMessageNotWritableException;
import org.springframework.util.StreamUtils;

/**
 * Implementation of {@link org.springframework.http.converter.HttpMessageConverter}
 * that can read and write {@link Source} objects.
 *
 * @author Arjen Poutsma
 * @author Rossen Stoyanchev
 * @since 3.0
 */
public class SourceHttpMessageConverter<T extends Source> extends AbstractHttpMessageConverter<T> {

	private static final Set<Class<?>> SUPPORTED_CLASSES = new HashSet<Class<?>>(5);

	static {
		SUPPORTED_CLASSES.add(DOMSource.class);
		SUPPORTED_CLASSES.add(SAXSource.class);
		SUPPORTED_CLASSES.add(StAXSource.class);
		SUPPORTED_CLASSES.add(StreamSource.class);
		SUPPORTED_CLASSES.add(Source.class);
	}


	private final TransformerFactory transformerFactory = TransformerFactory.newInstance();

	private boolean supportDtd = false;

	private boolean processExternalEntities = false;


	/**
	 * Sets the {@link #setSupportedMediaTypes(java.util.List) supportedMediaTypes}
	 * to {@code text/xml} and {@code application/xml}, and {@code application/*-xml}.
	 */
	public SourceHttpMessageConverter() {
		super(MediaType.APPLICATION_XML, MediaType.TEXT_XML, new MediaType("application", "*+xml"));
	}


	/**
	 * Indicates whether DTD parsing should be supported.
	 * <p>Default is {@code false} meaning that DTD is disabled.
	 */
	public void setSupportDtd(boolean supportDtd) {
		this.supportDtd = supportDtd;
	}

	/**
	 * Whether DTD parsing is supported.
	 */
	public boolean isSupportDtd() {
		return this.supportDtd;
	}

	/**
	 * Indicates whether external XML entities are processed when converting to a Source.
	 * <p>Default is {@code false}, meaning that external entities are not resolved.
	 * <p><strong>Note:</strong> setting this option to {@code true} also
	 * automatically sets {@link #setSupportDtd} to {@code true}.
	 */
	public void setProcessExternalEntities(boolean processExternalEntities) {
		this.processExternalEntities = processExternalEntities;
		if (processExternalEntities) {
			setSupportDtd(true);
		}
	}

	/**
	 * Returns the configured value for whether XML external entities are allowed.
	 */
	public boolean isProcessExternalEntities() {
		return this.processExternalEntities;
	}


	@Override
	public boolean supports(Class<?> clazz) {
		return SUPPORTED_CLASSES.contains(clazz);
	}

	@Override
	@SuppressWarnings("unchecked")
	protected T readInternal(Class<? extends T> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException {

		InputStream body = inputMessage.getBody();
		if (DOMSource.class == clazz) {
			return (T) readDOMSource(body);
		}
		else if (SAXSource.class == clazz) {
			return (T) readSAXSource(body);
		}
		else if (StAXSource.class == clazz) {
			return (T) readStAXSource(body);
		}
		else if (StreamSource.class == clazz || Source.class == clazz) {
			return (T) readStreamSource(body);
		}
		else {
			throw new HttpMessageConversionException("Could not read class [" + clazz +
					"]. Only DOMSource, SAXSource, StAXSource, and StreamSource are supported.");
		}
	}

	private DOMSource readDOMSource(InputStream body) throws IOException {
		try {
			DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
			documentBuilderFactory.setNamespaceAware(true);
			documentBuilderFactory.setFeature(
					"http://apache.org/xml/features/disallow-doctype-decl", !isSupportDtd());
			documentBuilderFactory.setFeature(
					"http://xml.org/sax/features/external-general-entities", isProcessExternalEntities());
			DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();
			if (!isProcessExternalEntities()) {
				documentBuilder.setEntityResolver(NO_OP_ENTITY_RESOLVER);
			}
			Document document = documentBuilder.parse(body);
			return new DOMSource(document);
		}
		catch (NullPointerException ex) {
			if (!isSupportDtd()) {
				throw new HttpMessageNotReadableException("NPE while unmarshalling: " +
						"This can happen due to the presence of DTD declarations which are disabled.", ex);
			}
			throw ex;
		}
		catch (ParserConfigurationException ex) {
			throw new HttpMessageNotReadableException("Could not set feature: " + ex.getMessage(), ex);
		}
		catch (SAXException ex) {
			throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex);
		}
	}

	private SAXSource readSAXSource(InputStream body) throws IOException {
		try {
			XMLReader xmlReader = XMLReaderFactory.createXMLReader();
			xmlReader.setFeature("http://apache.org/xml/features/disallow-doctype-decl", !isSupportDtd());
			xmlReader.setFeature("http://xml.org/sax/features/external-general-entities", isProcessExternalEntities());
			if (!isProcessExternalEntities()) {
				xmlReader.setEntityResolver(NO_OP_ENTITY_RESOLVER);
			}
			byte[] bytes = StreamUtils.copyToByteArray(body);
			return new SAXSource(xmlReader, new InputSource(new ByteArrayInputStream(bytes)));
		}
		catch (SAXException ex) {
			throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex);
		}
	}

	private Source readStAXSource(InputStream body) {
		try {
			XMLInputFactory inputFactory = XMLInputFactory.newInstance();
			inputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, isSupportDtd());
			inputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, isProcessExternalEntities());
			if (!isProcessExternalEntities()) {
				inputFactory.setXMLResolver(NO_OP_XML_RESOLVER);
			}
			XMLStreamReader streamReader = inputFactory.createXMLStreamReader(body);
			return new StAXSource(streamReader);
		}
		catch (XMLStreamException ex) {
			throw new HttpMessageNotReadableException("Could not parse document: " + ex.getMessage(), ex);
		}
	}

	private StreamSource readStreamSource(InputStream body) throws IOException {
		byte[] bytes = StreamUtils.copyToByteArray(body);
		return new StreamSource(new ByteArrayInputStream(bytes));
	}

	@Override
	protected Long getContentLength(T t, MediaType contentType) {
		if (t instanceof DOMSource) {
			try {
				CountingOutputStream os = new CountingOutputStream();
				transform(t, new StreamResult(os));
				return os.count;
			}
			catch (TransformerException ex) {
				// ignore
			}
		}
		return null;
	}

	@Override
	protected void writeInternal(T t, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException {
		try {
			Result result = new StreamResult(outputMessage.getBody());
			transform(t, result);
		}
		catch (TransformerException ex) {
			throw new HttpMessageNotWritableException("Could not transform [" + t + "] to output message", ex);
		}
	}

	private void transform(Source source, Result result) throws TransformerException {
		this.transformerFactory.newTransformer().transform(source, result);
	}


	private static class CountingOutputStream extends OutputStream {

		long count = 0;

		@Override
		public void write(int b) throws IOException {
			this.count++;
		}

		@Override
		public void write(byte[] b) throws IOException {
			this.count += b.length;
		}

		@Override
		public void write(byte[] b, int off, int len) throws IOException {
			this.count += len;
		}
	}


	private static final EntityResolver NO_OP_ENTITY_RESOLVER = new EntityResolver() {
		@Override
		public InputSource resolveEntity(String publicId, String systemId) {
			return new InputSource(new StringReader(""));
		}
	};

	private static final XMLResolver NO_OP_XML_RESOLVER = new XMLResolver() {
		@Override
		public Object resolveEntity(String publicID, String systemID, String base, String ns) {
			return StreamUtils.emptyInput();
		}
	};

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/UdaContextLoaderListener.java
================================================
/*
* Copyright 2023 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.spring.context;

import javax.servlet.ServletContext;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.context.ApplicationContext;
import org.springframework.web.context.ContextLoader;
import org.springframework.web.context.ContextLoaderListener;

/**
 * This class mirrors ContextLoaderListener from Spring 4 with BeanFactoryLocator mechanism enabled.
 * 
 * @since 6.0.0
 */
public class UdaContextLoaderListener extends ContextLoaderListener {

	/**
	 * Optional servlet context parameter (i.e., "{@code locatorFactorySelector}")
	 * used only when obtaining a parent context using the default implementation of
	 * {@link #loadParentContext(ServletContext servletContext)}. Specifies the
	 * 'selector' used in the
	 * {@link ContextSingletonBeanFactoryLocator#getInstance(String selector)}
	 * method call, which is used to obtain the BeanFactoryLocator instance from
	 * which the parent context is obtained.
	 * <p>
	 * The default is {@code classpath*:beanRefContext.xml}, matching the default
	 * applied for the {@link ContextSingletonBeanFactoryLocator#getInstance()}
	 * method. Supplying the "parentContextKey" parameter is sufficient in this
	 * case.
	 */
	public static final String LOCATOR_FACTORY_SELECTOR_PARAM = "locatorFactorySelector";

	/**
	 * Optional servlet context parameter (i.e., "{@code parentContextKey}") used
	 * only when obtaining a parent context using the default implementation of
	 * {@link #loadParentContext(ServletContext servletContext)}. Specifies the
	 * 'factoryKey' used in the
	 * {@link BeanFactoryLocator#useBeanFactory(String factoryKey)} method call,
	 * obtaining the parent application context from the BeanFactoryLocator
	 * instance.
	 * <p>
	 * Supplying this "parentContextKey" parameter is sufficient when relying on the
	 * default {@code classpath*:beanRefContext.xml} selector for candidate factory
	 * references.
	 */
	public static final String LOCATOR_FACTORY_KEY_PARAM = "parentContextKey";

	/**
	 * Holds BeanFactoryReference when loading parent factory via
	 * ContextSingletonBeanFactoryLocator.
	 */
	private BeanFactoryReference parentContextRef;

	/**
	 * Template method with default implementation (which may be overridden by a
	 * subclass), to load or obtain an ApplicationContext instance which will be
	 * used as the parent context of the root WebApplicationContext. If the return
	 * value from the method is null, no parent context is set.
	 * <p>
	 * The main reason to load a parent context here is to allow multiple root web
	 * application contexts to all be children of a shared EAR context, or
	 * alternately to also share the same parent context that is visible to EJBs.
	 * For pure web applications, there is usually no need to worry about having a
	 * parent context to the root web application context.
	 * <p>
	 * The default implementation uses
	 * {@link org.springframework.context.access.ContextSingletonBeanFactoryLocator},
	 * configured via {@link #LOCATOR_FACTORY_SELECTOR_PARAM} and
	 * {@link #LOCATOR_FACTORY_KEY_PARAM}, to load a parent context which will be
	 * shared by all other users of ContextsingletonBeanFactoryLocator which also
	 * use the same configuration parameters.
	 * 
	 * @param servletContext current servlet context
	 * @return the parent application context, or {@code null} if none
	 * @see org.springframework.context.access.ContextSingletonBeanFactoryLocator
	 */
	@Override
	protected ApplicationContext loadParentContext(ServletContext servletContext) {
		ApplicationContext parentContext = null;
		String locatorFactorySelector = servletContext.getInitParameter(LOCATOR_FACTORY_SELECTOR_PARAM);
		String parentContextKey = servletContext.getInitParameter(LOCATOR_FACTORY_KEY_PARAM);

		if (parentContextKey != null) {
			// locatorFactorySelector may be null, indicating the default "classpath*:beanRefContext.xml"
			BeanFactoryLocator locator = ContextSingletonBeanFactoryLocator.getInstance(locatorFactorySelector);
			Log logger = LogFactory.getLog(ContextLoader.class);
			if (logger.isDebugEnabled()) {
				logger.debug("Getting parent context definition: using parent context key of '" + parentContextKey
						+ "' with BeanFactoryLocator");
			}
			this.parentContextRef = locator.useBeanFactory(parentContextKey);
			parentContext = (ApplicationContext) this.parentContextRef.getFactory();
		}

		return parentContext;
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/WebUtils.java
================================================
package com.ejie.x38.spring.context;

import org.springframework.web.util.UriUtils;

public class WebUtils {

    /**
     * Extract the URL filename from the given request URL path.
     * Correctly resolves nested paths such as "/products/view.html" as well.
     *
     * @param urlPath
     *            the request URL path (e.g. "/index.html")
     * @return the extracted URI filename (e.g. "index")
     * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
     */
    @Deprecated
    public static String extractFilenameFromUrlPath(String urlPath) {
	String filename = WebUtils.extractFullFilenameFromUrlPath(urlPath);
	int dotIndex = filename.lastIndexOf('.');
	if (dotIndex != -1) {
	    filename = filename.substring(0, dotIndex);
	}
	return filename;
    }

    /**
     * Extract the full URL filename (including file extension) from the given
     * request URL path. Correctly resolve nested paths such as
     * "/products/view.html" and remove any path and or query parameters.
     *
     * @param urlPath
     *            the request URL path (e.g. "/products/index.html")
     * @return the extracted URI filename (e.g. "index.html")
     * @deprecated as of Spring 4.3.2, in favor of custom code for such purposes
     *             (or {@link UriUtils#extractFileExtension} for the file extension use case)
     */
    @Deprecated
    public static String extractFullFilenameFromUrlPath(String urlPath) {
	int end = urlPath.indexOf('?');
	if (end == -1) {
	    end = urlPath.indexOf('#');
	    if (end == -1) {
		end = urlPath.length();
	    }
	}
	int begin = urlPath.lastIndexOf('/', end) + 1;
	int paramIndex = urlPath.indexOf(';', begin);
	end = (paramIndex != -1 && paramIndex < end ? paramIndex : end);
	return urlPath.substring(begin, end);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/spring/context/XmlAwareFormHttpMessageConverter.java
================================================
/*
 * Copyright 2002-2013 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.spring.context;

import javax.xml.transform.Source;

import org.springframework.http.converter.FormHttpMessageConverter;

/**
 * Extension of {@link org.springframework.http.converter.FormHttpMessageConverter},
 * adding support for XML-based parts through a {@link SourceHttpMessageConverter}.
 *
 * @author Juergen Hoeller
 * @since 3.0.3
 * @deprecated in favor of
 * {@link org.springframework.http.converter.support.AllEncompassingFormHttpMessageConverter}
 */
@Deprecated
public class XmlAwareFormHttpMessageConverter extends FormHttpMessageConverter {

	public XmlAwareFormHttpMessageConverter() {
		super();
		addPartConverter(new SourceHttpMessageConverter<Source>());
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/Constants.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.text.SimpleDateFormat;

/**
 * 
 * @author UDA
 *
 */
public class Constants {

	public static final String EUSKARA = "eu";
	public static final String FRANCAIS = "fr";
	public static final String CASTELLANO = "es";
	public static final String ENGLISH = "en";
	
	public static final String X38_VERSION = "6.1.0-RELEASE";
	
	public static final SimpleDateFormat DDMMYYYY_DATE_FORMAT = new SimpleDateFormat("dd/MM/yyyy");
	public static final SimpleDateFormat YYYYMMDD_DATE_FORMAT = new SimpleDateFormat("yyyy/MM/dd");
	
	public static final SimpleDateFormat DDMMYYYY_HHMMSS_DATE_FORMAT = new SimpleDateFormat("dd/MM/yyyy HH:mm:ss");
	public static final SimpleDateFormat YYYYMMDD_HHMMSS_DATE_FORMAT = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
	
	public static final SimpleDateFormat HHMMSS_TIME_FORMAT = new SimpleDateFormat("HH:mm:ss");
	
	// MultiPK separator
	public static final String PK_TOKEN = "@@@@";
	
	// Security
	public static final String DATA_NOT_APPLICABLE = "N/A";
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/DateTimeManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

import com.ejie.x38.log.LogConstants;

/**
 * 
 * @author UDA
 *
 */
public class DateTimeManager {
	
	public static SimpleDateFormat getDateTimeFormat(Locale locale){
		if(locale.getLanguage().equals(Constants.EUSKARA)){
			return Constants.YYYYMMDD_DATE_FORMAT;
		}else if(locale.getLanguage().equals(Constants.FRANCAIS) || locale.getLanguage().equals(Constants.CASTELLANO) || locale.getLanguage().equals(Constants.ENGLISH)){
			return Constants.DDMMYYYY_DATE_FORMAT;
		}else{
			return Constants.DDMMYYYY_DATE_FORMAT;
		}
	}
	
	public static SimpleDateFormat getTimestampFormat(Locale locale){
		if(locale.getLanguage().equals(Constants.EUSKARA)){
			return Constants.YYYYMMDD_HHMMSS_DATE_FORMAT;
		}else if(locale.getLanguage().equals(Constants.FRANCAIS) || locale.getLanguage().equals(Constants.CASTELLANO) || locale.getLanguage().equals(Constants.ENGLISH)){
			return Constants.DDMMYYYY_HHMMSS_DATE_FORMAT;
		}else{
			return Constants.DDMMYYYY_HHMMSS_DATE_FORMAT;
		}
	}
	
	public static SimpleDateFormat getTimeFormat(Locale locale){
		return Constants.HHMMSS_TIME_FORMAT;
	}
	
	public static String getDateTime() {
        DateFormat dateFormat = new SimpleDateFormat(LogConstants.DATETIMEFORMAT);
        Date date = new Date();
        return dateFormat.format(date);
    }
	
	
	public static String getHttpExpiredDate(){
		final Calendar calendar = Calendar.getInstance();
		//calendar.set(2010,8,25);
		calendar.add(Calendar.DAY_OF_YEAR, 3);

		final DateFormat httpDateFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
		httpDateFormat.setTimeZone(TimeZone.getTimeZone("GMT"));

		return httpDateFormat.format(calendar.getTime());
	}
	
	public static String getHttpExpiredDate(Date date){

		final DateFormat httpDateFormat = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss z", Locale.US);
		httpDateFormat.setTimeZone(TimeZone.getTimeZone("GMT"));

		return httpDateFormat.format(date);
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/IframeXHREmulationUtils.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.io.IOException;

import javax.servlet.ServletOutputStream;
import javax.servlet.ServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.http.HttpStatus;

/**
 * Clase de utilidades para realizar la emulación de llamadas XHR utilizando iframes.
 * 
 * @author UDA
 *
 */
public class IframeXHREmulationUtils {

	public static final String PARAM_EMULATE_IFRAME_HTTP_STATUS = "_emulate_iframe_http_status";
	
	/**
	 * Comprueba si es necesario realizar la emulación. La emulación se indica
	 * mediante la presencia en la request del parámetro
	 * PARAM_EMULATE_IFRAME_HTTP_STATUS.
	 * 
	 * @param request
	 *            Petición HTTP.
	 * @return <b>true</b> o <b>false</b> dependiendo si es necesaria o no
	 *         realizar la emulación.
	 */
	public static boolean isIframeEmulationRequired(ServletRequest request){
		
		String emulate_iframe_http_status = request.getParameter(IframeXHREmulationUtils.PARAM_EMULATE_IFRAME_HTTP_STATUS);
		
		if (emulate_iframe_http_status!=null && Boolean.TRUE.toString().equals(emulate_iframe_http_status.toLowerCase())){
			return true;
		}
		
		return false;
	}
	
	/**
	 * @see IframeXHREmulationUtils.writeIframeHttpStatus
	 */
	public static void writeIframeHttpStatus(HttpServletResponse response, String data, int httpStatusCode) throws IOException{
		IframeXHREmulationUtils.writeIframeHttpStatus(response, data, httpStatusCode, null);
	}
		
	
	/**
	 * Escribe en la respuesta de la petición el mensaje correspondiente al
	 * contenido y el código de estado http indicados.</br> El contenido enviado
	 * en la request para permitir la emulación se arropa dentro de un textárea
	 * en cuyos atributos <i>status</i> y <i>statusText</i> se incluye la
	 * información de los errores http. La estructura enviada es la siguiente:
	 * 
	 * <pre>
	 * 
	 *  <textarea status="406" statusText="NotAcceptable">
	 *  	["Contenido de la respuesta en formato json"]
	 *  </textarea>
	 * 
	 * </pre>
	 * 
	 * @param response
	 *            Respuesta HTTP.
	 * @param data
	 *            Información que debe ser incluida en la respuesta.
	 * @param httpStatusCode
	 *            Código de error de estado HTTP.
	 * @param httpStatusCodeText
	 *            Textp del código de error de estado HTTP.
	 * @throws IOException
	 *             Excepción producida en operaciones I/O.
	 */
	public static void writeIframeHttpStatus(HttpServletResponse response, String data, int httpStatusCode, String httpStatusCodeText) throws IOException{
		

//		response.setStatus(HttpServletResponse.SC_OK);
//		response.setContentType("text/html");
//        response.setCharacterEncoding("UTF-8");

        HttpStatus httpStatus = HttpStatus.valueOf(httpStatusCode);
        
        
		
		StringBuilder sb = new StringBuilder();
		
		sb.append("<textarea ");
		sb.append("status=\"");
		sb.append(httpStatus.value());
		sb.append("\" ");
		sb.append("statusText=\"");
		if (httpStatusCodeText!=null){
			
		}else{
			sb.append(httpStatus.getReasonPhrase());
		}
		sb.append("\">");
		sb.append(data);
		sb.append("</textarea>");

		
		
		
		response.getWriter().write(sb.toString());
		
		response.setStatus(HttpServletResponse.SC_OK);
		response.setContentType("text/html; charset=UTF-8");
//		response.setCharacterEncoding("UTF-8");
		response.setHeader("Content-Type", "text/html; charset=UTF-8");
		response.getWriter().flush();
		
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/ManagementUrl.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

import javax.servlet.http.HttpServletRequest;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * 
 * @author UDA
 *
 */
//Getion asociada al acelerador de codigo de produccion (https => http) en EJIE
public class ManagementUrl {
	
	private static final Logger logger = LoggerFactory.getLogger(ManagementUrl.class);

	//Método que determina si la llamada esta o no acelerada 
	public static boolean isAcceleratedUrl(HttpServletRequest request){
		if (request.getHeader ("N38_URL") != null){
			logger.info("The aplication is being accelerated");
			return true;
		} else {
			logger.info("The aplication isn't being accelerated");
			return false;
		}
	}
	
	//Método que devuelve la url real asociada a la aceleracion  
	public static String getUrl(HttpServletRequest request){
		String url = request.getHeader("N38_URL");
		if (url != null){
			logger.info("N38_URL header: " + url);

		} else {
			url = request.getRequestURL().toString();
			logger.info("Request header: " + url);
			
		}
		if(request.getQueryString() != null){
			try {
				url = url+"?"+URLEncoder.encode(request.getQueryString(), "UTF-8");
			} catch (UnsupportedEncodingException e) {
				logger.error("getUrl(): Error Url encoder.", e);
			}
		}
		return url;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/MiscUtilitiesManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * 
 * @author UDA
 *
 */
public final class MiscUtilitiesManager {
	
	/**
	 * Reemplaza un string por otro en una cadena reiterativamente
	 * 
	 * @param String cadena de texto fuente
	 * @param String cadena a reemplazar
	 * @param String cadena de reemplazo
	 * @return String cadena resultado
	 */
	public static String replaceString(String src, String old, String newOne) {

		StringBuffer sbuf = new StringBuffer(src);
		int oldPos = 0;
		int fromIndex = 0;
		int offset = 0;

		while (true) {
			oldPos = src.indexOf(old, fromIndex);
			if (oldPos == -1)
				break;

			oldPos += offset;
			fromIndex = oldPos + 1;

			sbuf.replace(oldPos, oldPos + old.length(), newOne);
			offset = newOne.length() - 1;
		}

		String strBuffer = sbuf.toString();
		sbuf = null;

		return strBuffer;

	}
	
	/**
     * Método que comprueba si un object es nula
     * 
     * @param o Object a comprobar
     * @return boolean true si la cadena no es nula y no es la cadena vacía; false en caso contrario, si la cadena tiene blancos
     *         no se considera cadena vacía.
     */
    public static boolean isNotNull(Object o) {
        return (o != null && !o.equals("null"));
    }
    /**
     * Método que comprueba si una colección es nula o es está vacía.
     * 
     * @param c Colección a comprobar
     * @return boolean true si la colección es nula o está vacía; false en caso contrario.
     */
    public static boolean isBlank(Collection<?> c) {
        return (c == null || c.isEmpty());
    }

    /**
     * Método que comprueba si una cadena es nula o es la cadena vacía.
     * 
     * @param s String a comprobar
     * @return boolean true si la cadena es nula o es la cadena vacía; false en caso contrario, si la cadena tiene blancos no se
     *         considera cadena vacía.
     */
    public static boolean isBlank(String s) {
        return (s == null || s.equals(""));
    }

    /**
     * Método que comprueba si una cadena no es nula y no es la cadena vacía.
     * 
     * @param s String a comprobar
     * @return boolean true si la cadena no es nula y no es la cadena vacía; false en caso contrario, si la cadena tiene blancos
     *         no se considera cadena vacía.
     */
    public static boolean isNotBlank(String s) {
        return (s != null && !s.equals(""));
    }
  
    /**
     * Metodo que; pasando un String, le concatena las funciones TRIM(UPPER(param)) para tratamiento Oracle.
     * 
     * @param param String a la que hacer TRIM(UPPER(param))
     * @return devuelve conformado el String
     */
    public static String upperAndTrimOracle(String param) {
        return "TRIM(UPPER(" + param + "))";
    }

    /**
     * Metodo que; pasando un String, le concatena las funciones TRIM(UPPER(String)) para tratamiento JAVA.
     * 
     * @param param String a la que hacer param.trim().toUpperCase()
     * @return devuelve conformado el String
     */
    public static String upperAndTrimJava(String param) {
        return param.trim().toUpperCase();
    }

    /**
     * Método que une los elementos de un array en un String, separando los elementos por comas.
     * 
     * @param a El array del cual se obtendrán los valores de elementos que formarrán el String
     * @return El String con los valores de los elementos separados por comas. En caso de que algún elemento de array sea null se
     *         añadirá la cadena "null" como valor del elemento
     */
    public static String join(Object[] a) {
        StringBuffer s = new StringBuffer();
        for (int i = 0; i < a.length; ++i) {
            if (s.length() > 0) {
                s.append(", ");
            }
            s.append((a[i] == null) ? "null" : a[i].toString());
        }
        return s.toString();
    }
    
    /**
     * Método que une los elementos de un array en un String, separando los elementos la cadena de separacion indicada.
     * 
     * @param a El array del cual se obtendrán los valores de elementos que formarrán el String
     * @param seprator Cadena de separacion de los elementos
     * @param withNulls Indica si los elementos nulos se insertará como "null" en la lista de lementos
     * @return El String con los valores de los elementos separados por comas. En caso de que algún elemento de array sea null se
     *         añadirá la cadena "null" como valor del elemento si withNulls es true
     */
    public static String join(Object[] a, String seperator, boolean withNulls) {
        StringBuffer s = new StringBuffer();
        for (int i = 0; i < a.length; ++i) {
            if (s.length() > 0) {
                s.append(seperator);
            }
            if (a[i] == null) {
                if (withNulls) {
                    s.append("null");
                }
            } else {
                s.append(a[i].toString());
            }
        }
        return s.toString();
    }
    
    /**
     * Método que separa los elementos de una lista en varias listas del tamaño indicado.
     * 
     * @param list La lista de la que se separan los elementos
     * @param size Tamaño de las listas en las cuales son separados los elementos 
     * @return Una lista de listas con los elementos separados
     */
    public static List<List<?>> split(List<?> list, int size) {
        List<List<?>> l = new ArrayList<List<?>>();
        int n = 0;
        int m = (n + size < list.size())?n + size:list.size();
        while (n < list.size()) {
            l.add(list.subList(n, m));
            n = m;
            m = (n + size < list.size())?n + size:list.size();
        }
        return l;
    }
    
    /**
     * Método que reemplaza en una cadena las claves por sus valores indicados en un mapa.
     * 
     * @param format Cadena de plantilla
     * @param data Mapa con las claves y cadenas de reemplazo
     * @return Cadena con los datos reemplazados por los valores indicados en el mapa
     */
    public static String replace(String format, Map<?, ?> data) {
        String s = format;
        for (Iterator<?> it = data.keySet().iterator(); it.hasNext();) {
            String key = (String) it.next();
            String value = (String) data.get(key);
            if (value == null) {
                value = "";
            }
            s = s.replaceAll(key, value);
        }
        return s;
    }
        
    public static String limit(String s, int n) {
        return (s.length() > n)?s.substring(0, n):s;
    }   
    
	/** Lee un fichero a un String
     * @param filePath nombredelfichero a leer 
     * @return String
     * @throws java.io.IOException excepcion
 	**/ 	    
     public static String readFileAsString(String filePath) throws java.io.IOException{
 	    byte[] buffer = new byte[(int) new File(filePath).length()];
 	    BufferedInputStream f = new BufferedInputStream(new FileInputStream(filePath));
 	    f.read(buffer);
 	    return new String(buffer);
 	}
     
     /**
      * CODIFICACION_PLUS_JAVASCRIPT codificacion del escape en javascript para el
      * simbolo +
      */
     public final static String CODIFICACION_PLUS_JAVASCRIPT = "\\+";

       // para la función encodeHTML
       static final String[][] entities = {
           { "&", "amp" }
           
       };
       static String entityMap;
       static String[] quickEntities;
       static {
           int l = entities.length;
           StringBuffer temp = new StringBuffer();
           quickEntities = new String[l];
           for (int i = 0; i < l; i++) {
               temp.append(entities[i][0]);
               quickEntities[i] = "&" + entities[i][1] + ";";
           }
           entityMap = temp.toString();
       }
       
       /**
        * Función para codificar a HTML una cadena
        * @param nonHTMLsrc cadena
        * @return cadena codificada en HTML
        */
       // Función para codificar a HTML una cadena
       public static String encodeHTML(String nonHTMLsrc) {
           if (nonHTMLsrc==null){
               return "";
           }else{
               StringBuffer res = new StringBuffer();
               int l = nonHTMLsrc.length();
               int idx;
               char c;
               for (int i = 0; i < l; i++) {
                   c = nonHTMLsrc.charAt(i);
                   idx = entityMap.indexOf( c);
                   if (idx == -1) res.append( c);
                   else res.append( quickEntities[idx]);
               }
               return(res.toString());
           }
       }
       
   	public static String capitalize(String s) {
		if (s.length() == 0)
			return s;
		return s.substring(0, 1).toUpperCase() + s.substring(1).toLowerCase();
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/ObjectConversionManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.lang.reflect.Method;
import java.math.BigDecimal;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.ParseException;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import org.springframework.context.i18n.LocaleContextHolder;

/**
 * Generic object converter.
 * <p>
 * <h3>Use examples</h3>
 * 
 * <pre>
 * Object o1 = Boolean.TRUE;
 * Integer i = ObjectConverter.convert(o1, Integer.class);
 * System.out.println(i); // 1
 * 
 * Object o2 = "false";
 * Boolean b = ObjectConverter.convert(o2, Boolean.class);
 * System.out.println(b); // false
 * 
 * Object o3 = Integer.valueOf(123);
 * String s = ObjectConverter.convert(o3, String.class);
 * System.out.println(s); // 123
 * </pre>
 * 
 * Not all possible conversions are implemented. You can extend the <tt>ObjectConverter</tt>
 * easily by just adding a new method to it, with the appropriate logic. For example:
 * 
 * <pre>
 * public static ToObject fromObjectToObject(FromObject fromObject) {
 *     // Implement.
 * }
 * </pre>
 * 
 * The method name doesn't matter. It's all about the parameter type and the return type.
 * 
 * @author BalusC
 * @link http://balusc.blogspot.com/2007/08/generic-object-converter.html
 */
public final class ObjectConversionManager {

    // Init ---------------------------------------------------------------------------------------

    private static final Map<String, Method> CONVERTERS = new HashMap<String, Method>();

    static {
        // Preload converters.
        Method[] methods = ObjectConversionManager.class.getDeclaredMethods();
        for (Method method : methods) {
            if (method.getParameterTypes().length == 1) {
                // Converter should accept 1 argument. This skips the convert() method.
                CONVERTERS.put(method.getParameterTypes()[0].getName() + "_"
                    + method.getReturnType().getName(), method);
            }
        }
    }

    private ObjectConversionManager() {
        // Utility class, hide the constructor.
    }

    // Action -------------------------------------------------------------------------------------

    /**
     * Convert the given object value to the given class.
     * @param from The object value to be converted.
     * @param to The type class which the given object should be converted to.
     * @return The converted object value.
     * @throws NullPointerException If 'to' is null.
     * @throws UnsupportedOperationException If no suitable converter can be found.
     * @throws RuntimeException If conversion failed somehow. This can be caused by at least
     * an ExceptionInInitializerError, IllegalAccessException or InvocationTargetException.
     */
    public static <T> T convert(Object from, Class<T> to) {

        // Null is just null.
        if (from == null) {
            return null;
        }

        // Can we cast? Then just do it.
        if (to.isAssignableFrom(from.getClass())) {
            return to.cast(from);
        }

        // Lookup the suitable converter.
        String converterId = from.getClass().getName() + "_" + to.getName();
        Method converter = CONVERTERS.get(converterId);
        if (converter == null) {
            throw new UnsupportedOperationException("Cannot convert from " 
                + from.getClass().getName() + " to " + to.getName()
                + ". Requested converter does not exist.");
        }

        // Convert the value.
        try {
            return to.cast(converter.invoke(to, from));
        } catch (Exception e) {
            throw new RuntimeException("Cannot convert from " 
                + from.getClass().getName() + " to " + to.getName()
                + ". Conversion failed with " + e.getMessage(), e);
        }
    }

    // Converters ---------------------------------------------------------------------------------

    /**
     * Converts Integer to Boolean. If integer value is 0, then return FALSE, else return TRUE.
     * @param value The Integer to be converted.
     * @return The converted Boolean value.
     */
    public static Boolean integerToBoolean(Integer value) {
        return value.intValue() == 0 ? Boolean.FALSE : Boolean.TRUE;
    }

    /**
     * Converts Boolean to Integer. If boolean value is TRUE, then return 1, else return 0.
     * @param value The Boolean to be converted.
     * @return The converted Integer value.
     */
    public static Integer booleanToInteger(Boolean value) {
        return value.booleanValue() ? Integer.valueOf(1) : Integer.valueOf(0);
    }

    /**
     * Converts Double to BigDecimal.
     * @param value The Double to be converted.
     * @return The converted BigDecimal value.
     */
    public static BigDecimal doubleToBigDecimal(Double value) {
        return new BigDecimal(value.doubleValue());
    }

    /**
     * Converts BigDecimal to Double.
     * @param value The BigDecimal to be converted.
     * @return The converted Double value.
     */
    public static Double bigDecimalToDouble(BigDecimal value) {
        return Double.valueOf(value.doubleValue());
    }

    /**
     * Converts Integer to String.
     * @param value The Integer to be converted.
     * @return The converted String value.
     */
    public static String integerToString(Integer value) {
        return value.toString();
    }

    /**
     * Converts String to Integer.
     * @param value The String to be converted.
     * @return The converted Integer value.
     */
    public static Integer stringToInteger(String value) {
        return Integer.valueOf(value);
    }

    /**
     * Converts Boolean to String.
     * @param value The Boolean to be converted.
     * @return The converted String value.
     */
    public static String booleanToString(Boolean value) {
        return value.toString();
    }

    /**
     * Converts String to Boolean.
     * @param value The String to be converted.
     * @return The converted Boolean value.
     */
    public static Boolean stringToBoolean(String value) {
        return Boolean.valueOf(value);
    }

    /**
     * Converts Long to String.
     * @param value The Integer to be converted.
     * @return The converted String value.
     */
    public static String longToString(Long value) {
        return value.toString();
    }

    /**
     * Converts String to Long.
     * @param value The String to be converted.
     * @return The converted Long value.
     */
    public static Long stringToLong(String value) {
    	if (value.equals("")){
    		return null;
    	}else{
    		return Long.valueOf(value);
    	}
    }
    
    /**
     * Converts BigDecimal to String.
     * @param value The Integer to be converted.
     * @return The converted String value.
     */
    public static String bigDecimalToString(BigDecimal value) {
        return value.toString();
    }
    
    /**
     * Converts BigDecimal to String.
     * @param value The Integer to be converted.
     * @param numDecimales Number of decimals
     * @return The converted String value.
     */
    public static String bigDecimalToString(BigDecimal number, int numDecimales) {
		return ObjectConversionManager.bigDecimalToString(number, numDecimales, LocaleContextHolder.getLocale());
	}
    
    /**
     * Converts BigDecimal to String.
     * @param value The Integer to be converted.
     * @param numDecimales Number of decimals
     * @param locale Locale to use in the conversion.
     * @return The converted String value.
     */
    public static String bigDecimalToString(BigDecimal number, int numDecimales, Locale locale) {
		String res = "";
		try {
			if (number != null) {
				DecimalFormat df = new DecimalFormat("#,##0.00", new DecimalFormatSymbols(locale));
				df.setMinimumFractionDigits(numDecimales);
				df.setMaximumFractionDigits(numDecimales);
				res = df.format(number);
			}
		} catch (IllegalArgumentException e) {
			res = "";
		}
		return res;
	}
    
    
    public static BigDecimal stringToBigDecimal(String strNumber, Locale locale) {
		BigDecimal res = null;
		try {
			if (strNumber != null) {
				DecimalFormat df = new DecimalFormat("#,##0.00", new DecimalFormatSymbols(locale));
				df.setParseBigDecimal(true);
				res = new BigDecimal(df.parse(strNumber).toString());
			}
		} catch (IllegalArgumentException e) {
			res = null;
		} catch (ParseException e) {
			res = null;
		}
		return res;
	}
    
   
    /**
     * Converts String to BigDecimal.
     * @param value The String to be converted.
     * @return The converted Long value.
     */
    public static BigDecimal stringToBigDecimal(String value) {
    	if (value.equals("")){
    		return null;
    	}else{
    		return BigDecimal.valueOf(Long.valueOf(value).longValue());
    	}        
    }
    
    // You can implement more converter methods here.

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/StackTraceManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.io.PrintWriter;
import java.io.StringWriter;

/**
 * 
 * @author UDA
 *
 */
public class StackTraceManager {

	public static String getStackTrace(Throwable t)
    {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw, true);
        t.printStackTrace(pw);
        pw.flush();
        sw.flush();
        return sw.toString();
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/StaticsContainer.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

/**
 * 
 * @author UDA
 *
 */
public class StaticsContainer {

	public static String webAppName;
	public static String webId;
	public static String staticsUrl;
	public static String modelPackageName;
	public static String loginUrl;
	public static boolean aplicInPortal;
	public static String weblogicInstance;
	public static String layout;
	public static String language;
	public static boolean cookiePathRoot;
	public static boolean cookieSecure;
	public static boolean inheritableLocalContext;
	public static boolean xhrRedirectOnError;
	public static String xhrUnauthorizedPage;

	public static String getWebAppName() {
		return webAppName;
	}

	public static void setWebAppName(String webAppName) {
		StaticsContainer.webAppName = webAppName;
	}

	public static String getWebId() {
		return webId;
	}

	public static void setWebId(String webId) {
		StaticsContainer.webId = webId;
	}

	public static String getStaticsUrl() {
		return staticsUrl;
	}

	public static void setStaticsUrl(String staticsUrl) {
		StaticsContainer.staticsUrl = staticsUrl;
	}

	public static String getModelPackageName() {
		return modelPackageName;
	}

	public static void setModelPackageName(String modelPackageName) {
		StaticsContainer.modelPackageName = modelPackageName;
	}

	public static String getLoginUrl() {
		return loginUrl;
	}

	public static void setLoginUrl(String loginUrl) {
		StaticsContainer.loginUrl = loginUrl;
	}

	public static boolean isAplicInPortal() {
		return aplicInPortal;
	}

	public static void setAplicInPortal(boolean aplicInPortal) {
		StaticsContainer.aplicInPortal = aplicInPortal;
	}

	public static String getWeblogicInstance() {
		return weblogicInstance;
	}

	public static void setWeblogicInstance(String weblogicInstance) {
		StaticsContainer.weblogicInstance = weblogicInstance;
	}

	public static String getLayout() {
		return layout;
	}

	public static void setLayout(String layout) {
		StaticsContainer.layout = layout;
	}

	public static String getLanguage() {
		return language;
	}

	public static void setLanguage(String language) {
		StaticsContainer.language = language;
	}

	public static boolean isCookiePathRoot() {
		return cookiePathRoot;
	}

	public static void setCookiePathRoot(boolean cookiePathRoot) {
		StaticsContainer.cookiePathRoot = cookiePathRoot;
	}

	public static boolean isCookieSecure() {
		return cookieSecure;
	}

	public static void setCookieSecure(boolean cookieSecure) {
		StaticsContainer.cookieSecure = cookieSecure;
	}

	public static boolean isInheritableLocalContext() {
		return inheritableLocalContext;
	}

	public static void setInheritableLocalContext(boolean inheritableLocalContext) {
		StaticsContainer.inheritableLocalContext = inheritableLocalContext;
	}

	public static boolean isXhrRedirectOnError() {
		return xhrRedirectOnError;
	}

	public static void setXhrRedirectOnError(boolean xhrRedirectOnError) {
		StaticsContainer.xhrRedirectOnError = xhrRedirectOnError;
	}

	public static String getXhrUnauthorizedPage() {
		return xhrUnauthorizedPage;
	}

	public static void setXhrUnauthorizedPage(String xhrUnauthorizedPage) {
		StaticsContainer.xhrUnauthorizedPage = xhrUnauthorizedPage;
	}

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/TableManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.util.Hashtable;

import com.ejie.x38.log.LogConstants;

/**
 * 
 * @author UDA
 *
 */
public class TableManager {

	public static Hashtable<String, String> initTable (){
		Hashtable<String, String> table = new Hashtable<String, String>(11);
		for(String param:LogConstants.parameters){
			table.put(param, "");
		}
		return table;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/ThreadStorageManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.util.concurrent.atomic.AtomicLong;


/**
 * 
 * Almacena datos en un espacio de memoria independiente por cada hilo.
 * 
 * @author UDA
 * 
 */
public class ThreadStorageManager {
	
	//-9223372036854775808
	//9223372036854775807
	private static final AtomicLong uniqueId = new AtomicLong(0);
	
    private static ThreadLocal < Long > uniqueNum = 
        new ThreadLocal < Long > () {
            @Override protected Long initialValue() {
                return uniqueId.getAndIncrement();
        }
    };

    /**
     * Asigna un valor predefinido al Thread Local.
     * 
     * @param uniqueIdentificator
     */
    public static void setCurrentThreadId(Long uniqueIdentificator){
    	uniqueId.lazySet(uniqueIdentificator);
    }
    
    /**
     * Devuelve el valor almacenado por cada hilo. Si dicho valor no se ha inicializado, lo inicializa.
     * 
     * @return valor que se almacenapor cada hilo
     */
    public static long getCurrentThreadId() {
        return uniqueNum.get();
    }
    
    /**
     * Borra el espacio de memoria asociado al hilo.
     */
    public static void clearCurrentThreadId(){
    	uniqueNum.remove();
    }
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/UdaMultipartResolver.java
================================================
package com.ejie.x38.util;

import javax.servlet.http.HttpServletRequest;

import org.springframework.web.multipart.commons.CommonsMultipartResolver;

/**
 * Proporciona el soporte de peticiones multipart/ mediante metodo http PUT.
 * Este cambio viene dado por la modificacion realizada en la clase
 * RequestParamMethodArgumentResolver en la versión 3.1.1 de Spring, en la que
 * se elimina la limitación de que las peticiones multipart/ deban de ser
 * realizadas mediante POST.
 * 
 * @author UDA
 * 
 */
public class UdaMultipartResolver extends CommonsMultipartResolver {

	/*
	 * (non-Javadoc)
	 * @see org.springframework.web.multipart.commons.CommonsMultipartResolver#isMultipart(javax.servlet.http.HttpServletRequest)
	 */
	@Override
	public boolean isMultipart(HttpServletRequest request) {
		return (request != null && isMultipartContent(request));
	}

	/**
	 * Determina si la petición es multipart.
	 * 
	 * @param request
	 *            HttpServletRequest.
	 * @return Devuelve true/false dependiendo de si la petición es multipart.
	 */
	private boolean isMultipartContent(HttpServletRequest request) {
		String contentType = request.getContentType();
		return (contentType != null && contentType.toLowerCase().startsWith(
				"multipart/"));
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/WebContextParameterManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.io.InputStream;
import java.util.Properties;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.web.context.WebApplicationContext;

/**
 * 
 * @author UDA
 *
 */
public class WebContextParameterManager implements ApplicationContextAware {

	private static Logger logger = LoggerFactory.getLogger("com.ejie.x38.util.WebContextParameterManager");

	@Autowired
	private WebApplicationContext webApplicationContext;

	@PostConstruct
	public void init() {
		Properties appProperties = new Properties();
		logger.info("Loads the application context parameters");

		StaticsContainer.setWebAppName(webApplicationContext.getServletContext().getInitParameter("webAppName"));
		logger.info("The applications name is: " + StaticsContainer.getWebAppName());

		StaticsContainer.setWebId(webApplicationContext.getId());
		logger.info("The applications Id is: " + StaticsContainer.getWebId());

		try {
			logger.debug("Loading properties from: " + StaticsContainer.getWebAppName() + "/"
					+ StaticsContainer.getWebAppName() + ".properties");
			InputStream propertiesStream = this.getClass().getClassLoader().getResourceAsStream(
					StaticsContainer.getWebAppName() + "/" + StaticsContainer.getWebAppName() + ".properties");
			appProperties.load(propertiesStream);
			propertiesStream.close();
		} catch (Exception e) {
			logger.error(StackTraceManager.getStackTrace(e));
		}

		StaticsContainer.setStaticsUrl(appProperties.getProperty("statics.path"));
		logger.info("WARs specific Static Content URL is: " + StaticsContainer.getStaticsUrl());

		StaticsContainer.setModelPackageName("com.ejie." + StaticsContainer.getWebAppName() + ".model.");
		logger.info("Applications Model Package is: " + StaticsContainer.getModelPackageName() + ".model.");

		StaticsContainer.setLoginUrl(appProperties.getProperty("xlnets.path"));
		logger.info("The URL to access the security provider of the application (\"XLNets\") is: "
				+ StaticsContainer.getLoginUrl());

		if (appProperties.getProperty("xlnets.inPortal") != null
				&& ((appProperties.getProperty("xlnets.inPortal")).toLowerCase()).equals("true")) {
			StaticsContainer.setAplicInPortal(true);
			logger.info(
					"The application " + StaticsContainer.getWebAppName() + " is integrated in the portals of lote3");
		} else {
			StaticsContainer.setAplicInPortal(false);
			logger.info("The application " + StaticsContainer.getWebAppName()
					+ " isn't integrated in the portals of lote3");
		}

		if (StaticsContainer.getLoginUrl() == null) {
			logger.error("Login URL is not Set!");
		}

		StaticsContainer.setWeblogicInstance(System.getProperty("weblogic.Name"));
		logger.info("The WebLogic Instance Name is: " + StaticsContainer.getWeblogicInstance());

		if (appProperties.getProperty("cookie.rootPath") != null
				&& ((appProperties.getProperty("cookie.rootPath")).toLowerCase()).equals("true")) {
			StaticsContainer.setCookiePathRoot(true);
			logger.info("The cookie path is " + StaticsContainer.isCookiePathRoot());
		}

		if (appProperties.getProperty("cookie.secure") != null
				&& ((appProperties.getProperty("cookie.secure")).toLowerCase()).equals("true")) {
			StaticsContainer.setCookieSecure(true);
			logger.info("The cookie secure value is " + StaticsContainer.isCookieSecure());
		}

		if (appProperties.getProperty("locale.allowInheritance") != null
				&& ((appProperties.getProperty("locale.allowInheritance")).toLowerCase()).equals("true")) {
			StaticsContainer.setInheritableLocalContext(true);
			logger.info("The local context inheritance value is " + StaticsContainer.isInheritableLocalContext());
		}

		if (appProperties.getProperty("xhr.redirectOnError") != null
				&& ((appProperties.getProperty("xhr.redirectOnError")).toLowerCase()).equals("true")) {
			StaticsContainer.setXhrRedirectOnError(true);
		}

		if (appProperties.getProperty("xhr.unauthorizedPage") != null) {
			StaticsContainer.setXhrUnauthorizedPage(appProperties.getProperty("xhr.unauthorizedPage"));
		}
	}

	// Getters & Setters
	public WebApplicationContext getWebApplicationContext() {
		return webApplicationContext;
	}

	public void setApplicationContext(ApplicationContext context) throws BeansException {
		webApplicationContext = (WebApplicationContext) context;
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/WrappedRequest.java
================================================
/*
* Copyright 2022 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* https://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.util.Collections;
import java.util.Enumeration;
import java.util.Map;
import java.util.TreeMap;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;

public class WrappedRequest extends HttpServletRequestWrapper {
	private final String requestMethod;
	private final Map<String, String[]> modifiableParameters;
	private Map<String, String[]> allParameters = null;

	/**
	 * Crea una envoltura sobre la petición que permite incluir parámetros
	 * adicionales en el objeto de petición. No lee prematuramente los parámetros de
	 * la petición original.
	 * 
	 * @param request          Petición original.
	 * @param additionalParams Parámetros adicionales a ingresar en la petición.
	 */
	public WrappedRequest(final HttpServletRequest request, final Map<String, String[]> additionalParams) {
		super(request);
		modifiableParameters = new TreeMap<String, String[]>();
		modifiableParameters.putAll(additionalParams);
		requestMethod = ((HttpServletRequest) super.getRequest()).getMethod();
	}

	/**
	 * Crea una envoltura sobre la petición que permite incluir parámetros
	 * adicionales en el objeto de petición además de modificar el método. No lee
	 * prematuramente los parámetros de la petición original.
	 * 
	 * @param request          Petición original.
	 * @param additionalParams Parámetros adicionales a ingresar en la petición.
	 * @param method           Método a definir en la petición.
	 */
	public WrappedRequest(final HttpServletRequest request, final Map<String, String[]> additionalParams, final String method) {
		super(request);
		modifiableParameters = new TreeMap<String, String[]>();
		modifiableParameters.putAll(additionalParams);
		requestMethod = method;
	}

	@Override
	public String getParameter(final String name) {
		String[] strings = getParameterMap().get(name);
		if (strings != null) {
			return strings[0];
		}
		return super.getParameter(name);
	}

	@Override
	@SuppressWarnings("unchecked")
	public Map<String, String[]> getParameterMap() {
		if (allParameters == null) {
			allParameters = new TreeMap<String, String[]>();
			allParameters.putAll(super.getParameterMap());
			allParameters.putAll(modifiableParameters);
		}
		// Devuelve una colección no modificable porque se debe mantener el contrato.
		return Collections.unmodifiableMap(allParameters);
	}

	@Override
	public Enumeration<String> getParameterNames() {
		return Collections.enumeration(getParameterMap().keySet());
	}

	@Override
	public String[] getParameterValues(final String name) {
		return getParameterMap().get(name);
	}

	@Override
	public String getMethod() {
		return requestMethod;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/util/XmlManager.java
================================================
/*
* Copyright 2011 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.util;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.w3c.dom.DOMException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * 
 * @author UDA
 *
 */
public class XmlManager {
	
	private static final Logger logger =  LoggerFactory.getLogger(XmlManager.class);
	
	private static final XPath xPath = XPathFactory.newInstance().newXPath();
	
	/**
	 * Funcion que devuelve un Nodo dado un XPath.
	 * 
	 * @param Node XML
	 * @param Path XPath
	 * @return Node Nodo seleccionado con el Path
	 * @throws TransformerException 
	 */
	public static Node searchDomNode(Node docDom, String strPath) throws TransformerException {
		if (docDom != null && docDom.getTextContent()!=null){
			logger.debug("Searching node "+ "["+strPath+"] in document " + docDom.getTextContent());
		}else{ 
			logger.debug("Can't find node "+ "["+strPath+"] in empty document");
		}
			
		try {
			return (Node)xPath.evaluate(strPath, docDom, XPathConstants.NODE);
		} catch (XPathExpressionException e) {
			throw new TransformerException(e);
		} catch (DOMException e) {
			throw new TransformerException(e);
		}
	}	

	/**
	 * Funcion que devuelve un Vector de Strings dado un XPath.
	 * 
	 * @param Node XML
	 * @param Path XPath
	 * @return Vector vector de valores seleccionados con el Path
	 * @throws TransformerException 
	 * @throws SecurityException Excepción de seguridad
	 */
	public static Vector<String> searchDomVector(Node docDom, String strPath) throws TransformerException {
		NodeList nodeLiResultado;
		Vector<String> vecValores = null ;
		
		try {
			nodeLiResultado = (NodeList)xPath.evaluate(strPath, docDom, XPathConstants.NODESET);
		} catch (XPathExpressionException e) {
			throw new TransformerException(e);
		}
		
		if (nodeLiResultado.getLength() != 0) {
			int x = 0;
			vecValores = new Vector<String>();
			for (x = 0; x < nodeLiResultado.getLength(); x++) {
				if (nodeLiResultado.item(x).hasChildNodes()) {
					//arrayValores.add(NodeLiResultado.item(x).getFirstChild().getNodeValue());
					vecValores.add(nodeLiResultado.item(x).getFirstChild().getNodeValue());
				} else {
					vecValores.add("");
				}
			}
		} else {
			vecValores = new Vector<String>();
		}
		return vecValores;
		
	}	

}

================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/validation/ValidationController.java
================================================
package com.ejie.x38.validation;

import java.io.IOException;
import java.util.Locale;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.ejie.x38.util.DateTimeManager;
import com.ejie.x38.validation.ValidationManager;

@Controller
@RequestMapping (value = "/validate")
public class ValidationController {
	
	@Autowired
	private ValidationManager validationManager;
	
	@RequestMapping(method = RequestMethod.POST)
	public @ResponseBody Object validate(@RequestParam(value="bean",required=false) String bean, 
			@RequestParam(value="property",required=false) String property, 
			@RequestParam(value="value",required=false) String value, 
			HttpServletRequest request, HttpServletResponse response){
		

		Locale locale = LocaleContextHolder.getLocale();
		
		try {
			String result = validationManager.validateProperty(bean, property, value, locale);
			
			response.setContentType("text/javascript;charset=UTF-8");
			response.setHeader("Cache-Control", "no-cache");
			response.setHeader("Expires", DateTimeManager.getHttpExpiredDate());
			
			if (result == null){
	            response.setStatus(HttpServletResponse.SC_OK);		
			}else if (result!=null && !result.equals("error!")){
				response.setStatus(HttpServletResponse.SC_NOT_ACCEPTABLE);
				response.getWriter().write(result);
			}else{
				throw new RuntimeException("error!");
			}
		} catch (Exception e) {
            response.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
            try {
				response.getWriter().write("Error in the validate. The structure or morphology of the data is incorrect, review the data sent.");
			} catch (IOException e1) {
				e1.printStackTrace();
			}
		}
		return null;
		
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses/src/main/java/com/ejie/x38/validation/ValidationManager.java
================================================
/*
* Copyright 2012 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package com.ejie.x38.validation;

import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

import javax.annotation.PostConstruct;
import javax.annotation.Resource;
import javax.validation.ConstraintViolation;
import javax.validation.Path;
import javax.validation.Path.Node;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;
import javax.validation.groups.Default;

import org.hibernate.validator.HibernateValidator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanWrapper;
import org.springframework.beans.BeanWrapperImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.NoSuchMessageException;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.util.StringUtils;
import org.springframework.validation.Errors;
import org.springframework.validation.FieldError;
import org.springframework.validation.ObjectError;

import com.ejie.x38.json.JSONObject;
import com.ejie.x38.util.StackTraceManager;
import com.ejie.x38.util.StaticsContainer;
import com.ejie.x38.util.WebContextParameterManager;
import com.fasterxml.jackson.core.JsonGenerator;
import com.fasterxml.jackson.databind.MappingJsonFactory;
import com.fasterxml.jackson.databind.ObjectMapper;

/**
 * Proporciona el API de validación de UDA. 
 * 
 * @author UDA
 *
 */
public class ValidationManager {

	private static final long serialVersionUID = 1L;
	
	private final static Logger logger =  LoggerFactory.getLogger(ValidationManager.class);
	
	@Autowired
	WebContextParameterManager webContextParameterManager;
	
	@Resource
	private ReloadableResourceBundleMessageSource messageSource;

	@Autowired(required=false)
	private Validator validator;
	
	@PostConstruct
	public void init() {
		if (this.validator==null){
			ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator.class).configure().buildValidatorFactory();
			this.validator = validatorFactory.getValidator();
		}
	}

	/**
	 * Realiza la validación de la instancia indicada como parámetro. Las
	 * validaciones se realizan a partir de las anotaciones realizadas sobre las
	 * propiedades del bean. Los errores se añaden al objeto errors indicado
	 * como parámetro.
	 * 
	 * @param errors
	 *            Parámetro sobre el que se van a añadir los errores de
	 *            validación que se produzcan.
	 * @param obj
	 *            Intancia del objeto que se desea validar.
	 * @param groups
	 *            Grupos de validacion que se van a utilizar para realizar la
	 *            validación. En caso de no especificarse ninguno se tomará del
	 *            grupo Default.class como grupo por defecto.
	 */
	public void validate(Errors errors, Object obj, Class<?>... groups) {
		// En caso de no especificarse grupos de validaciones se toma el grupo Default por defecto.
		if (groups == null || groups.length == 0 || groups[0] == null) {
			groups = new Class<?>[] { Default.class };
		}
		
		// Se realiza la validacion de la instancia
		Set<ConstraintViolation<Object>> violations = validator.validate(obj, groups);
	    
		// A partir de las violaciones obtenidas a partir de la validacion
		// realizada, se añaden en la propiedad Errors
		for (ConstraintViolation<Object> v : violations) {
			Path path = v.getPropertyPath();
			String propertyName = "";
			if (path != null) {
				for (Node n : path) {
					propertyName += n.getName() + ".";
				}
				propertyName = propertyName.substring(0,
						propertyName.length() - 1);
			}
			String constraintName = v.getConstraintDescriptor().getAnnotation()
					.annotationType().getSimpleName();
			if (propertyName == null || "".equals(propertyName) || "null".equals(propertyName)) {
				errors.reject(constraintName, v.getMessage());
			} else {
				errors.rejectValue(propertyName, constraintName, v.getMessage());
			}
		}
	}


	/**
	 * Método que permite realizar la validación de
	 * una propiedad del bean.
	 * 
	 * @param bean
	 *            Nombre del tipo del bean sobre el que se deben de validar los
	 *            datos.
	 * @param property
	 *            Nombre de la propiedad del bean que se debe de validar.
	 * @param value
	 *            Valor de la propiedad que se debe de validar.
	 * @param locale
	 *            Locale actual que define el idioma a utilizar en la
	 *            internacionalización de los mensajes.
	 * @return Texto de error que contiene los mensajes de error resultantes de la validación.
	 */
	public String validateProperty(String bean, String property, String value, Locale locale){
		try{
			
			String capitalicedBean = StringUtils.capitalize(bean);
	
			BeanWrapper beanWrapper = new BeanWrapperImpl(Class.forName(StaticsContainer.modelPackageName+capitalicedBean));
			beanWrapper.setAutoGrowNestedPaths(true);
			beanWrapper.setPropertyValue(property, value);
			
			Set<ConstraintViolation<Object>> constraintViolations = validator.validateProperty(beanWrapper.getWrappedInstance(), property, Default.class);			
			return summary(constraintViolations, bean, locale);
		}catch (Exception e) {
			logger.error(StackTraceManager.getStackTrace(e));
			return "error!";
		}
	}
	
	
	/**
	 * Genera, a partir de unos errores indicados como parámetros, un mapa en el
	 * cual cada elemento está formado del siguiente modo:<br>
	 * <br>
	 * - El key del elemento del mapa está formado por el nombre de la propiedad
	 * sobre la que se ha producido el error de la validación o por el
	 * identificador que se ha asignado a la validación.<br>
	 * <br>
	 * - El objeto asociado al key está formado por una lista de mensajes de
	 * error internacionalizados a partir del key de error.
	 * 
	 * @param errors
	 *            Conjunto de errores que se desean procesar.
	 * @return Mapa resultante que contiene los errores procesados.
	 */
	public Map<String,List<String>> getErrorsAsMap(Errors errors){
		// Se obtiene la locale actual que va a ser utilizada para realizar la
		// internacionalización de los mensajes de error.
		Locale locale = LocaleContextHolder.getLocale();
		// Mapa en el que se van a almacenar los errores 
		Map<String,List<String>> errorsMap = new HashMap<String, List<String>>();
		// Lista de errores que se han producido al realizarse el databinding
		List<? extends ObjectError> fieldErrors = errors.getAllErrors();
		// Se recorre cada error
		for (Iterator<? extends ObjectError> iterator = fieldErrors.iterator(); iterator.hasNext();) {
		
			ObjectError objectError = (ObjectError) iterator.next();
			String errorMessage;
			String key;
			
			// Se comprueba si el error está asociado a la validación de una
			// propiedad de un bean
			if (objectError instanceof FieldError){
				FieldError fieldError = (FieldError)objectError;
				// En caso de que se trate de un FieldError se toma el nombre
				// del campo como el key que se utilizará en el elemento del
				// mapa.
				key = fieldError.getField();
				// Se trata de obtener el mensaje internacionalizado a partir del key del error.
				try{
					// En caso de existir se toma el mensaje internacionalizado como el texto de error a mostrar.
					errorMessage = messageSource.getMessage(fieldError.getDefaultMessage(), null, locale);
				}catch (NoSuchMessageException e) {
					// En caso de producirse un error en la obtención del texto se toma el key como texto a mostrar.
					errorMessage = fieldError.getCode();
				}
			}else{
				// En caso de que se trate de un FieldError se toma el code
				// del error como el key que se utilizará en el elemento del
				// mapa.
				key = objectError.getCode();
				// Se trata de obtener el mensaje internacionalizado a partir del key del error.
				try{
					// En caso de existir se toma el mensaje internacionalizado como el texto de error a mostrar.
					errorMessage = messageSource.getMessage(objectError.getDefaultMessage(), null, locale);
				}catch (NoSuchMessageException e) {
					// En caso de producirse un error en la obtención del texto se toma el key como texto a mostrar.
					errorMessage = objectError.getDefaultMessage();
				}
			}
			
			// Se comprrueba si error se ha insertado y a en el mapa
			if(errorsMap.containsKey(key)){
				// En caso de existir se añade el mensaje de error en la lista de errores.
				errorsMap.get(key).add(errorMessage);
			}else{
				// En caso de no existir se genera un nuevo elemento en el mapa
				// con una lista de errores en la cual se añade el mensaje de
				// error.
				List<String> listaErrores = new ArrayList<String>();
				listaErrores.add(errorMessage);
				errorsMap.put(key,listaErrores);
			}
		}
		// Se devuelve el mapa de errores
		return errorsMap;
	}
	
	/**
	 * Genera, a partir de unos errores indicados como parámetros, una lista
	 * formada por los mensajes de error internacionalizados.
	 * 
	 * @param errors
	 *            Conjunto de errores que se desean procesar.
	 * @return Lista resultanete que contiene los mensajes de error procesados.
	 */
	public List<String> getErrorsAsList(Errors errors){
		// Se obtiene la locale actual que va a ser utilizada para realizar la
		// internacionalización de los mensajes de error.
		Locale locale = LocaleContextHolder.getLocale();
		// Mapa en el que se van a almacenar los errores 
		List<String> list = new ArrayList<String>();
		// Lista de errores que se han producido al realizarse el databinding
		List<FieldError> fieldErrors = errors.getFieldErrors();
		
		// Se recorre cada error
		for (Iterator<FieldError> iterator = fieldErrors.iterator(); iterator.hasNext();) {
		
			FieldError fieldError = (FieldError) iterator.next();
			String errorMessage;
			
			try{
				errorMessage = messageSource.getMessage(fieldError.getCode(), null, locale);
			}catch (NoSuchMessageException e) {
				errorMessage = fieldError.getCode();
			}

			list.add(errorMessage);
			
		}
		
		return list;
	}

	/**
	 * Genera a partir de un mensaje y un estilo, una estructura para devolver
	 * una estructura que pueda ser convertida a formato JSON e interpretada por
	 * el feedback.
	 * 
	 * @param msg
	 *            Mensaje que debe ser visualizado por el feedback.
	 * @param style
	 *            Estilo que se debe mostrar con el feedback.
	 * @return Estrutura que contiene el mensaje y el estilo que se debe de
	 *         visualizar en el feedback.
	 */
	public Map<String,Object> getRupFeedbackMsg(String msg, String style){
		Map<String,Object> map = new HashMap<String, Object>();
		map.put("label", msg);
		if (style!=null && !"".equals(style)){
			map.put("style", style);
		}
		return map;
	}
	
	
	/*
	 * Metodos de validaciones
	 */
	public JSONObject getMessageJSON(Object fieldErrors){
		return this.getMessageJSON(fieldErrors, null, null);
	}
	public JSONObject getMessageJSON(Object fieldErrors, Object feedbackMessage){
		return this.getMessageJSON(fieldErrors, feedbackMessage, null);
	}
	public JSONObject getMessageJSON(Object fieldErrors, Object feedbackMessage, String style){
		
		JSONObject message = new JSONObject();
		
		if (feedbackMessage!=null ){
			
			JSONObject feedbackObj = new JSONObject();
			feedbackObj.put("message", feedbackMessage);
			
			if (style!=null && !"".equals(style)){
				feedbackObj.put("style", style);
			}
			message.put("rupFeedback", feedbackObj);
		}
		
		if (fieldErrors!=null){
			message.put("rupErrorFields", fieldErrors);
		}
		
		return message;
	}
	
	
	// MÉTODOS PRIVADOS
	
	/**
	 * Genera una cadena de error en formato JSON a partir de los errores de
	 * validación que se han producido.
	 * 
	 * @param <T>
	 *            Tipo del objeto que se va a validar.
	 * @param constraintViolations
	 *            Errores de validación sobre los que se desea generar el
	 *            mensaje.
	 * @param bean
	 *            Nombre del tipo de bean sobre el que se ha realizado la
	 *            validación.
	 * @param locale
	 *            Locale actual que define el idioma a utilizar en la
	 *            internacionalización de los mensajes.
	 * @return Cadena de error resultante.
	 */
	private <T extends Object> String summary (Set<ConstraintViolation<T>> constraintViolations, String bean, Locale locale){
		Iterator<ConstraintViolation<T>> ite = constraintViolations.iterator();
		Map<String,List<Map<String,String>>> errors = new HashMap<String,List<Map<String,String>>>();
		String propertyKey ="";
		List<Map<String,String>> propertyErrors;
		while (ite.hasNext()) {
			ConstraintViolation<T> constraintViolation = ite.next();
			propertyKey = constraintViolation.getPropertyPath()+"";
			if(errors.containsKey(propertyKey)){
				propertyErrors = errors.get(propertyKey);				
			}else{
				propertyErrors = new ArrayList<Map<String,String>>();
			}
			Map<String,String> node = new HashMap<String,String>();
			String interpolatedMessage;
			//Try to get the interpolated Message in this order: 1- War, 2- EAR, 3- Hibernate's Default 
			try{
				interpolatedMessage = messageSource.getMessage(constraintViolation.getMessage(), null, locale);
			}catch(NoSuchMessageException e){
				interpolatedMessage = constraintViolation.getMessage();
			}			
			if(interpolatedMessage!= null && !interpolatedMessage.equals("")){
				node.put(constraintViolation.getConstraintDescriptor().getAnnotation().annotationType().getSimpleName(), interpolatedMessage);
			}else{
				node.put(constraintViolation.getConstraintDescriptor().getAnnotation().annotationType().getSimpleName(), "message not found");
				logger.error("Validation message for key "+constraintViolation.getConstraintDescriptor().getAnnotation().annotationType().getSimpleName()+" not found");
			}
			
			propertyErrors.add(node);
			errors.put(propertyKey, propertyErrors);
		}
		if (!errors.isEmpty()){				
			Map<String, String> title = new HashMap<String, String>();
			title.put("key", bean);
			String header = serialize(title);
			String body = serialize(errors);
			String[] result = {header, body};
			String summary = serialize(result);
			return summary;
		}else{
    		return null;		
		}
	}
	
	/**
	 * Metodo utilizado para realizar la serialización de un objeto en formato JSON.
	 * 
	 * @param obj Objeto a serializar.
	 * @return Serialización del objeto en formato JSON.
	 */
	private String serialize(Object obj) {
		StringWriter sw = new StringWriter();
		ObjectMapper mapper = new ObjectMapper();
		MappingJsonFactory jsonFactory = new MappingJsonFactory();
		try {
			JsonGenerator jsonGenerator = jsonFactory.createGenerator(sw);
			mapper.writeValue(jsonGenerator, obj);
			sw.close();

			return sw.getBuffer().toString();
		} catch (IOException e) {
			logger.error(StackTraceManager.getStackTrace(e));
			return "error!";
		}
	}
}

================================================
File: x38ShLibClasses/x38ShLibClasses/.settings/org.eclipse.core.resources.prefs
================================================
eclipse.preferences.version=1
encoding//src/main/java=UTF-8
encoding//src/main/resources=UTF-8
encoding/<project>=UTF-8
encoding/src=UTF-8


================================================
File: x38ShLibClasses/x38ShLibClasses/.settings/org.eclipse.jdt.core.prefs
================================================
eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
org.eclipse.jdt.core.compiler.codegen.targetPlatform=11
org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
org.eclipse.jdt.core.compiler.compliance=11
org.eclipse.jdt.core.compiler.debug.lineNumber=generate
org.eclipse.jdt.core.compiler.debug.localVariable=generate
org.eclipse.jdt.core.compiler.debug.sourceFile=generate
org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
org.eclipse.jdt.core.compiler.release=disabled
org.eclipse.jdt.core.compiler.source=11


================================================
File: x38ShLibClasses/x38ShLibClasses/.settings/org.eclipse.m2e.core.prefs
================================================
activeProfiles=
eclipse.preferences.version=1
resolveWorkspaceProjects=true
version=1


================================================
File: x38ShLibClasses/x38ShLibClasses/.settings/org.eclipse.wst.common.component
================================================
<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
                
    
    
    <wb-module deploy-name="x38ShLibClasses">
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/java"/>
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/resources"/>
                            
    
    
    </wb-module>
            


</project-modules>


================================================
File: x38ShLibClasses/x38ShLibClasses/.settings/org.eclipse.wst.common.project.facet.core.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <runtime name="Oracle WebLogic Server 14.1.1.0"/>
  <installed facet="jst.utility" version="1.0"/>
  <installed facet="java" version="11"/>
</faceted-project>


================================================
File: x38ShLibClasses/x38ShLibClasses/.settings/org.eclipse.wst.validation.prefs
================================================
disabled=06target
eclipse.preferences.version=1


================================================
File: x38ShLibClasses/x38ShLibClasses/.settings/org.hibernate.eclipse.console.prefs
================================================
default.configuration=x38ShLibClasses
eclipse.preferences.version=1
hibernate3.enabled=true


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/LICENSE.txt
================================================
                    Licencia Pública de la Unión Europea
                                 Versión 1.1
                        EUPL © Comunidad Europea 2007
                     http://ec.europa.eu/idabc/eupl.html


   La presente Licencia Pública de la Unión Europea («EUPL»), se aplica a la 
   obra o al programa de ordenador (definidos a continuación) suministrados en
   las condiciones fijadas en la presente licencia. Queda prohibido cualquier
   uso de la obra distinto del autorizado por la presente licencia (en la 
   medida en que tal uso esté protegido por un derecho del titular de los 
   derechos de autor de la obra). 
   
   La obra original se suministrará en las condiciones fijadas en la presente 
   licencia cuando el licenciante (definido a continuación) haya colocado la 
   siguiente advertencia inmediatamente después de la mención a los derechos 
   de autor de la obra original: 
   
   			Licencia cedida con arreglo a la EUPL V.1.1 
   
   o haya expresado por otro procedimiento su voluntad de conceder una 
   licencia con arreglo a la EUPL. 
   
   
   1. Definiciones 
      En la presente licencia, se entenderá por: 
      – licencia: la presente licencia. 
      – obra original o programa de ordenador: el programa de ordenador 
        distribuido o comunicado por el licenciante con arreglo a la presente 
        licencia en forma de código fuente o, en su caso, de código ejecutable;
      – obras derivadas: las obras o el programa de ordenador que pudiera crear
        el licenciatario sobre la base de la obra original o de alguna de las 
        modificaciones de ésta. La presente licencia no define el grado de 
        modificación o dependencia de la obra original necesario para 
        clasificar una obra como derivada; dicho grado se determinará de 
        acuerdo con la legislación sobre derechos de autor aplicable en el país
        contemplado en el artículo 15;
      – obra: la obra original o sus obras derivadas; 
      – código fuente: la forma de la obra legible por seres humanos que pueda 
        ser estudiada y modificada más fácilmente; 
      – código ejecutable: cualquier código, en general compilado, destinado a 
        ser ejecutado como programa por un ordenador; 
      – licenciante: la persona física o jurídica que distribuye o comunica la 
        obra con arreglo a la licencia; 
      – colaborador: la persona física o jurídica que modifica la obra con 
        arreglo a la licencia o contribuye de cualquier otra manera a crear una
        obra derivada; 
      – licenciatario: la persona física o jurídica que hace un uso cualquiera 
        del programa de ordenador en las condiciones fijadas en la licencia; 
      – distribución o comunicación: cualquier acto de venta, donación,
        préstamo, alquiler, distribución, comunicación, transmisión o cualquier
        otro acto de puesta a disposición, en línea o fuera de línea, de copias
        de la obra o de acceso a sus funcionalidades esenciales a otra persona 
        física o jurídica.
   
   2. Ámbito de los derechos otorgados por la Licencia 
      El licenciante concede al licenciatario una licencia de ámbito mundial, a
      título gratuito, no exclusiva y que el licenciatario puede subcontratar 
      mientras sigan vigentes los derechos de autor sobre la obra original, y 
      lo autoriza a: 
      
      – utilizar la obra en cualquier circunstancia y para cualquier uso; 
      – reproducir la obra; 
      – modificar la obra original y realizar obras derivadas de la misma; 
      – comunicar al público la obra o copias de la misma, poner a su 
        disposición o exhibir la obra o las copias y, en su caso, ejecutar 
        públicamente la Obra; 
      – distribuir la obra o copias de la misma; 
      – prestar y alquilar la obra o copias de la misma; 
      – subcontratar los derechos relativos a la obra o a las copias de la
        misma. 
      
      Dichos derechos se podrán ejercer a través de cualquier medio, soporte y 
      formato, conocido en el presente o que pueda inventarse en el futuro, en 
      la medida en que así lo permita la legislación aplicable. 
      
      En los países cuyo ordenamiento contemple los derechos morales, el 
      Licenciante renunciará al ejercicio de los mismos en la medida en que lo 
      permita la legislación, a fin de hacer efectiva la licencia de los 
      derechos patrimoniales anteriormente enumerados. 
      
      El licenciante cede al licenciatario, libre de cánones, los derechos de 
      uso no exclusivos sobre cualquier patente de que sea titular, en la 
      medida necesaria para que el licenciatario haga uso de los derechos sobre
      la obra otorgados por la presente licencia. 
   
   3. Comunicación del Código Fuente 
      El licenciante podrá suministrar la obra en forma de código fuente o 
      código ejecutable. Si la suministrara en forma de código ejecutable, 
      deberá facilitar además una copia legible automáticamente del código 
      fuente de la obra junto con cada copia de la obra que distribuya, o bien 
      indicar, en una advertencia inserta a continuación de la mención a los 
      derechos de autor adjunta a la obra, un repositorio en el que se pueda 
      acceder al código fuente fácilmente y de manera gratuita durante el 
      período en que el licenciante siga distribuyendo o comunicando la obra. 
   
   4. Limitaciones a los derechos de autor 
      En ningún caso podrá interpretarse la presente licencia de modo que prive
      al licenciatario de los beneficios de los que pudiera disfrutar como 
      consecuencia de las excepciones o limitaciones a los derechos exclusivos 
      de los titulares de los derechos de la obra original o del programa de 
      ordenador, de la extinción de dichos derechos o de cualquier otra 
      limitación aplicable. 
   
   5. Obligaciones del licenciatario 
      La cesión de los derechos en virtud de la presente licencia queda 
      supeditada a ciertas restricciones u obligaciones que habrá de respetar 
      el licenciatario. Dichas obligaciones son: 
      
      Derecho de atribución: El licenciatario deberá mantener íntegramente 
      todas las advertencias y menciones a los derechos de autor, patentes o 
      marcas registradas, así como las que se refieran a la licencia y a la 
      exención de responsabilidad. El licenciatario deberá adjuntar copias de 
      dichas advertencias y menciones y de la Licencia con cada copia de la 
      obra que distribuya o comunique. El licenciatario se responsabilizará de 
      que sus modificaciones u obras derivadas incluyan una advertencia bien 
      destacada declarando que ha modificado la obra, y la fecha de 
      modificación.
      
      Cláusula de «izquierdo de copia» (copyleft): Si el licenciatario 
      distribuyera o comunicara copias de la obra original o de obras derivadas
      basadas en la obra original, dicha distribución o comunicación deberá 
      hacerse en las condiciones fijadas en la presente licencia o de una 
      versión posterior de la presente licencia, salvo si la obra original se 
      distribuye expresamente solo en la presente versión de la licencia. El 
      licenciatario (ahora en su calidad de licenciante) no podrá ofrecer ni 
      imponer condiciones adicionales sobre la obra o las obras derivadas que 
      modifiquen o limiten las condiciones de la licencia. 
      
      Cláusula de compatibilidad: Si el licenciatario distribuyera o comunicara
      obras derivadas o copias de estas últimas basadas a su vez en la obra 
      original y en otra obra licenciada bajo una licencia compatible, la 
      distribución o comunicación podrán efectuarse con arreglo a las 
      condiciones de dicha licencia compatible. A efectos de la presente 
      cláusula, se entenderá por «licencia compatible» cualquiera de las 
      licencias enumeradas en el apéndice adjunto a la presente licencia. En 
      caso de que las obligaciones del licenciatario con arreglo a la licencia 
      compatible estén en colisión con las derivadas de la presente licencia, 
      prevalecerán las obligaciones de la licencia compatible. 
      
      Suministro del código fuente: Cuando distribuya o comunique copias de la 
      obra, el licenciatario deberá facilitar una copia del código fuente 
      legible automáticamente o indicar un repositorio en que se pueda acceder 
      al código fuente fácilmente y de manera gratuita durante el período en 
      que siga distribuyendo o comunicando la obra. 
      
      Salvaguardia de otros derechos: La presente licencia no faculta para 
      utilizar los nombres comerciales, marcas de producto o de servicio o 
      nombres del licenciante, excepto cuando ello, realizado en la medida de 
      lo razonable y conforme a los usos habituales, sea necesario para indicar
      el origen de la obra y reproducir el contenido de la mención a los 
      derechos de autor. 
   
   6. Secuencia de autoría 
      El licenciante original garantiza ser titular originario de los derechos 
      de autor sobre la obra original objeto de la presente licencia o haberlos
      adquirido mediante la licencia correspondiente y estar facultado para 
      otorgar licencias sobre tales derechos.
      
      Cada colaborador garantiza ser titular de los derechos de autor sobre las
      modificaciones que aporta a la obra o haberlos adquirido mediante la 
      correspondiente licencia y estar facultado para otorgar licencias sobre 
      tales derechos.
      
      Cada vez que el licenciatario acepta la licencia, el licenciante original
      y los colaboradores posteriores le otorgan una licencia sobre sus propias
      contribuciones a la obra en las condiciones fijadas en la presente
      licencia.
   
   7. Exclusión de garantía 
      La obra se encuentra en proceso de elaboración, siendo objeto de 
      continuas mejoras por parte de numerosos colaboradores. No es una obra 
      acabada y por tanto puede contener defectos o fallos inherentes al 
      desarrollo de este tipo de programas. 
      
      Por este motivo, la obra, en virtud de la licencia, se suministra «tal 
      cual», sin garantías de ningún tipo, en particular, en una enumeración no
      exhaustiva, en cuanto a su comercialización, adecuación a un propósito 
      determinado, ausencia de defectos 
      
      o errores, exactitud y ausencia de infracción de los derechos de 
      propiedad intelectual distintos de los derechos de autor según se afirma
      en el artículo 6 de la presente licencia. 
      Esta exclusión de garantía forma parte esencial de la licencia y es 
      condición para la cesión de cualquier derecho con respecto a la obra. 
   
   8. Exclusión de responsabilidad 
      Excepto en casos de dolo o de daños ocasionados directamente a personas 
      físicas, el licenciante no será responsable de los daños y perjuicios de 
      cualquier clase, directos o indirectos, materiales o morales, que 
      pudieran derivarse de la licencia o del uso de la obra, en particular, en
      una enumeración no exhaustiva, de los daños y perjuicios por pérdida de 
      buena reputación, paro técnico, avería o mal funcionamiento de equipos 
      informáticos, pérdida de datos o cualquier perjuicio comercial, incluso 
      si el licenciante conocía la posibilidad de dichos daños. No obstante, el
      licenciante será responsable, de acuerdo con las normas legales que 
      regulen la responsabilidad por los daños causados por productos, en la 
      medida en que dichas normas sean aplicables a la obra. 
   
   9. Acuerdos adicionales 
      Al distribuir la obra original o las obras derivadas, el licenciatario 
      podrá suscribir un acuerdo adicional, y cobrar una remuneración para 
      ofrecer asistencia y proporcionar garantías o asumir indemnizaciones u 
      otras obligaciones en materia de responsabilidad o proporcionar servicios
      compatibles con la presente licencia. No obstante, al aceptar tales 
      obligaciones, el licenciatario actuará únicamente en nombre propio y bajo
      su exclusiva responsabilidad, y nunca en nombre del licenciante original
      ni de ningún otro colaborador, y ello a condición de que acceda a 
      indemnizar, defender y amparar a todo colaborador frente a cualquier 
      responsabilidad en que éste pudiera incurrir y frente a las reclamaciones
      que pudieran presentarse contra él por haber aceptado el licenciatario la
      mencionada garantía o responsabilidad adicional.
   
   10. Aceptación de la licencia 
      Lo dispuesto en la presente licencia puede aceptarse haciendo clic en el 
      icono «Aceptar» situado en la parte inferior de la ventana en que aparece
      el texto de la presente licencia o manifestando el consentimiento de 
      cualquier otra forma similar, de conformidad con lo previsto en la 
      legislación aplicable. Haciendo clic en dicho icono, se expresa la 
      aceptación inequívoca e irrevocable de la presente licencia y de todo su 
      contenido. 
      
      Asimismo, el licenciatario acepta irrevocablemente la presente licencia y
      todas sus condiciones por el mero hecho de ejercer cualquiera de los 
      derechos que le otorga el artículo 2 de la presente licencia, tales como
      el uso de la obra, la creación de una obra derivada o la distribución o 
      comunicación de la obra o de copias de la misma. 
   
   11. Información al público 
      En caso de que el licenciatario proceda a la distribución o comunicación
      de la obra por medios electrónicos (por ejemplo, ofreciendo la descarga 
      de la obra a distancia), el canal o medio de distribución (por ejemplo, 
      un sitio web) deberá facilitar al público, como mínimo, la información 
      exigida por la legislación aplicable acerca del licenciante, la licencia 
      y la manera en que el licenciatario puede acceder a dichos datos, 
      aceptarlos, conservarlos y reproducirlos. 
   
   12. Extinción de la licencia 
      La licencia y los derechos otorgados a su amparo se extinguirán 
      automáticamente si el licenciatario incumple alguna de las condiciones de
      la licencia.
      
      Tal extinción no supondrá, sin embargo, la de las licencias de que 
      disfruten las personas que hayan recibido la obra del licenciatario en
      virtud de la licencia, siempre que dichas personas sigan cumpliendo 
      plenamente las condiciones de la licencia. 
   
   13. Varios 
      No obstante lo dispuesto en el artículo 9, la licencia representará la 
      totalidad del acuerdo entre las partes en cuanto a la obra objeto de la 
      misma. 
      
      La eventual invalidez o ineficacia de alguna disposición de la presente 
      licencia con arreglo a la legislación vigente no afectará a la validez o 
      eficacia general de la licencia. En tales casos, la disposición se 
      interpretará o reformulará según proceda para hacerla válida y eficaz. 
      
      La Comisión Europea podrá publicar otras versiones lingüísticas o nuevas 
      versiones de la presente licencia en la medida en que resulte necesario y
      razonable y sin reducir el ámbito de los derechos concedidos por la 
      licencia. Las nuevas versiones de la licencia se publicarán con un número
      de versión único. 
      
      Todas las versiones lingüísticas de la presente licencia aprobadas por la
      Comisión European tienen idéntico valor. Las partes pueden utilizar la
      versión lingüística de su preferencia. 
   
   14. Tribunales competentes 
      Los litigios relativos a la interpretación de la presente licencia que se
      planteen entre la Comisión Europea, en calidad de licenciante, y un 
      licenciatario, se someterán a la jurisdicción del Tribunal de Justicia de
      las Comunidades Europeas, con arreglo al artículo 238 del Tratado
      constitutivo de la Comunidad Europea. 
      
      Los litigios relativos la interpretación de la presente licencia que se
      planteen entre partes distintas de la Comisión Europea, se someterán a la
      jurisdicción exclusiva del tribunal que sea competente en el lugar en que
      resida o ejerza su actividad principal el licenciante. 
   
   15. Legislación aplicable 
      La presente Licencia se regirá por la legislación del país de la Unión 
      Europea en el que resida o tenga su domicilio social el licenciante. 
      
      La presente licencia se regirá por la legislación belga si: 
      
      – se planteara un litigio entre la Comisión Europea, en calidad de 
        licenciante, y un licenciatario; 
      – el licenciante, distinto de la Comisión Europea, no residiera o no 
        tuviera su domicilio social en un Estado miembro de la Unión Europea. 
   
   Apéndice 
   
   Son «licencias compatibles» con la EUPL con arreglo al artículo 5: 
   
   – GNU General Public License (GNU GPL) v. 2 
   – Open Software License (OSL) v. 2.1, v. 3.0 
   – Common Public License v. 1.0 
   – Eclipse Public License v. 1.0 
   – Cecill v. 2.0 
   


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/NOTICE.txt
================================================
NOTICE.txt - UDA copyright notices

UDA is Copyright 2011 by E.J.I.E., S.A.
	
	* The plug-in and RUP components are licensed under the EUPL, Version 1.1 only 
	(the "Licence");
	* Documentation is licensed under the Creative Commons Attribution-NonCommercial-
	ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) 
	
THIRD PARTY COMPONENTS

	The UDA plug-in includes software developed by:
	
		* Enterprise JavaBeans 3.0
			http://www.oracle.com/technetwork/java/javaee/ejb/index.html
			Sun Microsystems, Inc.
			License: COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0

		* Oracle JDBC Drivers 
			http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html
			Oracle Corporation
			License: OTN (http://www.oracle.com/technetwork/licenses/standard-license-152015.html)

		* The JBoss Community
			Hibernate Tools (http://www.hibernate.org/subprojects/tools.html)
			Copyright (c) 2010 JBoss by Red Hat and others.
			License: FSF Lesser Gnu Public License (LGPL v2.1) (http://www.hibernate.org/license)

		* Eclipse
			Eclipse Platform (http://www.eclipse.org/platform)
			Copyright (c) Eclipse contributors and others 2000, 2011.  All rights reserved.
			License: Eclipse Foundation Software User Agreement
						
		* Oracle Enterprise Pack for Eclipse (OEPE)
			http://www.oracle.com/technetwork/developer-tools/eclipse/overview/index.html
			Copyright © 2008, 2011, Oracle and/or its affiliates. All rights reserved.
			License: ORACLE ENTERPRISE PACK FOR ECLIPSE LICENSE AGREEMENT
						
		* PMD (http://pmd.sourceforge.net)
			PMD plugin For Eclipse
			Copyright (c) 1997-2009, PMD for Eclipse Development Team
			License: "BSD-style" license (http://pmd.sourceforge.net/license.html)									

		* Eclipse Checkstyle Plugin (http://eclipse-cs.sf.net/)
			Checkstyle integration plugin for Eclipse
			(c) Copyright David Schneider, Lars Koedderitzsch and others, 2002-2010
			License: GNU Lesser General Public License Version 2.1 
						
		* FindBugs (http://findbugs.sourceforge.net)
			FindBugs plugin for Eclipse
			(c) Trademark and Copyright 2003-2008 by the University of Maryland.
			License: GNU Lesser General Public License (LGPL) (http://findbugs.sourceforge.net/manual/license.html)
			
		* Eclipse Subversive - SVN Team Provider Project
			The Eclipse Team Provider for the Subversion version control system.
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement 
			
		* Polarion Subversive SVN Connectors (http://www.polarion.org and http://www.polarion.com)
			Set of the SVN connectors for the Eclipse Subversive - SVN Team Provider. 
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement
			
		* Resource Bundle Editor (http://sourceforge.net/projects/eclipse-rbe/)
			Essiembre ResourceBundle Editor
			Copyright (C) 2003, 2004  Pascal Essiembre, Essiembre Consultant Inc.
			License: GNU Lesser General Public License Version 2.1

		* FreeMarker IDE (http://www.jboss.org/tools)
			FreeMarkerIDE provides editor for FreeMarker templates
			Copyright (c) 2008-2011 Red Hat, Inc. and others.
			License: Eclipse Public License - v 1.0 (http://www.eclipse.org/legal/epl-v10.html)


			
	The RUP (Rich UDA Patterns) components includes software developed by:

		* The jQuery Project
			jQuery core (http://jquery.com/)
			Copyright 2011, John Resig
			License: Gnu Public License v2 (GPLv2), MIT license
			
		* The jQueryUI Team
			jQueryUI (http://jqueryui.com/)
			Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
			License: Gnu Public License v2 (GPLv2), MIT license

		* The jQuery Grid Plugin
			jQuery Grid Plugin (http://www.trirand.com/blog/)
			Copyright (c) 2007-2011 jQuery Grid Plugin 
			License: Gnu Public License v2 (GPLv2), MIT license

		* ajaxBlender.com
			xBreadcrumbs (Extended Breadcrums) jQuery Plugin (http://www.ajaxblender.com/xbreadcrumbs.html)
			Copyright 2009 ajaxBlender.com 
			
		* form2object			
			form2object (https://github.com/maxatwork/form2js)
			Copyright (c) 2010 Maxim Vasiliev
			License: (https://github.com/maxatwork/form2js/blob/master/license.txt)
			
			

================================================
File: x38ShLibClasses/x38ShLibClasses-dav/pom.xml
================================================
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<parent>
		<groupId>com.ejie.x38</groupId>
		<artifactId>x38</artifactId>
		<version>6.1.0-RELEASE</version>
	</parent>
	<modelVersion>4.0.0</modelVersion>
	<artifactId>x38ShLibClasses-dav</artifactId>
	<packaging>jar</packaging>
	<name>x38ShLibClasses-dav</name>
	<url>http://www.ejie.eus</url>
</project>


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.classpath
================================================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" output="target/classes" path="src/main/java">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="org.eclipse.jst.component.nondependency" value=""/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-11">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="output" path="target/classes"/>
</classpath>


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.gitignore
================================================
/target/
/bin/


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.project
================================================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>x38ShLibClasses-dav_v6</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.wst.common.project.facet.core.builder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.hibernate.eclipse.console.hibernateBuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.wst.validation.validationbuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.m2e.core.maven2Builder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jem.workbench.JavaEMFNature</nature>
		<nature>org.eclipse.wst.common.modulecore.ModuleCoreNature</nature>
		<nature>org.eclipse.jdt.core.javanature</nature>
		<nature>org.eclipse.m2e.core.maven2Nature</nature>
		<nature>org.hibernate.eclipse.console.hibernateNature</nature>
		<nature>org.eclipse.wst.common.project.facet.core.nature</nature>
	</natures>
</projectDescription>


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/META-INF/MANIFEST.MF
================================================
Manifest-Version: 1.0
Class-Path: 



================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/IMethodExecutor.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav;

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.exceptions.LockFailedException;

public interface IMethodExecutor {

    void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException;

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/IMimeTyper.java
================================================
package com.ejie.x38.webdav;

public interface IMimeTyper {

    String getMimeType(String path);
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/ITransaction.java
================================================
package com.ejie.x38.webdav;

import java.security.Principal;

public interface ITransaction {

    Principal getPrincipal();

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/IWebdavStore.java
================================================
/*
 * $Header: /Users/ak/temp/cvs2svn/webdav-servlet/src/main/java/net/sf/webdav/IWebdavStore.java,v 1.1 2008-08-05 07:38:42 bauhardt Exp $
 * $Revision: 1.1 $
 * $Date: 2008-08-05 07:38:42 $
 *
 * ====================================================================
 *
 * Copyright 2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.ejie.x38.webdav;

import java.io.InputStream;
import java.security.Principal;

import com.ejie.x38.webdav.exceptions.WebdavException;

/**
 * Interface for simple implementation of any store for the WebdavServlet
 * <p>
 * based on the BasicWebdavStore from Oliver Zeigermann, that was part of the
 * Webdav Construcktion Kit from slide
 * 
 */
public interface IWebdavStore {

    /**
     * Indicates that a new request or transaction with this store involved has
     * been started. The request will be terminated by either 
     * {@link #commit(ITransaction transaction)} or
     * {@link #rollback(ITransaction transaction)}. If only non-read methods
     * have been called, the request will be terminated by a
     * {@link #commit(ITransaction transaction)}. This method will be
     * called by (@link WebdavStoreAdapter} at the beginning of each request.
     * 
     * 
     * @param principal
     *      the principal that started this request or <code>null</code> if
     *      there is non available
     * 
     * @throws WebdavException
     */
    ITransaction begin(Principal principal);

    /**
     * Checks if authentication information passed in is valid. If not throws an
     * exception.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     */
    void checkAuthentication(ITransaction transaction);

    /**
     * Indicates that all changes done inside this request shall be made
     * permanent and any transactions, connections and other temporary resources
     * shall be terminated.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * 
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    void commit(ITransaction transaction);

    /**
     * Indicates that all changes done inside this request shall be undone and
     * any transactions, connections and other temporary resources shall be
     * terminated.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * 
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    void rollback(ITransaction transaction);

    /**
     * Creates a folder at the position specified by <code>folderUri</code>.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param folderUri
     *      URI of the folder
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    void createFolder(ITransaction transaction, String folderUri);

    /**
     * Creates a content resource at the position specified by
     * <code>resourceUri</code>.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param resourceUri
     *      URI of the content resource
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    void createResource(ITransaction transaction, String resourceUri);

    /**
     * Gets the content of the resource specified by <code>resourceUri</code>.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param resourceUri
     *      URI of the content resource
     * @return input stream you can read the content of the resource from
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    InputStream getResourceContent(ITransaction transaction, String resourceUri);

    /**
     * Sets / stores the content of the resource specified by
     * <code>resourceUri</code>.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param resourceUri
     *      URI of the resource where the content will be stored
     * @param content
     *      input stream from which the content will be read from
     * @param contentType
     *      content type of the resource or <code>null</code> if unknown
     * @param characterEncoding
     *      character encoding of the resource or <code>null</code> if unknown
     *      or not applicable
     * @return lenght of resource
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    long setResourceContent(ITransaction transaction, String resourceUri,
            InputStream content, String contentType, String characterEncoding);

    /**
     * Gets the names of the children of the folder specified by
     * <code>folderUri</code>.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param folderUri
     *      URI of the folder
     * @return a (possibly empty) list of children, or <code>null</code> if the
     *  uri points to a file
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    String[] getChildrenNames(ITransaction transaction, String folderUri);

    /**
     * Gets the length of the content resource specified by
     * <code>resourceUri</code>.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param resourceUri
     *      URI of the content resource
     * @return length of the resource in bytes, <code>-1</code> declares this
     *  value as invalid and asks the adapter to try to set it from the
     *  properties if possible
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    long getResourceLength(ITransaction transaction, String resourceUri);

    /**
     * Removes the object specified by <code>uri</code>.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param uri
     *      URI of the object, i.e. content resource or folder
     * @throws WebdavException
     *      if something goes wrong on the store level
     */
    void removeObject(ITransaction transaction, String uri);

    /**
     * Gets the storedObject specified by <code>uri</code>
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param uri
     *      URI
     * @return StoredObject
     */
    StoredObject getStoredObject(ITransaction transaction, String uri);

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/LocalFileSystemStore.java
================================================
/*
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
package com.ejie.x38.webdav;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.security.Principal;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ejie.x38.webdav.exceptions.WebdavException;

/**
 * Reference Implementation of WebdavStore
 * 
 * @author joa
 * @author re
 */
public class LocalFileSystemStore implements IWebdavStore {

	private Logger LOG =  LoggerFactory.getLogger(LocalFileSystemStore.class);

    private static int BUF_SIZE = 65536;

    private File _root = null;

    private String rootPath;
    
    public void setRootPath(String rootPath) {
		this.rootPath = rootPath;
	}

	public LocalFileSystemStore(File root) {
        _root = root;
    }
    
    public LocalFileSystemStore() {
    }

    @PostConstruct
    public void init(){
    	if (_root==null){
    		if(rootPath!=null && rootPath!=""){
		        if (rootPath.equals("*WAR-FILE-ROOT*")) {
		            String file = LocalFileSystemStore.class.getProtectionDomain()
		                    .getCodeSource().getLocation().getFile().replace('\\', '/');
		            if (file.charAt(0) == '/'
		                    && System.getProperty("os.name").indexOf("Windows") != -1) {
		                file = file.substring(1, file.length());
		            }

		            int ix = file.indexOf("/WEB-INF/");
		            if (ix != -1) {
		                rootPath = file.substring(0, ix).replace('/',
		                        File.separatorChar);
		            } else {
		                throw new WebdavException(
		                        "Could not determine root of war file. Can't extract from path '"
		                                + file + "' for this web container");
		            }
		        }
		        _root = new File(rootPath);
    		}
    	}
    }
    
    public ITransaction begin(Principal principal) throws WebdavException {
        LOG.debug("LocalFileSystemStore.begin()");
        if (!_root.exists()) {
            if (!_root.mkdirs()) {
                throw new WebdavException("root path: "
                        + _root.getAbsolutePath()
                        + " does not exist and could not be created");
            }
        }
        return null;
    }

    public void checkAuthentication(ITransaction transaction)
            throws SecurityException {
        LOG.debug("LocalFileSystemStore.checkAuthentication()");
        // do nothing

    }

    public void commit(ITransaction transaction) throws WebdavException {
        // do nothing
        LOG.debug("LocalFileSystemStore.commit()");
    }

    public void rollback(ITransaction transaction) throws WebdavException {
        // do nothing
        LOG.debug("LocalFileSystemStore.rollback()");

    }

    public void createFolder(ITransaction transaction, String uri)
            throws WebdavException {
        LOG.debug("LocalFileSystemStore.createFolder(" + uri + ")");
        File file = new File(_root, uri);
        if (!file.mkdir())
            throw new WebdavException("cannot create folder: " + uri);
    }

    public void createResource(ITransaction transaction, String uri)
            throws WebdavException {
        LOG.debug("LocalFileSystemStore.createResource(" + uri + ")");
        File file = new File(_root, uri);
        try {
            if (!file.createNewFile())
                throw new WebdavException("cannot create file: " + uri);
        } catch (IOException e) {
            LOG
                    .error("LocalFileSystemStore.createResource(" + uri
                            + ") failed");
            throw new WebdavException(e);
        }
    }

    public long setResourceContent(ITransaction transaction, String uri,
            InputStream is, String contentType, String characterEncoding)
            throws WebdavException {

        LOG.debug("LocalFileSystemStore.setResourceContent(" + uri + ")");
        File file = new File(_root, uri);
        try {
            OutputStream os = new BufferedOutputStream(new FileOutputStream(
                    file), BUF_SIZE);
            try {
                int read;
                byte[] copyBuffer = new byte[BUF_SIZE];

                while ((read = is.read(copyBuffer, 0, copyBuffer.length)) != -1) {
                    os.write(copyBuffer, 0, read);
                }
            } finally {
                try {
                    is.close();
                } finally {
                    os.close();
                }
            }
        } catch (IOException e) {
            LOG.error("LocalFileSystemStore.setResourceContent(" + uri
                    + ") failed");
            throw new WebdavException(e);
        }
        long length = -1;

        try {
            length = file.length();
        } catch (SecurityException e) {
            LOG.error("LocalFileSystemStore.setResourceContent(" + uri
                    + ") failed" + "\nCan't get file.length");
        }

        return length;
    }

    public String[] getChildrenNames(ITransaction transaction, String uri)
            throws WebdavException {
        LOG.debug("LocalFileSystemStore.getChildrenNames(" + uri + ")");
        File file = new File(_root, uri);
        String[] childrenNames = null;
        if (file.isDirectory()) {
            File[] children = file.listFiles();
            List<String> childList = new ArrayList<String>();
            String name = null;
            for (int i = 0; i < children.length; i++) {
                name = children[i].getName();
                childList.add(name);
                LOG.debug("Child " + i + ": " + name);
            }
            childrenNames = new String[childList.size()];
            childrenNames = (String[]) childList.toArray(childrenNames);
        }
        return childrenNames;
    }

    public void removeObject(ITransaction transaction, String uri)
            throws WebdavException {
        File file = new File(_root, uri);
        boolean success = file.delete();
        LOG.debug("LocalFileSystemStore.removeObject(" + uri + ")=" + success);
        if (!success) {
            throw new WebdavException("cannot delete object: " + uri);
        }

    }

    public InputStream getResourceContent(ITransaction transaction, String uri)
            throws WebdavException {
        LOG.debug("LocalFileSystemStore.getResourceContent(" + uri + ")");
        File file = new File(_root, uri);

        InputStream in;
        try {
            in = new BufferedInputStream(new FileInputStream(file));
        } catch (IOException e) {
            LOG.error("LocalFileSystemStore.getResourceContent(" + uri
                    + ") failed");
            throw new WebdavException(e);
        }
        return in;
    }

    public long getResourceLength(ITransaction transaction, String uri)
            throws WebdavException {
        LOG.debug("LocalFileSystemStore.getResourceLength(" + uri + ")");
        File file = new File(_root, uri);
        return file.length();
    }

    public StoredObject getStoredObject(ITransaction transaction, String uri) {

        StoredObject so = null;

        File file = new File(_root, uri);
        if (file.exists()) {
            so = new StoredObject();
            so.setFolder(file.isDirectory());
            so.setLastModified(new Date(file.lastModified()));
            so.setCreationDate(new Date(file.lastModified()));
            so.setResourceLength(getResourceLength(transaction, uri));
        }

        return so;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/StoredObject.java
================================================
/*
 * ====================================================================
 *
 * Copyright 2004 The Apache Software Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

package com.ejie.x38.webdav;

import java.util.Date;

public class StoredObject {

    private boolean isFolder;
    private Date lastModified;
    private Date creationDate;
    private long contentLength;

    private boolean isNullRessource;

    /**
     * Determines whether the StoredObject is a folder or a resource
     * 
     * @return true if the StoredObject is a collection
     */
    public boolean isFolder() {
        return (isFolder);
    }

    /**
     * Determines whether the StoredObject is a folder or a resource
     * 
     * @return true if the StoredObject is a resource
     */
    public boolean isResource() {
        return (!isFolder);
    }

    /**
     * Sets a new StoredObject as a collection or resource
     * 
     * @param f
     *      true - collection ; false - resource
     */
    public void setFolder(boolean f) {
        this.isFolder = f;
    }

    /**
     * Gets the date of the last modification
     * 
     * @return last modification Date
     */
    public Date getLastModified() {
        return (lastModified);
    }

    /**
     * Sets the date of the last modification
     * 
     * @param d
     *      date of the last modification
     */
    public void setLastModified(Date d) {
        this.lastModified = d;
    }

    /**
     * Gets the date of the creation
     * 
     * @return creation Date
     */
    public Date getCreationDate() {
        return (creationDate);
    }

    /**
     * Sets the date of the creation
     * 
     * @param d
     *      date of the creation
     */
    public void setCreationDate(Date d) {
        this.creationDate = d;
    }

    /**
     * Gets the length of the resource content
     * 
     * @return length of the resource content
     */
    public long getResourceLength() {
        return (contentLength);
    }

    /**
     * Sets the length of the resource content
     * 
     * @param l
     *      the length of the resource content
     */
    public void setResourceLength(long l) {
        this.contentLength = l;
    }

    /**
     * Gets the state of the resource
     * 
     * @return true if the resource is in lock-null state
     */
    public boolean isNullResource() {
        return isNullRessource;
    }

    /**
     * Sets a StoredObject as a lock-null resource
     * 
     * @param f
     *      true to set the resource as lock-null resource
     */
    public void setNullResource(boolean f) {
        this.isNullRessource = f;
        this.isFolder = false;
        this.creationDate = null;
        this.lastModified = null;
        // this.content = null;
        this.contentLength = 0;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/WebDavServletBean.java
================================================
package com.ejie.x38.webdav;

import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.locking.IResourceLocks;

public class WebDavServletBean extends HttpServlet {

	private static final long serialVersionUID = -4486300132003239385L;

	/**
     * MD5 message digest provider.
     */
    protected static MessageDigest SHA512_HELPER;

    protected IResourceLocks _resLocks;
    private IWebdavStore _store;
    private HashMap<String, IMethodExecutor> _methodMap = new HashMap<String, IMethodExecutor>();

    public WebDavServletBean() {
        try {
        	SHA512_HELPER = MessageDigest.getInstance("SHA-512");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException();
        }
    }

    public void init(IWebdavStore store, String dftIndexFile,
            String insteadOf404, int nocontentLenghHeaders,
            boolean lazyFolderCreationOnPut) throws ServletException {

        _store = store;

        IMimeTyper mimeTyper = new IMimeTyper() {
            public String getMimeType(String path) {
                return getServletContext().getMimeType(path);
            }
        };
        
        WebDavServletHelper.registerWebDavMethods(_store, _methodMap, dftIndexFile, insteadOf404, _resLocks, nocontentLenghHeaders, lazyFolderCreationOnPut, mimeTyper);
    }

    /**
     * Handles the special WebDAV methods.
     */
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {

    	WebDavServletHelper.processWebDav(request, response, this._store, this._methodMap);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/WebDavServletHelper.java
================================================
package com.ejie.x38.webdav;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.security.Principal;
import java.util.Enumeration;
import java.util.HashMap;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.exceptions.UnauthenticatedException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;
import com.ejie.x38.webdav.methods.DoCopy;
import com.ejie.x38.webdav.methods.DoDelete;
import com.ejie.x38.webdav.methods.DoGet;
import com.ejie.x38.webdav.methods.DoHead;
import com.ejie.x38.webdav.methods.DoLock;
import com.ejie.x38.webdav.methods.DoMkcol;
import com.ejie.x38.webdav.methods.DoMove;
import com.ejie.x38.webdav.methods.DoNotImplemented;
import com.ejie.x38.webdav.methods.DoOptions;
import com.ejie.x38.webdav.methods.DoPropfind;
import com.ejie.x38.webdav.methods.DoProppatch;
import com.ejie.x38.webdav.methods.DoPut;
import com.ejie.x38.webdav.methods.DoUnlock;

public class WebDavServletHelper {

	private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
    .getLogger(WebDavServletBean.class);
	
	private static final boolean READ_ONLY = false;
	
	public static void processWebDav(HttpServletRequest request,
			HttpServletResponse response, IWebdavStore webDavStore, HashMap<String, IMethodExecutor> _methodMap) throws ServletException, IOException {
		String methodName = request.getMethod();
		ITransaction transaction = null;
		boolean needRollback = false;

		if (LOG.isTraceEnabled()){
			WebDavServletHelper.debugRequest(methodName, request);
		}

		try {
			Principal userPrincipal = request.getUserPrincipal();
			transaction = webDavStore.begin(userPrincipal);
			needRollback = true;
			webDavStore.checkAuthentication(transaction);
			response.setStatus(WebdavStatus.SC_OK);

			try {
				IMethodExecutor methodExecutor = (IMethodExecutor) _methodMap
						.get(methodName);
				if (methodExecutor == null) {
					methodExecutor = (IMethodExecutor) _methodMap
							.get("*NO*IMPL*");
				}

				methodExecutor.execute(transaction, request, response);

				webDavStore.commit(transaction);
				needRollback = false;
			} catch (IOException e) {
				java.io.StringWriter sw = new java.io.StringWriter();
				java.io.PrintWriter pw = new java.io.PrintWriter(sw);
				e.printStackTrace(pw);
				LOG.error("IOException: " + sw.toString());
				response.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
				webDavStore.rollback(transaction);
				throw new ServletException(e);
			}

		} catch (UnauthenticatedException e) {
			response.sendError(WebdavStatus.SC_FORBIDDEN);
		} catch (WebdavException e) {
			java.io.StringWriter sw = new java.io.StringWriter();
			java.io.PrintWriter pw = new java.io.PrintWriter(sw);
			e.printStackTrace(pw);
			LOG.error("WebdavException: " + sw.toString());
			throw new ServletException(e);
		} catch (Exception e) {
			java.io.StringWriter sw = new java.io.StringWriter();
			java.io.PrintWriter pw = new java.io.PrintWriter(sw);
			e.printStackTrace(pw);
			LOG.error("Exception: " + sw.toString());
		} finally {
			if (needRollback)
				webDavStore.rollback(transaction);
		}

	}

	public static void registerWebDavMethods(IWebdavStore webDavStore, HashMap<String, IMethodExecutor> _methodMap, String dftIndexFile, String insteadOf404, IResourceLocks _resLocks, int nocontentLenghHeaders, boolean lazyFolderCreationOnPut, IMimeTyper mimeTyper){
		WebDavServletHelper.register("GET", _methodMap, new DoGet(webDavStore, dftIndexFile, insteadOf404, _resLocks,
				mimeTyper, nocontentLenghHeaders));
		WebDavServletHelper.register("HEAD", _methodMap, new DoHead(webDavStore, dftIndexFile, insteadOf404,
				_resLocks, mimeTyper, nocontentLenghHeaders));

		DoDelete doDelete = (DoDelete) WebDavServletHelper.register("DELETE",  _methodMap,new DoDelete(webDavStore,
				_resLocks, READ_ONLY));
		
		DoCopy doCopy = (DoCopy) WebDavServletHelper.register("COPY",  _methodMap, new DoCopy(webDavStore, _resLocks,
				doDelete, READ_ONLY));
		
		WebDavServletHelper.register("LOCK", _methodMap, new DoLock(webDavStore, _resLocks, READ_ONLY));
		WebDavServletHelper.register("UNLOCK", _methodMap, new DoUnlock(webDavStore, _resLocks, READ_ONLY));
		WebDavServletHelper.register("MOVE", _methodMap, new DoMove(_resLocks, doDelete, doCopy, READ_ONLY));
		WebDavServletHelper.register("MKCOL", _methodMap, new DoMkcol(webDavStore, _resLocks, READ_ONLY));
		WebDavServletHelper.register("OPTIONS", _methodMap, new DoOptions(webDavStore, _resLocks));
		WebDavServletHelper.register("PUT", _methodMap, new DoPut(webDavStore, _resLocks, READ_ONLY,
				lazyFolderCreationOnPut));
		WebDavServletHelper.register("PROPFIND", _methodMap, new DoPropfind(webDavStore, _resLocks, mimeTyper));
		WebDavServletHelper.register("PROPPATCH", _methodMap, new DoProppatch(webDavStore, _resLocks, READ_ONLY));
		WebDavServletHelper.register("*NO*IMPL*", _methodMap, new DoNotImplemented(READ_ONLY));
	}
	
	public static IWebdavStore constructStore(String clazzName, File root) {
        IWebdavStore webdavStore;
        try {
        	Class<?> clazz = Class.forName(clazzName);

            Constructor<?> ctor = clazz
                    .getConstructor(new Class[] { File.class });

            webdavStore = (IWebdavStore) ctor
                    .newInstance(new Object[] { root });
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("some problem making store component", e);
        }
        return webdavStore;
    }
    
	public static IResourceLocks constructResourceLocks(String clazzName){
    	IResourceLocks resourceLocks;
        try {
        	Class<?> clazz = Class.forName(clazzName);

            Constructor<?> ctor = clazz
                    .getConstructor();

            resourceLocks = (IResourceLocks) ctor.newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("some problem making store component", e);
        }
        return resourceLocks;
    }
	
	private static IMethodExecutor register(String methodName, HashMap<String, IMethodExecutor> _methodMap, IMethodExecutor method) {
        _methodMap.put(methodName, method);
        return method;
    }
	
	private static void debugRequest(String methodName, HttpServletRequest req) {
        LOG.trace("-----------");
        LOG.trace("WebdavServlet\n request: methodName = " + methodName);
        LOG.trace("time: " + System.currentTimeMillis());
        LOG.trace("path: " + req.getRequestURI());
        LOG.trace("-----------");
        Enumeration<?> e = req.getHeaderNames();
        while (e.hasMoreElements()) {
            String s = (String) e.nextElement();
            LOG.trace("header: " + s + " " + req.getHeader(s));
        }
        e = req.getAttributeNames();
        while (e.hasMoreElements()) {
            String s = (String) e.nextElement();
            LOG.trace("attribute: " + s + " " + req.getAttribute(s));
        }
        e = req.getParameterNames();
        while (e.hasMoreElements()) {
            String s = (String) e.nextElement();
            LOG.trace("parameter: " + s + " " + req.getParameter(s));
        }
    }
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/WebdavServlet.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav;

import java.io.File;
import java.lang.reflect.Constructor;

import javax.servlet.ServletException;

import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;
import com.ejie.x38.webdav.locking.MemoryResourceLocks;

/**
 * Servlet which provides support for WebDAV level 2.
 * 
 * the original class is org.apache.catalina.servlets.WebdavServlet by Remy
 * Maucherat, which was heavily changed
 * 
 * @author Remy Maucherat
 */
public class WebdavServlet extends WebDavServletBean  {

    private static final String ROOTPATH_PARAMETER = "rootpath";

    @Override
    public void init() throws ServletException {

        // Parameters from web.xml
        String clazzName = getServletConfig().getInitParameter(
                "ResourceHandlerImplementation");
        if (clazzName == null || clazzName.equals("")) {
            clazzName = LocalFileSystemStore.class.getName();
        }
        
        File root = getFileRoot();
        IWebdavStore webdavStore = constructStore(clazzName, root);

        // Parametro del ResourceLock
        String resourceLocksClazzName = getServletConfig().getInitParameter(
        "ResourceLocksImplementation");
        if (resourceLocksClazzName == null || resourceLocksClazzName.equals("")) {
        	resourceLocksClazzName = MemoryResourceLocks.class.getName();
        }
        
        this._resLocks = this.constructResourceLocks(resourceLocksClazzName);

        boolean lazyFolderCreationOnPut = getInitParameter("lazyFolderCreationOnPut") != null
                && getInitParameter("lazyFolderCreationOnPut").equals("1");

        String dftIndexFile = getInitParameter("default-index-file");
        String insteadOf404 = getInitParameter("instead-of-404");

        int noContentLengthHeader = getIntInitParameter("no-content-length-headers");

        super.init(webdavStore, dftIndexFile, insteadOf404,
                noContentLengthHeader, lazyFolderCreationOnPut);
    }

    private int getIntInitParameter(String key) {
        return getInitParameter(key) == null ? -1 : Integer
                .parseInt(getInitParameter(key));
    }

    protected IWebdavStore constructStore(String clazzName, File root) {
        IWebdavStore webdavStore;
        try {
        	Class<?> clazz = Class.forName(clazzName);

            Constructor<?> ctor = clazz
                    .getConstructor(new Class[] { File.class });

            webdavStore = (IWebdavStore) ctor
                    .newInstance(new Object[] { root });
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("some problem making store component", e);
        }
        return webdavStore;
    }
    
    protected IResourceLocks constructResourceLocks(String clazzName){
    	IResourceLocks resourceLocks;
        try {
        	Class<?> clazz = Class.forName(clazzName);

            Constructor<?> ctor = clazz
                    .getConstructor();

            resourceLocks = (IResourceLocks) ctor.newInstance();
        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException("some problem making store component", e);
        }
        return resourceLocks;
    }

    private File getFileRoot() {
        String rootPath = getInitParameter(ROOTPATH_PARAMETER);
        if (rootPath == null) {
            throw new WebdavException("missing parameter: "
                    + ROOTPATH_PARAMETER);
        }
        if (rootPath.equals("*WAR-FILE-ROOT*")) {
            String file = LocalFileSystemStore.class.getProtectionDomain()
                    .getCodeSource().getLocation().getFile().replace('\\', '/');
            if (file.charAt(0) == '/'
                    && System.getProperty("os.name").indexOf("Windows") != -1) {
                file = file.substring(1, file.length());
            }

            int ix = file.indexOf("/WEB-INF/");
            if (ix != -1) {
                rootPath = file.substring(0, ix).replace('/',
                        File.separatorChar);
            } else {
                throw new WebdavException(
                        "Could not determine root of war file. Can't extract from path '"
                                + file + "' for this web container");
            }
        }
        return new File(rootPath);
    }

    
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/WebdavSpringServlet.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav;

import java.io.IOException;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;

import javax.annotation.PostConstruct;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.springframework.web.HttpRequestHandler;

import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;

/**
 * Servlet which provides support for WebDAV level 2.
 * 
 * the original class is org.apache.catalina.servlets.WebdavServlet by Remy
 * Maucherat, which was heavily changed
 * 
 * @author Remy Maucherat
 */
public class WebdavSpringServlet implements HttpRequestHandler {

	private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
     .getLogger(WebDavServletBean.class);
	
    private Boolean lazyFolderCreationOnPut;
    
    private String defaultIndexFile;
    
    private String insteadOf404;
    
    private Integer noContentLengthHeaders;
    
    private IWebdavStore webDavStore;
    
    private IResourceLocks resourceLocks;
    
    private HashMap<String, IMethodExecutor> _methodMap = new HashMap<String, IMethodExecutor>();
    
    protected static MessageDigest SHA512_HELPER;
    
    @PostConstruct
    public void init() throws ServletException {

    	try {
    		SHA512_HELPER = MessageDigest.getInstance("SHA-512");
        } catch (NoSuchAlgorithmException e) {
            throw new IllegalStateException();
        }
        
        if (this.noContentLengthHeaders==null){
        	this.noContentLengthHeaders = Integer.valueOf(0);
        }
    	
        if (this.lazyFolderCreationOnPut==null){
        	this.lazyFolderCreationOnPut = Boolean.FALSE;
        }

        // Inicialización del componente de locking
        if (this.resourceLocks == null){
        	LOG.error("No se ha configurado correctamente el gestor de locking de webDav");
        	throw new WebdavException("No se ha configurado correctamente el gestor de locking de webDav");
        }
        
        WebDavServletHelper.registerWebDavMethods(webDavStore, _methodMap, defaultIndexFile, insteadOf404, resourceLocks, noContentLengthHeaders, lazyFolderCreationOnPut, null);
    	
    }

    
    @Override
	public void handleRequest(HttpServletRequest request,
			HttpServletResponse response)
			throws ServletException, IOException {
    	
    	WebDavServletHelper.processWebDav(request, response, this.webDavStore, this._methodMap);
	}
    

	public void setLazyFolderCreationOnPut(Boolean lazyFolderCreationOnPut) {
		this.lazyFolderCreationOnPut = lazyFolderCreationOnPut;
	}

	public void setDefaultIndexFile(String defaultIndexFile) {
		this.defaultIndexFile = defaultIndexFile;
	}

	public void setInsteadOf404(String insteadOf404) {
		this.insteadOf404 = insteadOf404;
	}

	public void setNoContentLengthHeaders(Integer noContentLengthHeaders) {
		this.noContentLengthHeaders = noContentLengthHeaders;
	}

	public void setWebDavStore(IWebdavStore webDavStore) {
		this.webDavStore = webDavStore;
	}

	public void setResourceLocks(IResourceLocks resourceLocks) {
		this.resourceLocks = resourceLocks;
	}
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/WebdavStatus.java
================================================
package com.ejie.x38.webdav;

import java.util.Hashtable;

import javax.servlet.http.HttpServletResponse;

/**
 * Wraps the HttpServletResponse class to abstract the specific protocol used.
 * To support other protocols we would only need to modify this class and the
 * WebDavRetCode classes.
 * 
 * @author Marc Eaddy
 * @version 1.0, 16 Nov 1997
 */
public class WebdavStatus {

    // ----------------------------------------------------- Instance Variables

    /**
     * This Hashtable contains the mapping of HTTP and WebDAV status codes to
     * descriptive text. This is a static variable.
     */
    private static Hashtable<Integer, String> _mapStatusCodes = new Hashtable<Integer, String>();

    // ------------------------------------------------------ HTTP Status Codes

    /**
     * Status code (200) indicating the request succeeded normally.
     */
    public static final int SC_OK = HttpServletResponse.SC_OK;

    /**
     * Status code (201) indicating the request succeeded and created a new
     * resource on the server.
     */
    public static final int SC_CREATED = HttpServletResponse.SC_CREATED;

    /**
     * Status code (202) indicating that a request was accepted for processing,
     * but was not completed.
     */
    public static final int SC_ACCEPTED = HttpServletResponse.SC_ACCEPTED;

    /**
     * Status code (204) indicating that the request succeeded but that there
     * was no new information to return.
     */
    public static final int SC_NO_CONTENT = HttpServletResponse.SC_NO_CONTENT;

    /**
     * Status code (301) indicating that the resource has permanently moved to a
     * new location, and that future references should use a new URI with their
     * requests.
     */
    public static final int SC_MOVED_PERMANENTLY = HttpServletResponse.SC_MOVED_PERMANENTLY;

    /**
     * Status code (302) indicating that the resource has temporarily moved to
     * another location, but that future references should still use the
     * original URI to access the resource.
     */
    public static final int SC_MOVED_TEMPORARILY = HttpServletResponse.SC_MOVED_TEMPORARILY;

    /**
     * Status code (304) indicating that a conditional GET operation found that
     * the resource was available and not modified.
     */
    public static final int SC_NOT_MODIFIED = HttpServletResponse.SC_NOT_MODIFIED;

    /**
     * Status code (400) indicating the request sent by the client was
     * syntactically incorrect.
     */
    public static final int SC_BAD_REQUEST = HttpServletResponse.SC_BAD_REQUEST;

    /**
     * Status code (401) indicating that the request requires HTTP
     * authentication.
     */
    public static final int SC_UNAUTHORIZED = HttpServletResponse.SC_UNAUTHORIZED;

    /**
     * Status code (403) indicating the server understood the request but
     * refused to fulfill it.
     */
    public static final int SC_FORBIDDEN = HttpServletResponse.SC_FORBIDDEN;

    /**
     * Status code (404) indicating that the requested resource is not
     * available.
     */
    public static final int SC_NOT_FOUND = HttpServletResponse.SC_NOT_FOUND;

    /**
     * Status code (500) indicating an error inside the HTTP service which
     * prevented it from fulfilling the request.
     */
    public static final int SC_INTERNAL_SERVER_ERROR = HttpServletResponse.SC_INTERNAL_SERVER_ERROR;

    /**
     * Status code (501) indicating the HTTP service does not support the
     * functionality needed to fulfill the request.
     */
    public static final int SC_NOT_IMPLEMENTED = HttpServletResponse.SC_NOT_IMPLEMENTED;

    /**
     * Status code (502) indicating that the HTTP server received an invalid
     * response from a server it consulted when acting as a proxy or gateway.
     */
    public static final int SC_BAD_GATEWAY = HttpServletResponse.SC_BAD_GATEWAY;

    /**
     * Status code (503) indicating that the HTTP service is temporarily
     * overloaded, and unable to handle the request.
     */
    public static final int SC_SERVICE_UNAVAILABLE = HttpServletResponse.SC_SERVICE_UNAVAILABLE;

    /**
     * Status code (100) indicating the client may continue with its request.
     * This interim response is used to inform the client that the initial part
     * of the request has been received and has not yet been rejected by the
     * server.
     */
    public static final int SC_CONTINUE = 100;

    /**
     * Status code (405) indicating the method specified is not allowed for the
     * resource.
     */
    public static final int SC_METHOD_NOT_ALLOWED = 405;

    /**
     * Status code (409) indicating that the request could not be completed due
     * to a conflict with the current state of the resource.
     */
    public static final int SC_CONFLICT = 409;

    /**
     * Status code (412) indicating the precondition given in one or more of the
     * request-header fields evaluated to false when it was tested on the
     * server.
     */
    public static final int SC_PRECONDITION_FAILED = 412;

    /**
     * Status code (413) indicating the server is refusing to process a request
     * because the request entity is larger than the server is willing or able
     * to process.
     */
    public static final int SC_REQUEST_TOO_LONG = 413;

    /**
     * Status code (415) indicating the server is refusing to service the
     * request because the entity of the request is in a format not supported by
     * the requested resource for the requested method.
     */
    public static final int SC_UNSUPPORTED_MEDIA_TYPE = 415;

    // -------------------------------------------- Extended WebDav status code

    /**
     * Status code (207) indicating that the response requires providing status
     * for multiple independent operations.
     */
    public static final int SC_MULTI_STATUS = 207;

    // This one colides with HTTP 1.1
    // "207 Parital Update OK"

    /**
     * Status code (418) indicating the entity body submitted with the PATCH
     * method was not understood by the resource.
     */
    public static final int SC_UNPROCESSABLE_ENTITY = 418;

    // This one colides with HTTP 1.1
    // "418 Reauthentication Required"

    /**
     * Status code (419) indicating that the resource does not have sufficient
     * space to record the state of the resource after the execution of this
     * method.
     */
    public static final int SC_INSUFFICIENT_SPACE_ON_RESOURCE = 419;

    // This one colides with HTTP 1.1
    // "419 Proxy Reauthentication Required"

    /**
     * Status code (420) indicating the method was not executed on a particular
     * resource within its scope because some part of the method's execution
     * failed causing the entire method to be aborted.
     */
    public static final int SC_METHOD_FAILURE = 420;

    /**
     * Status code (423) indicating the destination resource of a method is
     * locked, and either the request did not contain a valid Lock-Info header,
     * or the Lock-Info header identifies a lock held by another principal.
     */
    public static final int SC_LOCKED = 423;

    // ------------------------------------------------------------ Initializer

    static {
        // HTTP 1.0 Status Code
        addStatusCodeMap(SC_OK, "OK");
        addStatusCodeMap(SC_CREATED, "Created");
        addStatusCodeMap(SC_ACCEPTED, "Accepted");
        addStatusCodeMap(SC_NO_CONTENT, "No Content");
        addStatusCodeMap(SC_MOVED_PERMANENTLY, "Moved Permanently");
        addStatusCodeMap(SC_MOVED_TEMPORARILY, "Moved Temporarily");
        addStatusCodeMap(SC_NOT_MODIFIED, "Not Modified");
        addStatusCodeMap(SC_BAD_REQUEST, "Bad Request");
        addStatusCodeMap(SC_UNAUTHORIZED, "Unauthorized");
        addStatusCodeMap(SC_FORBIDDEN, "Forbidden");
        addStatusCodeMap(SC_NOT_FOUND, "Not Found");
        addStatusCodeMap(SC_INTERNAL_SERVER_ERROR, "Internal Server Error");
        addStatusCodeMap(SC_NOT_IMPLEMENTED, "Not Implemented");
        addStatusCodeMap(SC_BAD_GATEWAY, "Bad Gateway");
        addStatusCodeMap(SC_SERVICE_UNAVAILABLE, "Service Unavailable");
        addStatusCodeMap(SC_CONTINUE, "Continue");
        addStatusCodeMap(SC_METHOD_NOT_ALLOWED, "Method Not Allowed");
        addStatusCodeMap(SC_CONFLICT, "Conflict");
        addStatusCodeMap(SC_PRECONDITION_FAILED, "Precondition Failed");
        addStatusCodeMap(SC_REQUEST_TOO_LONG, "Request Too Long");
        addStatusCodeMap(SC_UNSUPPORTED_MEDIA_TYPE, "Unsupported Media Type");
        // WebDav Status Codes
        addStatusCodeMap(SC_MULTI_STATUS, "Multi-Status");
        addStatusCodeMap(SC_UNPROCESSABLE_ENTITY, "Unprocessable Entity");
        addStatusCodeMap(SC_INSUFFICIENT_SPACE_ON_RESOURCE,
                "Insufficient Space On Resource");
        addStatusCodeMap(SC_METHOD_FAILURE, "Method Failure");
        addStatusCodeMap(SC_LOCKED, "Locked");
    }

    // --------------------------------------------------------- Public Methods

    /**
     * Returns the HTTP status text for the HTTP or WebDav status code specified
     * by looking it up in the static mapping. This is a static function.
     * 
     * @param nHttpStatusCode
     *      [IN] HTTP or WebDAV status code
     * @return A string with a short descriptive phrase for the HTTP status code
     *  (e.g., "OK").
     */
    public static String getStatusText(int nHttpStatusCode) {
        Integer intKey = Integer.valueOf(nHttpStatusCode);

        if (!_mapStatusCodes.containsKey(intKey)) {
            return "";
        } else {
            return (String) _mapStatusCodes.get(intKey);
        }
    }

    // -------------------------------------------------------- Private Methods

    /**
     * Adds a new status code -> status text mapping. This is a static method
     * because the mapping is a static variable.
     * 
     * @param nKey
     *      [IN] HTTP or WebDAV status code
     * @param strVal
     *      [IN] HTTP status text
     */
    private static void addStatusCodeMap(int nKey, String strVal) {
        _mapStatusCodes.put(Integer.valueOf(nKey), strVal);
    }

};


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/exceptions/AccessDeniedException.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.exceptions;

public class AccessDeniedException extends WebdavException {

    public AccessDeniedException() {
        super();
    }

    public AccessDeniedException(String message) {
        super(message);
    }

    public AccessDeniedException(String message, Throwable cause) {
        super(message, cause);
    }

    public AccessDeniedException(Throwable cause) {
        super(cause);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/exceptions/LockFailedException.java
================================================
package com.ejie.x38.webdav.exceptions;

public class LockFailedException extends WebdavException {

    public LockFailedException() {
        super();
    }

    public LockFailedException(String message) {
        super(message);
    }

    public LockFailedException(String message, Throwable cause) {
        super(message, cause);
    }

    public LockFailedException(Throwable cause) {
        super(cause);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/exceptions/ObjectAlreadyExistsException.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.exceptions;

public class ObjectAlreadyExistsException extends WebdavException {

    public ObjectAlreadyExistsException() {
        super();
    }

    public ObjectAlreadyExistsException(String message) {
        super(message);
    }

    public ObjectAlreadyExistsException(String message, Throwable cause) {
        super(message, cause);
    }

    public ObjectAlreadyExistsException(Throwable cause) {
        super(cause);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/exceptions/ObjectNotFoundException.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.exceptions;

public class ObjectNotFoundException extends WebdavException {

    public ObjectNotFoundException() {
        super();
    }

    public ObjectNotFoundException(String message) {
        super(message);
    }

    public ObjectNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }

    public ObjectNotFoundException(Throwable cause) {
        super(cause);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/exceptions/UnauthenticatedException.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.exceptions;

public class UnauthenticatedException extends WebdavException {

    public UnauthenticatedException() {
        super();
    }

    public UnauthenticatedException(String message) {
        super(message);
    }

    public UnauthenticatedException(String message, Throwable cause) {
        super(message, cause);
    }

    public UnauthenticatedException(Throwable cause) {
        super(cause);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/exceptions/WebdavException.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.exceptions;

public class WebdavException extends RuntimeException {

    public WebdavException() {
        super();
    }

    public WebdavException(String message) {
        super(message);
    }

    public WebdavException(String message, Throwable cause) {
        super(message, cause);
    }

    public WebdavException(Throwable cause) {
        super(cause);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/fromcatalina/RequestUtil.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.fromcatalina;

import java.io.UnsupportedEncodingException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Map;
import java.util.TimeZone;

import javax.servlet.http.Cookie;

/**
 * General purpose request parsing and encoding utility methods.
 * 
 * @author Craig R. McClanahan
 * @author Tim Tye
 * @version $Revision: 1.2 $ $Date: 2008-08-05 07:38:45 $
 */

public final class RequestUtil {

    /**
     * The DateFormat to use for generating readable dates in cookies.
     */
    private static SimpleDateFormat FORMAT = new SimpleDateFormat(
            " EEEE, dd-MMM-yy kk:mm:ss zz");

    static {
        FORMAT.setTimeZone(TimeZone.getTimeZone("GMT"));
    }

    /**
     * Encode a cookie as per RFC 2109. The resulting string can be used as the
     * value for a <code>Set-Cookie</code> header.
     * 
     * @param cookie
     *      The cookie to encode.
     * @return A string following RFC 2109.
     */
    public static String encodeCookie(Cookie cookie) {

        StringBuilder buf = new StringBuilder(cookie.getName());
        buf.append("=");
        buf.append(cookie.getValue());

        String comment = cookie.getComment();
        if (comment != null) {
            buf.append("; Comment=\"");
            buf.append(comment);
            buf.append("\"");
        }

        String domain = cookie.getDomain();
        if (domain != null) {
            buf.append("; Domain=\"");
            buf.append(domain);
            buf.append("\"");
        }

        int age = cookie.getMaxAge();
        if (age >= 0) {
            buf.append("; Max-Age=\"");
            buf.append(age);
            buf.append("\"");
        }

        String path = cookie.getPath();
        if (path != null) {
            buf.append("; Path=\"");
            buf.append(path);
            buf.append("\"");
        }

        if (cookie.getSecure()) {
            buf.append("; Secure");
        }

        int version = cookie.getVersion();
        if (version > 0) {
            buf.append("; Version=\"");
            buf.append(version);
            buf.append("\"");
        }

        return (buf.toString());
    }

    /**
     * Filter the specified message string for characters that are sensitive in
     * HTML. This avoids potential attacks caused by including JavaScript codes
     * in the request URL that is often reported in error messages.
     * 
     * @param message
     *      The message string to be filtered
     */
    public static String filter(String message) {

        if (message == null)
            return (null);

        char content[] = new char[message.length()];
        message.getChars(0, message.length(), content, 0);
        StringBuilder result = new StringBuilder(content.length + 50);
        for (int i = 0; i < content.length; i++) {
            switch (content[i]) {
            case '<':
                result.append("&lt;");
                break;
            case '>':
                result.append("&gt;");
                break;
            case '&':
                result.append("&amp;");
                break;
            case '"':
                result.append("&quot;");
                break;
            default:
                result.append(content[i]);
            }
        }
        return (result.toString());

    }

    /**
     * Normalize a relative URI path that may have relative values ("/./",
     * "/../", and so on ) it it. <strong>WARNING</strong> - This method is
     * useful only for normalizing application-generated paths. It does not try
     * to perform security checks for malicious input.
     * 
     * @param path
     *      Relative path to be normalized
     */
    public static String normalize(String path) {

        if (path == null)
            return null;

        // Create a place for the normalized path
        String normalized = path;

        if (normalized.equals("/."))
            return "/";

        // Add a leading "/" if necessary
        if (!normalized.startsWith("/"))
            normalized = "/" + normalized;

        // Resolve occurrences of "//" in the normalized path
        while (true) {
            int index = normalized.indexOf("//");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index)
                    + normalized.substring(index + 1);
        }

        // Resolve occurrences of "/./" in the normalized path
        while (true) {
            int index = normalized.indexOf("/./");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index)
                    + normalized.substring(index + 2);
        }

        // Resolve occurrences of "/../" in the normalized path
        while (true) {
            int index = normalized.indexOf("/../");
            if (index < 0)
                break;
            if (index == 0)
                return (null); // Trying to go outside our context
            int index2 = normalized.lastIndexOf('/', index - 1);
            normalized = normalized.substring(0, index2)
                    + normalized.substring(index + 3);
        }

        // Return the normalized path that we have completed
        return (normalized);

    }

    /**
     * Parse the character encoding from the specified content type header. If
     * the content type is null, or there is no explicit character encoding,
     * <code>null</code> is returned.
     * 
     * @param contentType
     *      a content type header
     */
    public static String parseCharacterEncoding(String contentType) {

        if (contentType == null)
            return (null);
        int start = contentType.indexOf("charset=");
        if (start < 0)
            return (null);
        String encoding = contentType.substring(start + 8);
        int end = encoding.indexOf(';');
        if (end >= 0)
            encoding = encoding.substring(0, end);
        encoding = encoding.trim();
        if ((encoding.length() > 2) && (encoding.startsWith("\""))
                && (encoding.endsWith("\"")))
            encoding = encoding.substring(1, encoding.length() - 1);
        return (encoding.trim());

    }

    /**
     * Parse a cookie header into an array of cookies according to RFC 2109.
     * 
     * @param header
     *      Value of an HTTP "Cookie" header
     */
    public static Cookie[] parseCookieHeader(String header) {

        if ((header == null) || (header.length() < 1))
            return (new Cookie[0]);

        ArrayList<Cookie> cookies = new ArrayList<Cookie>();
        while (header.length() > 0) {
            int semicolon = header.indexOf(';');
            if (semicolon < 0)
                semicolon = header.length();
            if (semicolon == 0)
                break;
            String token = header.substring(0, semicolon);
            if (semicolon < header.length())
                header = header.substring(semicolon + 1);
            else
                header = "";
            try {
                int equals = token.indexOf('=');
                if (equals > 0) {
                    String name = token.substring(0, equals).trim();
                    String value = token.substring(equals + 1).trim();
                    final Cookie cookie = new Cookie(name, value);
                    cookie.setSecure(true);
                    cookies.add(cookie);
                }
            } catch (Throwable ignored) {
                ;
            }
        }

        return ((Cookie[]) cookies.toArray(new Cookie[0]));

    }

    /**
     * Append request parameters from the specified String to the specified Map.
     * It is presumed that the specified Map is not accessed from any other
     * thread, so no synchronization is performed.
     * <p>
     * <strong>IMPLEMENTATION NOTE</strong>: URL decoding is performed
     * individually on the parsed name and value elements, rather than on the
     * entire query string ahead of time, to properly deal with the case where
     * the name or value includes an encoded "=" or "&" character that would
     * otherwise be interpreted as a delimiter.
     * 
     * @param map
     *      Map that accumulates the resulting parameters
     * @param data
     *      Input string containing request parameters
     * 
     * @exception IllegalArgumentException
     *      if the data is malformed
     */
    public static void parseParameters(Map<String, String[]> map, String data,
            String encoding) throws UnsupportedEncodingException {

        if ((data != null) && (data.length() > 0)) {

            // use the specified encoding to extract bytes out of the
            // given string so that the encoding is not lost. If an
            // encoding is not specified, let it use platform default
            byte[] bytes = null;
            try {
                if (encoding == null) {
                    bytes = data.getBytes();
                } else {
                    bytes = data.getBytes(encoding);
                }
            } catch (UnsupportedEncodingException uee) {
            }

            parseParameters(map, bytes, encoding);
        }

    }

    /**
     * Decode and return the specified URL-encoded String. When the byte array
     * is converted to a string, the system default character encoding is
     * used... This may be different than some other servers.
     * 
     * @param str
     *      The url-encoded string
     * 
     * @exception IllegalArgumentException
     *      if a '%' character is not followed by a valid 2-digit hexadecimal
     *      number
     */
    public static String URLDecode(String str) {

        return URLDecode(str, null);

    }

    /**
     * Decode and return the specified URL-encoded String.
     * 
     * @param str
     *      The url-encoded string
     * @param enc
     *      The encoding to use; if null, the default encoding is used
     * @exception IllegalArgumentException
     *      if a '%' character is not followed by a valid 2-digit hexadecimal
     *      number
     */
    public static String URLDecode(String str, String enc) {

        if (str == null)
            return (null);

        // use the specified encoding to extract bytes out of the
        // given string so that the encoding is not lost. If an
        // encoding is not specified, let it use platform default
        byte[] bytes = null;
        try {
            if (enc == null) {
                bytes = str.getBytes();
            } else {
                bytes = str.getBytes(enc);
            }
        } catch (UnsupportedEncodingException uee) {
        }

        return URLDecode(bytes, enc);

    }

    /**
     * Decode and return the specified URL-encoded byte array.
     * 
     * @param bytes
     *      The url-encoded byte array
     * @exception IllegalArgumentException
     *      if a '%' character is not followed by a valid 2-digit hexadecimal
     *      number
     */
    public static String URLDecode(byte[] bytes) {
        return URLDecode(bytes, null);
    }

    /**
     * Decode and return the specified URL-encoded byte array.
     * 
     * @param bytes
     *      The url-encoded byte array
     * @param enc
     *      The encoding to use; if null, the default encoding is used
     * @exception IllegalArgumentException
     *      if a '%' character is not followed by a valid 2-digit hexadecimal
     *      number
     */
    public static String URLDecode(byte[] bytes, String enc) {

        if (bytes == null)
            return (null);

        int len = bytes.length;
        int ix = 0;
        int ox = 0;
        while (ix < len) {
            byte b = bytes[ix++]; // Get byte to test
            if (b == '+') {
                b = (byte) ' ';
            } else if (b == '%') {
                b = (byte) ((convertHexDigit(bytes[ix++]) << 4) + convertHexDigit(bytes[ix++]));
            }
            bytes[ox++] = b;
        }
        if (enc != null) {
            try {
                return new String(bytes, 0, ox, enc);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return new String(bytes, 0, ox);

    }

    /**
     * Convert a byte character value to hexidecimal digit value.
     * 
     * @param b
     *      the character value byte
     */
    private static byte convertHexDigit(byte b) {
        if ((b >= '0') && (b <= '9'))
            return (byte) (b - '0');
        if ((b >= 'a') && (b <= 'f'))
            return (byte) (b - 'a' + 10);
        if ((b >= 'A') && (b <= 'F'))
            return (byte) (b - 'A' + 10);
        return 0;
    }

    /**
     * Put name and value pair in map. When name already exist, add value to
     * array of values.
     * 
     * @param map
     *      The map to populate
     * @param name
     *      The parameter name
     * @param value
     *      The parameter value
     */
    private static void putMapEntry(Map<String, String[]> map, String name,
            String value) {
        String[] newValues = null;
        String[] oldValues = (String[]) map.get(name);
        if (oldValues == null) {
            newValues = new String[1];
            newValues[0] = value;
        } else {
            newValues = new String[oldValues.length + 1];
            System.arraycopy(oldValues, 0, newValues, 0, oldValues.length);
            newValues[oldValues.length] = value;
        }
        map.put(name, newValues);
    }

    /**
     * Append request parameters from the specified String to the specified Map.
     * It is presumed that the specified Map is not accessed from any other
     * thread, so no synchronization is performed.
     * <p>
     * <strong>IMPLEMENTATION NOTE</strong>: URL decoding is performed
     * individually on the parsed name and value elements, rather than on the
     * entire query string ahead of time, to properly deal with the case where
     * the name or value includes an encoded "=" or "&" character that would
     * otherwise be interpreted as a delimiter. NOTE: byte array data is
     * modified by this method. Caller beware.
     * 
     * @param map
     *      Map that accumulates the resulting parameters
     * @param data
     *      Input string containing request parameters
     * @param encoding
     *      Encoding to use for converting hex
     * 
     * @exception UnsupportedEncodingException
     *      if the data is malformed
     */
    public static void parseParameters(Map<String, String[]> map, byte[] data,
            String encoding) throws UnsupportedEncodingException {

        if (data != null && data.length > 0) {
            int ix = 0;
            int ox = 0;
            String key = null;
            String value = null;
            while (ix < data.length) {
                byte c = data[ix++];
                switch ((char) c) {
                case '&':
                    value = new String(data, 0, ox, encoding);
                    if (key != null) {
                        putMapEntry(map, key, value);
                        key = null;
                    }
                    ox = 0;
                    break;
                case '=':
                    if (key == null) {
                        key = new String(data, 0, ox, encoding);
                        ox = 0;
                    } else {
                        data[ox++] = c;
                    }
                    break;
                case '+':
                    data[ox++] = (byte) ' ';
                    break;
                case '%':
                    data[ox++] = (byte) ((convertHexDigit(data[ix++]) << 4) + convertHexDigit(data[ix++]));
                    break;
                default:
                    data[ox++] = c;
                }
            }
            // The last value does not end in '&'. So save it now.
            if (key != null) {
                value = new String(data, 0, ox, encoding);
                putMapEntry(map, key, value);
            }
        }

    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/fromcatalina/URLEncoder.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.fromcatalina;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.BitSet;

/**
 * 
 * This class is very similar to the java.net.URLEncoder class.
 * 
 * Unfortunately, with java.net.URLEncoder there is no way to specify to the
 * java.net.URLEncoder which characters should NOT be encoded.
 * 
 * This code was moved from DefaultServlet.java
 * 
 * @author Craig R. McClanahan
 * @author Remy Maucherat
 */
public class URLEncoder {
    protected static final char[] HEXADECIMAL = { '0', '1', '2', '3', '4', '5',
            '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

    // Array containing the safe characters set.
    protected BitSet _safeCharacters = new BitSet(256);

    public URLEncoder() {
        for (char i = 'a'; i <= 'z'; i++) {
            addSafeCharacter(i);
        }
        for (char i = 'A'; i <= 'Z'; i++) {
            addSafeCharacter(i);
        }
        for (char i = '0'; i <= '9'; i++) {
            addSafeCharacter(i);
        }
    }

    public void addSafeCharacter(char c) {
        _safeCharacters.set(c);
    }

    public String encode(String path) {
        int maxBytesPerChar = 10;
        // int caseDiff = ('a' - 'A');
        StringBuilder rewrittenPath = new StringBuilder(path.length());
        ByteArrayOutputStream buf = new ByteArrayOutputStream(maxBytesPerChar);
        OutputStreamWriter writer = null;
        try {
            writer = new OutputStreamWriter(buf, "UTF8");
        } catch (Exception e) {
            e.printStackTrace();
            writer = new OutputStreamWriter(buf);
        }

        for (int i = 0; i < path.length(); i++) {
            int c = (int) path.charAt(i);
            if (_safeCharacters.get(c)) {
                rewrittenPath.append((char) c);
            } else {
                // convert to external encoding before hex conversion
                try {
                    writer.write((char) c);
                    writer.flush();
                } catch (IOException e) {
                    buf.reset();
                    continue;
                }
                byte[] ba = buf.toByteArray();
                for (int j = 0; j < ba.length; j++) {
                    // Converting each byte in the buffer
                    byte toEncode = ba[j];
                    rewrittenPath.append('%');
                    int low = (int) (toEncode & 0x0f);
                    int high = (int) ((toEncode & 0xf0) >> 4);
                    rewrittenPath.append(HEXADECIMAL[high]);
                    rewrittenPath.append(HEXADECIMAL[low]);
                }
                buf.reset();
            }
        }
        return rewrittenPath.toString();
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/fromcatalina/XMLHelper.java
================================================
package com.ejie.x38.webdav.fromcatalina;

import java.util.ArrayList;
import java.util.List;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public class XMLHelper {

    public static Node findSubElement(Node parent, String localName) {
        if (parent == null) {
            return null;
        }
        Node child = parent.getFirstChild();
        while (child != null) {
            if ((child.getNodeType() == Node.ELEMENT_NODE)
                    && (child.getLocalName().equals(localName))) {
                return child;
            }
            child = child.getNextSibling();
        }
        return null;
    }

    public static List<String> getPropertiesFromXML(Node propNode) {
        ArrayList<String> properties;
        properties = new ArrayList<String>();
        NodeList childList = propNode.getChildNodes();

        for (int i = 0; i < childList.getLength(); i++) {
            Node currentNode = childList.item(i);
            if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                String nodeName = currentNode.getLocalName();
                String namespace = currentNode.getNamespaceURI();
                // href is a live property which is handled differently
                properties.add(namespace + ":" + nodeName);
            }
        }
        return properties;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/fromcatalina/XMLWriter.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.fromcatalina;

import java.io.IOException;
import java.io.Writer;
import java.util.Iterator;
import java.util.Map;

/**
 * XMLWriter helper class.
 * 
 * @author <a href="mailto:remm@apache.org">Remy Maucherat</a>
 */
public class XMLWriter {

    // -------------------------------------------------------------- Constants

    /**
     * Opening tag.
     */
    public static final int OPENING = 0;

    /**
     * Closing tag.
     */
    public static final int CLOSING = 1;

    /**
     * Element with no content.
     */
    public static final int NO_CONTENT = 2;

    // ----------------------------------------------------- Instance Variables

    /**
     * Buffer.
     */
    protected StringBuffer _buffer = new StringBuffer();

    /**
     * Writer.
     */
    protected Writer _writer = null;

    /**
     * Namespaces to be declared in the root element
     */
    protected Map<String, String> _namespaces;

    /**
     * Is true until the root element is written
     */
    protected boolean _isRootElement = true;

    // ----------------------------------------------------------- Constructors

    /**
     * Constructor.
     */
    public XMLWriter(Map<String, String> namespaces) {
        _namespaces = namespaces;
    }

    /**
     * Constructor.
     */
    public XMLWriter(Writer writer, Map<String, String> namespaces) {
        _writer = writer;
        _namespaces = namespaces;
    }

    // --------------------------------------------------------- Public Methods

    /**
     * Retrieve generated XML.
     * 
     * @return String containing the generated XML
     */
    @Override
    public String toString() {
        return _buffer.toString();
    }

    /**
     * Write property to the XML.
     * 
     * @param name
     *      Property name
     * @param value
     *      Property value
     */
    public void writeProperty(String name, String value) {
        writeElement(name, OPENING);
        _buffer.append(value);
        writeElement(name, CLOSING);
    }

    /**
     * Write property to the XML.
     * 
     * @param name
     *      Property name
     */
    public void writeProperty(String name) {
        writeElement(name, NO_CONTENT);
    }

    /**
     * Write an element.
     * 
     * @param name
     *      Element name
     * @param type
     *      Element type
     */
    public void writeElement(String name, int type) {
        StringBuffer nsdecl = new StringBuffer();

        if (_isRootElement) {
            for (Iterator<String> iter = _namespaces.keySet().iterator(); iter
                    .hasNext();) {
                String fullName = (String) iter.next();
                String abbrev = (String) _namespaces.get(fullName);
                nsdecl.append(" xmlns:").append(abbrev).append("=\"").append(
                        fullName).append("\"");
            }
            _isRootElement = false;
        }

        int pos = name.lastIndexOf(':');
        if (pos >= 0) {
            // lookup prefix for namespace
            String fullns = name.substring(0, pos);
            String prefix = (String) _namespaces.get(fullns);
            if (prefix == null) {
                // there is no prefix for this namespace
                name = name.substring(pos + 1);
                nsdecl.append(" xmlns=\"").append(fullns).append("\"");
            } else {
                // there is a prefix
                name = prefix + ":" + name.substring(pos + 1);
            }
        } else {
            throw new IllegalArgumentException(
                    "All XML elements must have a namespace");
        }

        switch (type) {
        case OPENING:
            _buffer.append("<");
            _buffer.append(name);
            _buffer.append( nsdecl);
            _buffer.append( ">");
            break;
        case CLOSING:
            _buffer.append("</");
            _buffer.append( name);
            _buffer.append( ">\n");
            break;
        case NO_CONTENT:
        default:
            _buffer.append("<");
            _buffer.append( name);
            _buffer.append( nsdecl);
            _buffer.append( "/>");
            break;
        }
    }

    /**
     * Write text.
     * 
     * @param text
     *      Text to append
     */
    public void writeText(String text) {
        _buffer.append(text);
    }

    /**
     * Write data.
     * 
     * @param data
     *      Data to append
     */
    public void writeData(String data) {
        _buffer.append("<![CDATA[");
        _buffer.append( data);
        _buffer.append( "]]>");
    }

    /**
     * Write XML Header.
     */
    public void writeXMLHeader() {
        _buffer.append("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n");
    }

    /**
     * Send data and reinitializes buffer.
     */
    public void sendData() throws IOException {
        if (_writer != null) {
            _writer.write(_buffer.toString());
            _writer.flush();
            _buffer = new StringBuffer();
        }
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/DataBaseLockDao.java
================================================
package com.ejie.x38.webdav.locking;

import java.util.List;




/**
 * @author UDA
 */

public interface DataBaseLockDao {

	void insert(DataBaseModel webdavLockObj);
	
	void delete(DataBaseModel webdavLockObj);
	
	public List<DataBaseModel> getByPath(String path, Boolean tempLock);
	
	public List<DataBaseModel> getById(String id, Boolean tempLock);

	Boolean isLockedByPath(String path, Boolean tempLock);
	
	Boolean isLockedById(String id, Boolean tempLock);

	void deleteById(String id, Boolean tempLock);
	
	void deleteByPath(String path, Boolean tempLock);
	
	void removeTimeoutLocks(Boolean tempLock);
}




================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/DataBaseLockDaoImpl.java
================================================
package com.ejie.x38.webdav.locking;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Calendar;
import java.util.List;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;



/**
 * @author UDA
 */
@Repository
@Transactional
public class DataBaseLockDaoImpl implements DataBaseLockDao {

	private Logger logger =  LoggerFactory.getLogger(DataBaseLockDaoImpl.class);
	
	private NamedParameterJdbcTemplate jdbcTemplate;
	
	private String lockingTableName;
	
	private RowMapper<DataBaseModel> dataBaseModelRowMapper = new RowMapper<DataBaseModel>() {
		public DataBaseModel mapRow(ResultSet resultSet, int rowNum)
				throws SQLException {

			DataBaseModel dataBaseModel = new DataBaseModel();
			
			dataBaseModel.setId(resultSet.getString("ID"));
			dataBaseModel.setOwner(resultSet.getString("OWNER"));
			dataBaseModel.setPath(resultSet.getString("PATH"));
			dataBaseModel.setLockDepth(Integer.valueOf(resultSet.getString("LOCK_DEPTH")));
			dataBaseModel.setExpiresAt(resultSet.getLong("EXPIRES_AT"));
			dataBaseModel.setExclusiveLock(resultSet.getString("EXCLUSIVE_LOCK").equals("0")?Boolean.FALSE:Boolean.TRUE);
			dataBaseModel.setLockType(resultSet.getString("LOCK_TYPE"));
			dataBaseModel.setChildrenId(resultSet.getString("CHILDREN_ID"));
			dataBaseModel.setParentId(resultSet.getString("PARENT_ID"));
			dataBaseModel.setTempLock(resultSet.getString("TEMP_LOCK").equals("0")?Boolean.FALSE:Boolean.TRUE);
			
			return dataBaseModel;
		}
	};
	
	
	public void insert(DataBaseModel webdavLockObj){
		
		StringBuilder query = new StringBuilder();
		
		query.append("INSERT INTO ").append(lockingTableName).append(" ");
		query.append("(ID, OWNER, PATH, LOCK_DEPTH, EXPIRES_AT, EXCLUSIVE_LOCK, LOCK_TYPE, CHILDREN_ID, PARENT_ID, TEMP_LOCK) ");
		query.append("VALUES (:id, :owner, :path, :lockDepth, :expiresAt, :exclusiveLock, :lockType, :childrenId, :parentId, :tempLock)");
		
		SqlParameterSource beanParameterSource =  new BeanPropertySqlParameterSource(webdavLockObj);
		
		logger.debug("DataBaseLockDaoImpl.insert()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: " +webdavLockObj.toString());
		
		jdbcTemplate.update(query.toString(), beanParameterSource);
		
	}
	
	public void delete(DataBaseModel webdavLockObj){
		
		StringBuilder query = new StringBuilder();
		
		query.append("DELETE FROM ").append(lockingTableName).append(" ");
		query.append("WHERE ID=:id AND OWNER=:owner");
		
		SqlParameterSource beanParameterSource =  new BeanPropertySqlParameterSource(webdavLockObj);
		
		logger.debug("DataBaseLockDaoImpl.delete()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: " +webdavLockObj.toString());
		
		jdbcTemplate.update(query.toString(), beanParameterSource);
		
	}

	@Override
	public List<DataBaseModel> getByPath(String path, Boolean tempLock) {
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT ID, OWNER, PATH, LOCK_DEPTH, EXPIRES_AT, EXCLUSIVE_LOCK, LOCK_TYPE, CHILDREN_ID, PARENT_ID, TEMP_LOCK ");
		query.append(" FROM ").append(lockingTableName);
		query.append(" WHERE PATH = :path AND TEMP_LOCK = :tempLock");
		
		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
		mapParameterSource.addValue("path", path);
		mapParameterSource.addValue("tempLock", tempLock);
		
		logger.debug("DataBaseLockDaoImpl.getByPath()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: {path: " +path + ", tempLock: "+tempLock+"}");
		
		return jdbcTemplate.query(query.toString(), mapParameterSource, dataBaseModelRowMapper);
	}
	
	
	
	@Override
	public List<DataBaseModel> getById(String id, Boolean tempLock) {
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT ID, OWNER, PATH, LOCK_DEPTH, EXPIRES_AT, EXCLUSIVE_LOCK, LOCK_TYPE, CHILDREN_ID, PARENT_ID, TEMP_LOCK ");
		query.append(" FROM ").append(lockingTableName);
		query.append(" WHERE ID = :id AND TEMP_LOCK = :tempLock");
		
		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
		mapParameterSource.addValue("id", id);
		mapParameterSource.addValue("tempLock", tempLock);
		
		logger.debug("DataBaseLockDaoImpl.getById()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: {id: " +id + ", tempLock: "+tempLock+"}");
		
		return jdbcTemplate.query(query.toString(), mapParameterSource, dataBaseModelRowMapper);
	}

	public Boolean isLockedByPath(String path, Boolean tempLock){
		
		StringBuilder query = new StringBuilder();
		query.append("SELECT count(1)");
		query.append(" FROM ").append(lockingTableName);
		query.append(" WHERE PATH = :path AND TEMP_LOCK=:tempLock");
		
		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
		mapParameterSource.addValue("path", path);
		mapParameterSource.addValue("tempLock", tempLock);
		
		logger.debug("DataBaseLockDaoImpl.isLockedByPath()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: {path: " +path + ", tempLock: "+tempLock+"}");
		
		return jdbcTemplate.queryForObject(query.toString(), mapParameterSource, Integer.class)>0;
	}

	@Override
	public Boolean isLockedById(String id, Boolean tempLock) {
		StringBuilder query = new StringBuilder();
		
		query.append("SELECT count(1) ");
		query.append(" FROM ").append(lockingTableName);
		query.append(" WHERE id = :id AND TEMP_LOCK=:tempLock");
		
		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
		mapParameterSource.addValue("id", id);
		mapParameterSource.addValue("tempLock", tempLock);
		
		logger.debug("DataBaseLockDaoImpl.isLockedById()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: {id: " +id+ ", tempLock: "+tempLock+"}");
		
		return jdbcTemplate.queryForObject(query.toString(), mapParameterSource, Integer.class)>0;
	}

	@Override
	public void deleteById(String id, Boolean tempLock) {
		StringBuilder query = new StringBuilder();
		
		query.append("DELETE FROM ").append(lockingTableName); 
		query.append(" WHERE ID=:id AND TEMP_LOCK=:tempLock");
		
		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
		mapParameterSource.addValue("id", id);
		mapParameterSource.addValue("tempLock", tempLock);
		
		logger.debug("DataBaseLockDaoImpl.deleteById()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: {id: " +id+ ", tempLock: "+tempLock+"}");
		
		jdbcTemplate.update(query.toString(), mapParameterSource);
	}
	
	@Override
	public void deleteByPath(String path, Boolean tempLock) {
		StringBuilder query = new StringBuilder();
		
		query.append("DELETE FROM ").append(lockingTableName); 
		query.append(" WHERE PATH=:path AND TEMP_LOCK=:tempLock");
		
		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
		mapParameterSource.addValue("path", path);
		mapParameterSource.addValue("tempLock", tempLock);
		
		logger.debug("DataBaseLockDaoImpl.deleteByPath()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: {path: " +path+ ", tempLock: "+tempLock+"}");
		
		jdbcTemplate.update(query.toString(), mapParameterSource);
	}


	@Override
	public void removeTimeoutLocks(Boolean tempLock) {
		StringBuilder query = new StringBuilder();
		
		query.append("DELETE FROM ").append(lockingTableName); 
		query.append(" WHERE TEMP_LOCK=:tempLock AND EXPIRES_AT < :sysdate");
		
		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
		mapParameterSource.addValue("sysdate", Calendar.getInstance().getTime().getTime());
		mapParameterSource.addValue("tempLock", tempLock);
		
		logger.debug("DataBaseLockDaoImpl.deleteByPath()");
		logger.debug("\tSQL: " +query.toString());
		logger.debug("\tparams: {tempLock: " +tempLock+"}");
		
		jdbcTemplate.update(query.toString(), mapParameterSource);
		
	}

	public void setLockingTableName(String lockingTableName) {
		this.lockingTableName = lockingTableName;
	}
	
	public void setLockingDataSource(DataSource dataSource) {
		this.jdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
	}
}




================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/DataBaseLockService.java
================================================
package com.ejie.x38.webdav.locking;




/**
 * @author UDA
 */

public interface DataBaseLockService {

	
	public DataBaseLockedObject getLockedObjectByPath(String path);
	
	public DataBaseLockedObject getLockedObjectByPath(String path, Boolean temp);
	
	public DataBaseLockedObject getLockedObjectById(String id, Boolean temp);
	
	Boolean isLockedByPath(String path, Boolean tempLock);
	
	Boolean isLockedById(String id, Boolean tempLock);
	
	void addLockedObject(DataBaseLockedObject webdavLockObj);
	
	void unlockObjectById(String id, Boolean tempLock);
	
	void unlockObjectByPath(String path, Boolean tempLock);
	
	void removeTimeoutLocks(Boolean tempLock);
    
}




================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/DataBaseLockServiceImpl.java
================================================
package com.ejie.x38.webdav.locking;

import java.util.List;

import org.springframework.stereotype.Service;



/**
 * @author UDA
 */
@Service(value = "dataBaseLockService")
public class DataBaseLockServiceImpl implements DataBaseLockService {

	private DataBaseLockDao dataBaseLockDao;
	
	@Override
	public DataBaseLockedObject getLockedObjectByPath(String path) {
		return this.getLockedObjectByPath(path, Boolean.TRUE);
	}
	
	@Override
	public DataBaseLockedObject getLockedObjectByPath(String path, Boolean tempLock) {
		 List<DataBaseModel> listDataBaseModel = this.dataBaseLockDao.getByPath(path, tempLock);
		 
		 if (listDataBaseModel.isEmpty()){
			 return null;
		 }else{
			 return new DataBaseLockedObject(listDataBaseModel);
		 }
		 
	}
	
	@Override
	public DataBaseLockedObject getLockedObjectById(String id, Boolean tempLock) {
		List<DataBaseModel> listDataBaseModel = this.dataBaseLockDao.getById(id, tempLock);
		 
		 if (listDataBaseModel.isEmpty()){
			 return null;
		 }else{
			 return new DataBaseLockedObject(listDataBaseModel);
		 }
	}

	@Override
	public Boolean isLockedByPath(String path, Boolean tempLock) {
		return dataBaseLockDao.isLockedByPath(path, tempLock);
	}
	
	@Override
	public Boolean isLockedById(String id, Boolean tempLock) {
		return dataBaseLockDao.isLockedById(id, tempLock);
	}

	@Override
	public void addLockedObject(DataBaseLockedObject webdavLockObj) {
		
		dataBaseLockDao.insert(webdavLockObj.getDataBaseModel());
		
	}

	@Override
	public void unlockObjectById(String id, Boolean tempLock) {
		dataBaseLockDao.deleteById(id, tempLock);
		
	}
	
	@Override
	public void unlockObjectByPath(String path, Boolean tempLock) {
		dataBaseLockDao.deleteByPath(path, tempLock);
		
	}
	

	@Override
	public void removeTimeoutLocks(Boolean tempLock) {
		dataBaseLockDao.removeTimeoutLocks(tempLock);
	}

	public void setDataBaseLockDao(DataBaseLockDao dataBaseLockDao) {
		this.dataBaseLockDao = dataBaseLockDao;
	}
	
	
}




================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/DataBaseLockedObject.java
================================================
package com.ejie.x38.webdav.locking;

import java.util.List;
import java.util.UUID;

/**
 * a helper class for ResourceLocks, represents the Locks
 * 
 * @author re
 * 
 */
public class DataBaseLockedObject extends LockedObject<DataBaseResourceLocks> {

//    private IResourceLocks _resourceLocks;

//    private String _path;

//    private String _id;

    /**
     * Describing the depth of a locked collection. If the locked resource is
     * not a collection, depth is 0 / doesn't matter.
     */
//    protected int _lockDepth;protected

    /**
     * Describing the timeout of a locked object (ms)
     */
//    protected long _expiresAt;

    /**
     * owner of the lock. shared locks can have multiple owners. is null if no
     * owner is present
     */
    // protected String[] _owner = null;
//    protected String[] _owner = null;

    /**
     * children of that lock
     */
    protected DataBaseLockedObject[] _children = null;
//
    protected DataBaseLockedObject _parent = null;

    /**
     * weather the lock is exclusive or not. if owner=null the exclusive value
     * doesn't matter
     */
//    protected boolean _exclusive = false;

    /**
     * weather the lock is a write or read lock
     */
//    protected String _type = null;

    /**
     * @param resLocks
     *      the resourceLocks where locks are stored
     * @param path
     *      the path to the locked object
     * @param temporary
     *      indicates if the LockedObject should be temporary or not
     */
    public DataBaseLockedObject(DataBaseResourceLocks resLocks, String path, boolean temporary) {
        _path = path;
        _id = UUID.randomUUID().toString();
        _resourceLocks = resLocks;
    }
    
    public DataBaseLockedObject(List<DataBaseModel> listdataBaseModel){
    	this(listdataBaseModel.get(0));
    }
    
    public DataBaseLockedObject(DataBaseModel listdataBaseModel){
    	this._id = listdataBaseModel.getId();
    	this._path = listdataBaseModel.getPath();
    	this._exclusive = listdataBaseModel.getExclusiveLock();
    	this._expiresAt = listdataBaseModel.getExpiresAt();
    	this._lockDepth = listdataBaseModel.getLockDepth();
    	this._owner = new String[]{listdataBaseModel.getOwner()};
    	this._type = listdataBaseModel.getLockType();
    }

    /**
     * adds a new owner to a lock
     * 
     * @param owner
     *      string that represents the owner
     * @return true if the owner was added, false otherwise
     */
    public boolean addLockedObjectOwner(String owner) {

        if (_owner == null) {
            _owner = new String[1];
        } else {

            int size = _owner.length;
            String[] newLockObjectOwner = new String[size + 1];

            // check if the owner is already here (that should actually not
            // happen)
            for (int i = 0; i < size; i++) {
                if (_owner[i].equals(owner)) {
                    return false;
                }
            }

            System.arraycopy(_owner, 0, newLockObjectOwner, 0, size);
            _owner = newLockObjectOwner;
        }

        _owner[_owner.length - 1] = owner;
        return true;
    }

    /**
     * tries to remove the owner from the lock
     * 
     * @param owner
     *      string that represents the owner
     */
    public void removeLockedObjectOwner(String owner) {

        try {
            if (_owner != null) {
                int size = _owner.length;
                for (int i = 0; i < size; i++) {
                    // check every owner if it is the requested one
                    if (_owner[i].equals(owner)) {
                        // remove the owner
                        String[] newLockedObjectOwner = new String[size - 1];
                        for (int j = 0; j < (size - 1); j++) {
                            if (j < i) {
                                newLockedObjectOwner[j] = _owner[j];
                            } else {
                                newLockedObjectOwner[j] = _owner[j + 1];
                            }
                        }
                        _owner = newLockedObjectOwner;

                    }
                }
                if (_owner.length == 0) {
                    _owner = null;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("LockedObject.removeLockedObjectOwner()");
            System.out.println(e.toString());
        }
    }

    /**
     * adds a new child lock to this lock
     * 
     * @param newChild
     *      new child
     */
    public void addChild(DataBaseLockedObject newChild) {
        if (_children == null) {
            _children = new DataBaseLockedObject[0];
        }
        int size = _children.length;
        DataBaseLockedObject[] newChildren = new DataBaseLockedObject[size + 1];
        System.arraycopy(_children, 0, newChildren, 0, size);
        newChildren[size] = newChild;
        _children = newChildren;
    }

    /**
     * deletes this Lock object. assumes that it has no children and no owners
     * (does not check this itself)
     * 
     */
    public void removeLockedObject() {
//        if (this != _resourceLocks._root && !this.getPath().equals("/")) {
//
//            int size = _parent._children.length;
//            for (int i = 0; i < size; i++) {
//                if (_parent._children[i].equals(this)) {
//                	DataBaseLockedObject[] newChildren = new DataBaseLockedObject[size - 1];
//                    for (int i2 = 0; i2 < (size - 1); i2++) {
//                        if (i2 < i) {
//                            newChildren[i2] = _parent._children[i2];
//                        } else {
//                            newChildren[i2] = _parent._children[i2 + 1];
//                        }
//                    }
//                    if (newChildren.length != 0) {
//                        _parent._children = newChildren;
//                    } else {
//                        _parent._children = null;
//                    }
//                    break;
//                }
//            }
//
//            // removing from hashtable
//            _resourceLocks._locksByID.remove(getID());
//            _resourceLocks._locks.remove(getPath());
//
//            // now the garbage collector has some work to do
//        }
    }

    /**
     * deletes this Lock object. assumes that it has no children and no owners
     * (does not check this itself)
     * 
     */
    public void removeTempLockedObject() {
    }

    /**
     * checks if a lock of the given exclusivity can be placed, only considering
     * children up to "depth"
     * 
     * @param exclusive
     *      wheather the new lock should be exclusive
     * @param depth
     *      the depth to which should be checked
     * @return true if the lock can be placed
     */
    public boolean checkLocks(boolean exclusive, int depth) {
        if (checkParents(exclusive) && checkChildren(exclusive, depth)) {
            return true;
        }
        return false;
    }

    /**
     * helper of checkLocks(). looks if the parents are locked
     * 
     * @param exclusive
     *      wheather the new lock should be exclusive
     * @return true if no locks at the parent path are forbidding a new lock
     */
    private boolean checkParents(boolean exclusive) {
        if (_path.equals("/")) {
            return true;
        } else {
            if (_owner == null) {
                // no owner, checking parents
                return _parent != null && _parent.checkParents(exclusive);
            } else {
                // there already is a owner
                return !(_exclusive || exclusive)
                        && _parent.checkParents(exclusive);
            }
        }
    }

    /**
     * helper of checkLocks(). looks if the children are locked
     * 
     * @param exclusive
     *      wheather the new lock should be exclusive
     * @return true if no locks at the children paths are forbidding a new lock
     * @param depth
     *      depth
     */
    private boolean checkChildren(boolean exclusive, int depth) {
        if (_children == null) {
            // a file

            return _owner == null || !(_exclusive || exclusive);
        } else {
            // a folder

            if (_owner == null) {
                // no owner, checking children

                if (depth != 0) {
                    boolean canLock = true;
                    int limit = _children.length;
                    for (int i = 0; i < limit; i++) {
                        if (!_children[i].checkChildren(exclusive, depth - 1)) {
                            canLock = false;
                        }
                    }
                    return canLock;
                } else {
                    // depth == 0 -> we don't care for children
                    return true;
                }
            } else {
                // there already is a owner
                return !(_exclusive || exclusive);
            }
        }

    }

    /**
     * Sets a new timeout for the LockedObject
     * 
     * @param timeout
     */
    public void refreshTimeout(int timeout) {
        _expiresAt = System.currentTimeMillis() + (timeout * 1000);
    }

    /**
     * Gets the timeout for the LockedObject
     * 
     * @return timeout
     */
    public long getTimeoutMillis() {
        return (_expiresAt - System.currentTimeMillis());
    }

    /**
     * Return true if the lock has expired.
     * 
     * @return true if timeout has passed
     */
    public boolean hasExpired() {
        if (_expiresAt != 0) {
            return (System.currentTimeMillis() > _expiresAt);
        } else {
            return true;
        }
    }

    /**
     * Gets the LockID (locktoken) for the LockedObject
     * 
     * @return locktoken
     */
    public String getID() {
        return _id;
    }

    /**
     * Gets the owners for the LockedObject
     * 
     * @return owners
     */
    public String[] getOwner() {
        return _owner;
    }

    /**
     * Gets the path for the LockedObject
     * 
     * @return path
     */
    public String getPath() {
        return _path;
    }

    /**
     * Sets the exclusivity for the LockedObject
     * 
     * @param exclusive
     */
    public void setExclusive(boolean exclusive) {
        _exclusive = exclusive;
    }

    /**
     * Gets the exclusivity for the LockedObject
     * 
     * @return exclusivity
     */
    public boolean isExclusive() {
        return _exclusive;
    }

    /**
     * Gets the exclusivity for the LockedObject
     * 
     * @return exclusivity
     */
    public boolean isShared() {
        return !_exclusive;
    }

    /**
     * Gets the type of the lock
     * 
     * @return type
     */
    public String getType() {
        return _type;
    }

    /**
     * Gets the depth of the lock
     * 
     * @return depth
     */
    public int getLockDepth() {
        return _lockDepth;
    }

    public DataBaseModel getDataBaseModel(){
    	DataBaseModel dataBaseModel = new DataBaseModel();
    	
    	dataBaseModel.setId(this._id);
    	dataBaseModel.setPath(this._path);
    	dataBaseModel.setExclusiveLock(this._exclusive);
    	dataBaseModel.setLockDepth(this._lockDepth);
    	dataBaseModel.setExpiresAt(this._expiresAt);
    	dataBaseModel.setLockType(this._type);
    	if(this._owner!= null && this._owner.length>0){
    		dataBaseModel.setOwner(this._owner[0]);
    	}
    	if ("read".equals(this._type)){
    		dataBaseModel.setTempLock(Boolean.TRUE);
    	}else{
    		dataBaseModel.setTempLock(Boolean.FALSE);
    	}
    	
    	return dataBaseModel;
    }

	@Override
	public boolean equals(Object obj) {
		
		if (obj instanceof DataBaseLockedObject){
			DataBaseLockedObject dblo = (DataBaseLockedObject)obj;
			
			if (this._id.equals(dblo.getID()) 
					&& this._path.equals(dblo.getPath())){
				return true;
			}
		}
		
		return false;
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/DataBaseModel.java
================================================
package com.ejie.x38.webdav.locking;


/**
 * @author UDA
 */
public class DataBaseModel {

	private String id;
	
	private String owner;
	
	private String path;
	
	private Integer lockDepth;
	
	private Long expiresAt;
	
	private Boolean exclusiveLock;
	
	private String lockType;
	
	private String childrenId;
	
	private String parentId;
	
	private Boolean tempLock;
	
	public DataBaseModel() {
		super();
	}

	public DataBaseModel(String id, String owner, String path,
			Integer lockDepth, Long expiresAt, Boolean exclusive, String type,
			String children, String parent, Boolean tempLock) {
		super();
		this.id = id;
		this.owner = owner;
		this.path = path;
		this.lockDepth = lockDepth;
		this.expiresAt = expiresAt;
		this.exclusiveLock = exclusive;
		this.lockType = type;
		this.childrenId = children;
		this.parentId = parent;
		this.tempLock = tempLock;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getOwner() {
		return owner;
	}

	public void setOwner(String owner) {
		this.owner = owner;
	}

	public String getPath() {
		return path;
	}

	public void setPath(String path) {
		this.path = path;
	}

	public Integer getLockDepth() {
		return lockDepth;
	}

	public void setLockDepth(Integer lockDepth) {
		this.lockDepth = lockDepth;
	}

	public Long getExpiresAt() {
		return expiresAt;
	}

	public void setExpiresAt(Long expiresAt) {
		this.expiresAt = expiresAt;
	}

	public Boolean getExclusiveLock() {
		return exclusiveLock;
	}

	public void setExclusiveLock(Boolean exclusiveLock) {
		this.exclusiveLock = exclusiveLock;
	}

	public String getLockType() {
		return lockType;
	}

	public void setLockType(String lockType) {
		this.lockType = lockType;
	}

	public String getChildrenId() {
		return childrenId;
	}

	public void setChildrenId(String childrenId) {
		this.childrenId = childrenId;
	}

	public String getParentId() {
		return parentId;
	}

	public void setParentId(String parentId) {
		this.parentId = parentId;
	}

	public Boolean getTempLock() {
		return tempLock;
	}

	public void setTempLock(Boolean tempLock) {
		this.tempLock = tempLock;
	}

	@Override
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(this.getClass().getName()).append(" Object {");
		result.append(" [ id: ").append(this.id).append(" ]");
		result.append(" [ owner: ").append(this.owner).append(" ]");
		result.append(" [ path: ").append(this.path).append(" ]");
		result.append(" [ lockDepth: ").append(this.lockDepth).append(" ]");
		result.append(" [ expiresAt: ").append(this.expiresAt).append(" ]");
		result.append(" [ exclusiveLock: ").append(this.exclusiveLock).append(" ]");
		result.append(" [ lockType: ").append(this.lockType).append(" ]");
		result.append(" [ childrenId: ").append(this.childrenId).append(" ]");
		result.append(" [ lockDepth: ").append(this.lockDepth).append(" ]");
		result.append(" [ parentId: ").append(this.parentId).append(" ]");
		result.append(" [ tempLock: ").append(this.tempLock).append(" ]");
		result.append("}");
		return result.toString();
	}
	
}




================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/DataBaseResourceLocks.java
================================================
/*
 * Copyright 2005-2006 webdav-servlet group.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.locking;

import org.springframework.stereotype.Component;
import org.springframework.web.context.support.SpringBeanAutowiringSupport;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.exceptions.LockFailedException;

/**
 * 
 * @author UDA
 */
@Component(value="dataBaseResourceLocks")
public class DataBaseResourceLocks extends SpringBeanAutowiringSupport implements IResourceLocks {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DataBaseResourceLocks.class);

    private boolean _temporary = true;

    protected DataBaseLockService dataBaseLockService;
    
    public synchronized boolean lock(ITransaction transaction, String path,
            String owner, boolean exclusive, int depth, int timeout,
            boolean temporary) throws LockFailedException {

    	LOG.debug("DataBaseResourceLocks.lock()");
    	
        DataBaseLockedObject lo = null;
        if (temporary) {
            lo = generateTempLockedObjects(transaction, path);
            lo._type = "read";
        } else {
            lo = generateLockedObjects(transaction, path);
            lo._type = "write";
        }
        
        if (lo.checkLocks(exclusive, depth)) {

            lo._exclusive = exclusive;
            lo._lockDepth = depth;
            lo._expiresAt = System.currentTimeMillis() + (timeout * 1000);
            if (lo._parent != null) {
                lo._parent._expiresAt = lo._expiresAt;
//                if (lo._parent.equals(_root)) {
//                if (lo._parent.getPath().equals("/")) {
//                	DataBaseLockedObject rootLo = getLockedObjectByPath(transaction,
//                            "/");
//                    rootLo._expiresAt = lo._expiresAt;
//                } else if (lo._parent.equals(_tempRoot)) {
//                } else if (lo._parent.getPath().equals("/")) {
//                	DataBaseLockedObject tempRootLo = getTempLockedObjectByPath(
//                            transaction, "/");
//                    tempRootLo._expiresAt = lo._expiresAt;
//                }
            }
            if (lo.addLockedObjectOwner(owner)) {
            	dataBaseLockService.addLockedObject(lo);
                return true;
            } else {
                LOG.trace("Couldn't set owner \"" + owner
                        + "\" to resource at '" + path + "'");
                return false;
            }
        } else {
            LOG.trace("Lock resource at " + path + " failed because"
                    + "\na parent or child resource is currently locked");
            return false;
        }
    	
    }

    public synchronized boolean unlock(ITransaction transaction, String id,
            String owner) {

    	LOG.debug("DataBaseResourceLocks.unlock()");
    	
    	if (dataBaseLockService.isLockedById(id, Boolean.FALSE)){
    		dataBaseLockService.unlockObjectById(id, Boolean.FALSE);
    	}
    	
    	this.checkTimeouts(transaction,  Boolean.FALSE);
    	
    	return true;
    }

    public synchronized void unlockTemporaryLockedObjects(
            ITransaction transaction, String path, String owner) {
    	
    	LOG.debug("DataBaseResourceLocks.unlockTemporaryLockedObjects()");
    	
    	if (dataBaseLockService.isLockedByPath(path, Boolean.TRUE)){
    		dataBaseLockService.unlockObjectByPath(path, Boolean.TRUE);
    	}
    	
    	this.checkTimeouts(transaction,  Boolean.TRUE);
    }

    public void checkTimeouts(ITransaction transaction, boolean temporary) {
    	LOG.debug("DataBaseResourceLocks.checkTimeouts()");
    	
    	dataBaseLockService.removeTimeoutLocks(temporary);
    }
    
    public boolean checkLocks(boolean exclusive, int depth) {
    	LOG.debug("DataBaseResourceLocks.checkLocks()");
    	
       return false;
    }

    public boolean exclusiveLock(ITransaction transaction, String path,
            String owner, int depth, int timeout) throws LockFailedException {
    	
    	LOG.debug("DataBaseResourceLocks.exclusiveLock()");
    	
        return lock(transaction, path, owner, true, depth, timeout, false);
    }

    public boolean sharedLock(ITransaction transaction, String path,
            String owner, int depth, int timeout) throws LockFailedException {
    	
    	LOG.debug("DataBaseResourceLocks.sharedLock()");
    	
        return lock(transaction, path, owner, false, depth, timeout, false);
    }

    public DataBaseLockedObject getLockedObjectByID(ITransaction transaction, String id) {
    	LOG.debug("DataBaseResourceLocks.getLockedObjectByID()");
    	
    	DataBaseLockedObject lockedObject = dataBaseLockService.getLockedObjectById(id, Boolean.FALSE);
    	if (lockedObject!=null) {
            return lockedObject;
        } else {
            return null;
        }
    }

    public DataBaseLockedObject getLockedObjectByPath(ITransaction transaction,
            String path) {
    	
    	LOG.debug("DataBaseResourceLocks.getLockedObjectByPath()");
    	
    	DataBaseLockedObject lockedObject = dataBaseLockService.getLockedObjectByPath(path, Boolean.FALSE);
    	
        if (lockedObject!=null) {
            return lockedObject;
        } else {
            return null;
        }
    }
    
    
    public DataBaseLockedObject getTempLockedObjectByID(ITransaction transaction,
            String id) {
    	LOG.debug("DataBaseResourceLocks.getTempLockedObjectById()");
    	
    	DataBaseLockedObject lockedObject = dataBaseLockService.getLockedObjectById(id, Boolean.TRUE);
    	
        if (lockedObject!=null) {
            return lockedObject;
        } else {
            return null;
        }
    }

    public DataBaseLockedObject getTempLockedObjectByPath(ITransaction transaction,
            String path) {
    	LOG.debug("DataBaseResourceLocks.getTempLockedObjectByPath()");
    	
    	DataBaseLockedObject lockedObject = dataBaseLockService.getLockedObjectByPath(path, Boolean.TRUE);
    	
        if (lockedObject!=null) {
            return lockedObject;
        } else {
            return null;
        }
    	
    }
    
    

    /**
     * generates real LockedObjects for the resource at path and its parent
     * folders. does not create new LockedObjects if they already exist
     * 
     * @param transaction
     * @param path
     *      path to the (new) LockedObject
     * @return the LockedObject for path.
     */
    private DataBaseLockedObject generateLockedObjects(ITransaction transaction,
            String path) {
    	LOG.debug("DataBaseResourceLocks.generateLockedObjects()");
    	
    	if (!dataBaseLockService.isLockedByPath(path, Boolean.FALSE) ){
    		DataBaseLockedObject returnObject = new DataBaseLockedObject(this, path,
                    !_temporary);
            String parentPath = getParentPath(path);
            if (parentPath != null && !"/".equals(path)) {
            	DataBaseLockedObject parentLockedObject = generateLockedObjects(
                        transaction, parentPath);
                parentLockedObject.addChild(returnObject);
                returnObject._parent = parentLockedObject;
            }
            return returnObject;
        } else {
            // there is already a LockedObject on the specified path
            return dataBaseLockService.getLockedObjectByPath(path, Boolean.FALSE);
        }
    }

    /**
     * generates temporary LockedObjects for the resource at path and its parent
     * folders. does not create new LockedObjects if they already exist
     * 
     * @param transaction
     * @param path
     *      path to the (new) LockedObject
     * @return the LockedObject for path.
     */
    private DataBaseLockedObject generateTempLockedObjects(ITransaction transaction,
            String path) {
    	LOG.debug("DataBaseResourceLocks.generateTempLockedObjects()");
    	
    	
    	if (!dataBaseLockService.isLockedByPath(path, Boolean.TRUE) ){
    		DataBaseLockedObject returnObject = new DataBaseLockedObject(this, path, _temporary);
            String parentPath = getParentPath(path);
            if (parentPath != null && !"/".equals(path)) {
            	DataBaseLockedObject parentLockedObject = generateTempLockedObjects(
                        transaction, parentPath);
                parentLockedObject.addChild(returnObject);
                returnObject._parent = parentLockedObject;
            }
            return returnObject;
        } else {
//             there is already a LockedObject on the specified path
            return dataBaseLockService.getLockedObjectByPath(path, _temporary);
        }
    	

    }
    

    /**
     * creates the parent path from the given path by removing the last '/' and
     * everything after that
     * 
     * @param path
     *      the path
     * @return parent path
     */
    private String getParentPath(String path) {
    	LOG.debug("DataBaseResourceLocks.getParentPath()");
        int slash = path.lastIndexOf('/');
        if (slash == -1) {
            return null;
        } else {
            if (slash == 0) {
                // return "root" if parent path is empty string
                return "/";
            } else {
                return path.substring(0, slash);
            }
        }
    }

	public void setDataBaseLockService(DataBaseLockService dataBaseLockService) {
		this.dataBaseLockService = dataBaseLockService;
	}
 }


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/IResourceLocks.java
================================================
package com.ejie.x38.webdav.locking;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.exceptions.LockFailedException;

public interface IResourceLocks {

    /**
     * Tries to lock the resource at "path".
     * 
     * @param transaction
     * @param path
     *      what resource to lock
     * @param owner
     *      the owner of the lock
     * @param exclusive
     *      if the lock should be exclusive (or shared)
     * @param depth
     *      depth
     * @param timeout
     *      Lock Duration in seconds.
     * @return true if the resource at path was successfully locked, false if an
     *  existing lock prevented this
     * @throws LockFailedException
     */
    boolean lock(ITransaction transaction, String path, String owner,
            boolean exclusive, int depth, int timeout, boolean temporary)
            throws LockFailedException;

    /**
     * Unlocks all resources at "path" (and all subfolders if existing)<p/> that
     * have the same owner.
     * 
     * @param transaction
     * @param id
     *      id to the resource to unlock
     * @param owner
     *      who wants to unlock
     */
    boolean unlock(ITransaction transaction, String id, String owner);

    /**
     * Unlocks all resources at "path" (and all subfolders if existing)<p/> that
     * have the same owner.
     * 
     * @param transaction
     * @param path
     *      what resource to unlock
     * @param owner
     *      who wants to unlock
     */
    void unlockTemporaryLockedObjects(ITransaction transaction, String path,
            String owner);

    /**
     * Deletes LockedObjects, where timeout has reached.
     * 
     * @param transaction
     * @param temporary
     *      Check timeout on temporary or real locks
     */
    void checkTimeouts(ITransaction transaction, boolean temporary);

    /**
     * Tries to lock the resource at "path" exclusively.
     * 
     * @param transaction
     *      Transaction
     * @param path
     *      what resource to lock
     * @param owner
     *      the owner of the lock
     * @param depth
     *      depth
     * @param timeout
     *      Lock Duration in seconds.
     * @return true if the resource at path was successfully locked, false if an
     *  existing lock prevented this
     * @throws LockFailedException
     */
    boolean exclusiveLock(ITransaction transaction, String path, String owner,
            int depth, int timeout) throws LockFailedException;

    /**
     * Tries to lock the resource at "path" shared.
     * 
     * @param transaction
     *      Transaction
     * @param path
     *      what resource to lock
     * @param owner
     *      the owner of the lock
     * @param depth
     *      depth
     * @param timeout
     *      Lock Duration in seconds.
     * @return true if the resource at path was successfully locked, false if an
     *  existing lock prevented this
     * @throws LockFailedException
     */
    boolean sharedLock(ITransaction transaction, String path, String owner,
            int depth, int timeout) throws LockFailedException;

    /**
     * Gets the LockedObject corresponding to specified id.
     * 
     * @param transaction
     * @param id
     *      LockToken to requested resource
     * @return LockedObject or null if no LockedObject on specified path exists
     */
    LockedObject<? extends IResourceLocks> getLockedObjectByID(ITransaction transaction, String id);

    /**
     * Gets the LockedObject on specified path.
     * 
     * @param transaction
     * @param path
     *      Path to requested resource
     * @return LockedObject or null if no LockedObject on specified path exists
     */
    LockedObject<? extends IResourceLocks> getLockedObjectByPath(ITransaction transaction, String path);

    /**
     * Gets the LockedObject corresponding to specified id (locktoken).
     * 
     * @param transaction
     * @param id
     *      LockToken to requested resource
     * @return LockedObject or null if no LockedObject on specified path exists
     */
    LockedObject<? extends IResourceLocks> getTempLockedObjectByID(ITransaction transaction, String id);

    /**
     * Gets the LockedObject on specified path.
     * 
     * @param transaction
     * @param path
     *      Path to requested resource
     * @return LockedObject or null if no LockedObject on specified path exists
     */
    LockedObject<? extends IResourceLocks> getTempLockedObjectByPath(ITransaction transaction, String path);

    
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/LockedObject.java
================================================
package com.ejie.x38.webdav.locking;


/**
 * a helper class for ResourceLocks, represents the Locks
 * 
 * @author re
 * 
 */
public abstract class LockedObject <T extends IResourceLocks> {

    protected T _resourceLocks;

    protected String _path;

    protected String _id;

    /**
     * Describing the depth of a locked collection. If the locked resource is
     * not a collection, depth is 0 / doesn't matter.
     */
    protected int _lockDepth;

    /**
     * Describing the timeout of a locked object (ms)
     */
    protected long _expiresAt;

    /**
     * owner of the lock. shared locks can have multiple owners. is null if no
     * owner is present
     */
    // protected String[] _owner = null;
    protected String[] _owner = null;

    /**
     * children of that lock
     */
    protected LockedObject<T>[] _children = null;

    protected LockedObject<T> _parent = null;

    /**
     * weather the lock is exclusive or not. if owner=null the exclusive value
     * doesn't matter
     */
    protected boolean _exclusive = false;

    /**
     * weather the lock is a write or read lock
     */
    protected String _type = null;

    /**
     * @param resLocks
     *      the resourceLocks where locks are stored
     * @param path
     *      the path to the locked object
     * @param temporary
     *      indicates if the LockedObject should be temporary or not
     */
//    public LockedObject(ResourceLocks resLocks, String path, boolean temporary) {
//        _path = path;
//        _id = UUID.randomUUID().toString();
//        _resourceLocks = resLocks;
//
//        if (!temporary) {
//            _resourceLocks._locks.put(path, this);
//            _resourceLocks._locksByID.put(_id, this);
//        } else {
//            _resourceLocks._tempLocks.put(path, this);
//            _resourceLocks._tempLocksByID.put(_id, this);
//        }
//        _resourceLocks._cleanupCounter++;
//    }

    /**
     * adds a new owner to a lock
     * 
     * @param owner
     *      string that represents the owner
     * @return true if the owner was added, false otherwise
     */
    public boolean addLockedObjectOwner(String owner) {

        if (_owner == null) {
            _owner = new String[1];
        } else {

            int size = _owner.length;
            String[] newLockObjectOwner = new String[size + 1];

            // check if the owner is already here (that should actually not
            // happen)
            for (int i = 0; i < size; i++) {
                if (_owner[i].equals(owner)) {
                    return false;
                }
            }

            System.arraycopy(_owner, 0, newLockObjectOwner, 0, size);
            _owner = newLockObjectOwner;
        }

        _owner[_owner.length - 1] = owner;
        return true;
    }

    /**
     * tries to remove the owner from the lock
     * 
     * @param owner
     *      string that represents the owner
     */
    public void removeLockedObjectOwner(String owner) {

        try {
            if (_owner != null) {
                int size = _owner.length;
                for (int i = 0; i < size; i++) {
                    // check every owner if it is the requested one
                    if (_owner[i].equals(owner)) {
                        // remove the owner
                        String[] newLockedObjectOwner = new String[size - 1];
                        for (int j = 0; j < (size - 1); j++) {
                            if (j < i) {
                                newLockedObjectOwner[j] = _owner[j];
                            } else {
                                newLockedObjectOwner[j] = _owner[j + 1];
                            }
                        }
                        _owner = newLockedObjectOwner;

                    }
                }
                if (_owner.length == 0) {
                    _owner = null;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("LockedObject.removeLockedObjectOwner()");
            System.out.println(e.toString());
        }
    }

    /**
     * deletes this Lock object. assumes that it has no children and no owners
     * (does not check this itself)
     * 
     */
    public abstract void removeLockedObject();

    /**
     * deletes this Lock object. assumes that it has no children and no owners
     * (does not check this itself)
     * 
     */
    public abstract void removeTempLockedObject();



    /**
     * Sets a new timeout for the LockedObject
     * 
     * @param timeout
     */
    public void refreshTimeout(int timeout) {
        _expiresAt = System.currentTimeMillis() + (timeout * 1000);
    }

    /**
     * Gets the timeout for the LockedObject
     * 
     * @return timeout
     */
    public long getTimeoutMillis() {
        return (_expiresAt - System.currentTimeMillis());
    }

    /**
     * Return true if the lock has expired.
     * 
     * @return true if timeout has passed
     */
    public boolean hasExpired() {
        if (_expiresAt != 0) {
            return (System.currentTimeMillis() > _expiresAt);
        } else {
            return true;
        }
    }

    /**
     * Gets the LockID (locktoken) for the LockedObject
     * 
     * @return locktoken
     */
    public String getID() {
        return _id;
    }

    /**
     * Gets the owners for the LockedObject
     * 
     * @return owners
     */
    public String[] getOwner() {
        return _owner;
    }

    /**
     * Gets the path for the LockedObject
     * 
     * @return path
     */
    public String getPath() {
        return _path;
    }

    /**
     * Sets the exclusivity for the LockedObject
     * 
     * @param exclusive
     */
    public void setExclusive(boolean exclusive) {
        _exclusive = exclusive;
    }

    /**
     * Gets the exclusivity for the LockedObject
     * 
     * @return exclusivity
     */
    public boolean isExclusive() {
        return _exclusive;
    }

    /**
     * Gets the exclusivity for the LockedObject
     * 
     * @return exclusivity
     */
    public boolean isShared() {
        return !_exclusive;
    }

    /**
     * Gets the type of the lock
     * 
     * @return type
     */
    public String getType() {
        return _type;
    }

    /**
     * Gets the depth of the lock
     * 
     * @return depth
     */
    public int getLockDepth() {
        return _lockDepth;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/MemoryLockedObject.java
================================================
package com.ejie.x38.webdav.locking;

import java.util.UUID;

/**
 * a helper class for ResourceLocks, represents the Locks
 * 
 * @author re
 * 
 */
public class MemoryLockedObject extends LockedObject<MemoryResourceLocks> {


    /**
     * Describing the depth of a locked collection. If the locked resource is
     * not a collection, depth is 0 / doesn't matter.
     */
    protected int _lockDepth;

    /**
     * Describing the timeout of a locked object (ms)
     */
    protected long _expiresAt;

    /**
     * owner of the lock. shared locks can have multiple owners. is null if no
     * owner is present
     */
    // protected String[] _owner = null;
    protected String[] _owner = null;

    /**
     * children of that lock
     */
    protected MemoryLockedObject[] _children = null;

    protected MemoryLockedObject _parent = null;

    /**
     * weather the lock is exclusive or not. if owner=null the exclusive value
     * doesn't matter
     */
    protected boolean _exclusive = false;

    /**
     * weather the lock is a write or read lock
     */
    protected String _type = null;

    /**
     * @param resLocks
     *      the resourceLocks where locks are stored
     * @param path
     *      the path to the locked object
     * @param temporary
     *      indicates if the LockedObject should be temporary or not
     */
    public MemoryLockedObject(MemoryResourceLocks resLocks, String path, boolean temporary) {
        _path = path;
        _id = UUID.randomUUID().toString();
        _resourceLocks = resLocks;

        if (!temporary) {
            _resourceLocks.get_locks().put(path, this);
            _resourceLocks.get_locksByID().put(_id, this);
        } else {
        	_resourceLocks.get_tempLocks().put(path, this);
        	_resourceLocks.get_tempLocksByID().put(_id, this);
        }
        _resourceLocks.addCleanupCounter();
    }

    /**
     * adds a new owner to a lock
     * 
     * @param owner
     *      string that represents the owner
     * @return true if the owner was added, false otherwise
     */
    public boolean addLockedObjectOwner(String owner) {

        if (_owner == null) {
            _owner = new String[1];
        } else {

            int size = _owner.length;
            String[] newLockObjectOwner = new String[size + 1];

            // check if the owner is already here (that should actually not
            // happen)
            for (int i = 0; i < size; i++) {
                if (_owner[i].equals(owner)) {
                    return false;
                }
            }

            System.arraycopy(_owner, 0, newLockObjectOwner, 0, size);
            _owner = newLockObjectOwner;
        }

        _owner[_owner.length - 1] = owner;
        return true;
    }

    /**
     * tries to remove the owner from the lock
     * 
     * @param owner
     *      string that represents the owner
     */
    public void removeLockedObjectOwner(String owner) {

        try {
            if (_owner != null) {
                int size = _owner.length;
                for (int i = 0; i < size; i++) {
                    // check every owner if it is the requested one
                    if (_owner[i].equals(owner)) {
                        // remove the owner
                        String[] newLockedObjectOwner = new String[size - 1];
                        for (int j = 0; j < (size - 1); j++) {
                            if (j < i) {
                                newLockedObjectOwner[j] = _owner[j];
                            } else {
                                newLockedObjectOwner[j] = _owner[j + 1];
                            }
                        }
                        _owner = newLockedObjectOwner;

                    }
                }
                if (_owner.length == 0) {
                    _owner = null;
                }
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("LockedObject.removeLockedObjectOwner()");
            System.out.println(e.toString());
        }
    }

    /**
     * adds a new child lock to this lock
     * 
     * @param newChild
     *      new child
     */
    public void addChild(MemoryLockedObject newChild) {
        if (_children == null) {
            _children = new MemoryLockedObject[0];
        }
        int size = _children.length;
        MemoryLockedObject[] newChildren = new MemoryLockedObject[size + 1];
        System.arraycopy(_children, 0, newChildren, 0, size);
        newChildren[size] = newChild;
        _children = newChildren;
    }

    /**
     * deletes this Lock object. assumes that it has no children and no owners
     * (does not check this itself)
     * 
     */
    public void removeLockedObject() {
        if (this != _resourceLocks._root && !this.getPath().equals("/")) {

            int size = _parent._children.length;
            for (int i = 0; i < size; i++) {
                if (_parent._children[i].equals(this)) {
                	MemoryLockedObject[] newChildren = new MemoryLockedObject[size - 1];
                    for (int i2 = 0; i2 < (size - 1); i2++) {
                        if (i2 < i) {
                            newChildren[i2] = _parent._children[i2];
                        } else {
                            newChildren[i2] = _parent._children[i2 + 1];
                        }
                    }
                    if (newChildren.length != 0) {
                        _parent._children = newChildren;
                    } else {
                        _parent._children = null;
                    }
                    break;
                }
            }

            // removing from hashtable
            _resourceLocks._locksByID.remove(getID());
            _resourceLocks._locks.remove(getPath());

            // now the garbage collector has some work to do
        }
    }

    /**
     * deletes this Lock object. assumes that it has no children and no owners
     * (does not check this itself)
     * 
     */
    public void removeTempLockedObject() {
        if (this != _resourceLocks._tempRoot) {
            // removing from tree
            if (_parent != null && _parent._children != null) {
                int size = _parent._children.length;
                for (int i = 0; i < size; i++) {
                    if (_parent._children[i].equals(this)) {
                    	MemoryLockedObject[] newChildren = new MemoryLockedObject[size - 1];
                        for (int i2 = 0; i2 < (size - 1); i2++) {
                            if (i2 < i) {
                                newChildren[i2] = _parent._children[i2];
                            } else {
                                newChildren[i2] = _parent._children[i2 + 1];
                            }
                        }
                        if (newChildren.length != 0) {
                            _parent._children = newChildren;
                        } else {
                            _parent._children = null;
                        }
                        break;
                    }
                }

                // removing from hashtable
                _resourceLocks._tempLocksByID.remove(getID());
                _resourceLocks._tempLocks.remove(getPath());

                // now the garbage collector has some work to do
            }
        }
    }

    /**
     * checks if a lock of the given exclusivity can be placed, only considering
     * children up to "depth"
     * 
     * @param exclusive
     *      wheather the new lock should be exclusive
     * @param depth
     *      the depth to which should be checked
     * @return true if the lock can be placed
     */
    public boolean checkLocks(boolean exclusive, int depth) {
        if (checkParents(exclusive) && checkChildren(exclusive, depth)) {
            return true;
        }
        return false;
    }

    /**
     * helper of checkLocks(). looks if the parents are locked
     * 
     * @param exclusive
     *      wheather the new lock should be exclusive
     * @return true if no locks at the parent path are forbidding a new lock
     */
    protected boolean checkParents(boolean exclusive) {
        if (_path.equals("/")) {
            return true;
        } else {
            if (_owner == null) {
                // no owner, checking parents
                return _parent != null && _parent.checkParents(exclusive);
            } else {
                // there already is a owner
                return !(_exclusive || exclusive)
                        && _parent.checkParents(exclusive);
            }
        }
    }

    /**
     * helper of checkLocks(). looks if the children are locked
     * 
     * @param exclusive
     *      wheather the new lock should be exclusive
     * @return true if no locks at the children paths are forbidding a new lock
     * @param depth
     *      depth
     */
    protected boolean checkChildren(boolean exclusive, int depth) {
        if (_children == null) {
            // a file

            return _owner == null || !(_exclusive || exclusive);
        } else {
            // a folder

            if (_owner == null) {
                // no owner, checking children

                if (depth != 0) {
                    boolean canLock = true;
                    int limit = _children.length;
                    for (int i = 0; i < limit; i++) {
                        if (!_children[i].checkChildren(exclusive, depth - 1)) {
                            canLock = false;
                        }
                    }
                    return canLock;
                } else {
                    // depth == 0 -> we don't care for children
                    return true;
                }
            } else {
                // there already is a owner
                return !(_exclusive || exclusive);
            }
        }

    }

    /**
     * Sets a new timeout for the LockedObject
     * 
     * @param timeout
     */
    public void refreshTimeout(int timeout) {
        _expiresAt = System.currentTimeMillis() + (timeout * 1000);
    }

    /**
     * Gets the timeout for the LockedObject
     * 
     * @return timeout
     */
    public long getTimeoutMillis() {
        return (_expiresAt - System.currentTimeMillis());
    }

    /**
     * Return true if the lock has expired.
     * 
     * @return true if timeout has passed
     */
    public boolean hasExpired() {
        if (_expiresAt != 0) {
            return (System.currentTimeMillis() > _expiresAt);
        } else {
            return true;
        }
    }

    /**
     * Gets the LockID (locktoken) for the LockedObject
     * 
     * @return locktoken
     */
    public String getID() {
        return _id;
    }

    /**
     * Gets the owners for the LockedObject
     * 
     * @return owners
     */
    public String[] getOwner() {
        return _owner;
    }

    /**
     * Gets the path for the LockedObject
     * 
     * @return path
     */
    public String getPath() {
        return _path;
    }

    /**
     * Sets the exclusivity for the LockedObject
     * 
     * @param exclusive
     */
    public void setExclusive(boolean exclusive) {
        _exclusive = exclusive;
    }

    /**
     * Gets the exclusivity for the LockedObject
     * 
     * @return exclusivity
     */
    public boolean isExclusive() {
        return _exclusive;
    }

    /**
     * Gets the exclusivity for the LockedObject
     * 
     * @return exclusivity
     */
    public boolean isShared() {
        return !_exclusive;
    }

    /**
     * Gets the type of the lock
     * 
     * @return type
     */
    public String getType() {
        return _type;
    }

    /**
     * Gets the depth of the lock
     * 
     * @return depth
     */
    public int getLockDepth() {
        return _lockDepth;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/locking/MemoryResourceLocks.java
================================================
/*
 * Copyright 2005-2006 webdav-servlet group.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.locking;

import java.util.Enumeration;
import java.util.Hashtable;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.exceptions.LockFailedException;

/**
 * simple locking management for concurrent data access, NOT the webdav locking.
 * ( could that be used instead? )
 * 
 * IT IS ACTUALLY USED FOR DOLOCK
 * 
 * @author re
 */
public class MemoryResourceLocks implements IResourceLocks {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(MemoryResourceLocks.class);

    /**
     * after creating this much LockedObjects, a cleanup deletes unused
     * LockedObjects
     */
    private final int _cleanupLimit = 100000;

    protected int _cleanupCounter = 0;

    /**
     * keys: path value: LockedObject from that path
     * Concurrent access can occur
     */
    protected Hashtable<String, LockedObject> _locks = new Hashtable<String, LockedObject>();

    /**
     * keys: id value: LockedObject from that id
     * Concurrent access can occur
     */
    protected Hashtable<String, LockedObject> _locksByID = new Hashtable<String, LockedObject>();

    /**
     * keys: path value: Temporary LockedObject from that path
     * Concurrent access can occur
     */
    protected Hashtable<String, LockedObject> _tempLocks = new Hashtable<String, LockedObject>();

    /**
     * keys: id value: Temporary LockedObject from that id
     * Concurrent access can occur
     */
    protected Hashtable<String, LockedObject> _tempLocksByID = new Hashtable<String, LockedObject>();

    // REMEMBER TO REMOVE UNUSED LOCKS FROM THE HASHTABLE AS WELL

    protected LockedObject _root = null;

    protected LockedObject _tempRoot = null;

    private boolean _temporary = true;

    public MemoryResourceLocks() {
        _root = new MemoryLockedObject(this, "/", true);
        _tempRoot = new MemoryLockedObject(this, "/", false);
    }

    public synchronized boolean lock(ITransaction transaction, String path,
            String owner, boolean exclusive, int depth, int timeout,
            boolean temporary) throws LockFailedException {

    	MemoryLockedObject lo = null;

        if (temporary) {
            lo = generateTempLockedObjects(transaction, path);
            lo._type = "read";
        } else {
            lo = generateLockedObjects(transaction, path);
            lo._type = "write";
        }

        if (lo.checkLocks(exclusive, depth)) {

            lo._exclusive = exclusive;
            lo._lockDepth = depth;
            lo._expiresAt = System.currentTimeMillis() + (timeout * 1000);
            if (lo._parent != null) {
                lo._parent._expiresAt = lo._expiresAt;
                if (lo._parent.equals(_root)) {
                    LockedObject rootLo = getLockedObjectByPath(transaction,
                            _root.getPath());
                    rootLo._expiresAt = lo._expiresAt;
                } else if (lo._parent.equals(_tempRoot)) {
                    LockedObject tempRootLo = getTempLockedObjectByPath(
                            transaction, _tempRoot.getPath());
                    tempRootLo._expiresAt = lo._expiresAt;
                }
            }
            if (lo.addLockedObjectOwner(owner)) {
                return true;
            } else {
                LOG.trace("Couldn't set owner \"" + owner
                        + "\" to resource at '" + path + "'");
                return false;
            }
        } else {
            // can not lock
            LOG.trace("Lock resource at " + path + " failed because"
                    + "\na parent or child resource is currently locked");
            return false;
        }
    }

    public synchronized boolean unlock(ITransaction transaction, String id,
            String owner) {

        if (_locksByID.containsKey(id)) {
            String path = _locksByID.get(id).getPath();
            if (_locks.containsKey(path)) {
                LockedObject lo = _locks.get(path);
                lo.removeLockedObjectOwner(owner);

                if (lo._children == null && lo._owner == null)
                    lo.removeLockedObject();

            } else {
                // there is no lock at that path. someone tried to unlock it
                // anyway. could point to a problem
                LOG
                        .trace("net.sf.webdav.locking.ResourceLocks.unlock(): no lock for path "
                                + path);
                return false;
            }

            if (_cleanupCounter > _cleanupLimit) {
                _cleanupCounter = 0;
                cleanLockedObjects(transaction, _root, !_temporary);
            }
        }
        checkTimeouts(transaction, !_temporary);

        return true;

    }

    public synchronized void unlockTemporaryLockedObjects(
            ITransaction transaction, String path, String owner) {
        if (_tempLocks.containsKey(path)) {
            LockedObject lo = _tempLocks.get(path);
            lo.removeLockedObjectOwner(owner);

        } else {
            // there is no lock at that path. someone tried to unlock it
            // anyway. could point to a problem
            LOG
                    .trace("net.sf.webdav.locking.ResourceLocks.unlock(): no lock for path "
                            + path);
        }

        if (_cleanupCounter > _cleanupLimit) {
            _cleanupCounter = 0;
            cleanLockedObjects(transaction, _tempRoot, _temporary);
        }

        checkTimeouts(transaction, _temporary);

    }

    public void checkTimeouts(ITransaction transaction, boolean temporary) {
        if (!temporary) {
            Enumeration<LockedObject> lockedObjects = _locks.elements();
            while (lockedObjects.hasMoreElements()) {
                LockedObject currentLockedObject = lockedObjects.nextElement();

                if (currentLockedObject._expiresAt < System.currentTimeMillis()) {
                    currentLockedObject.removeLockedObject();
                }
            }
        } else {
            Enumeration<LockedObject> lockedObjects = _tempLocks.elements();
            while (lockedObjects.hasMoreElements()) {
                LockedObject currentLockedObject = lockedObjects.nextElement();

                if (currentLockedObject._expiresAt < System.currentTimeMillis()) {
                    currentLockedObject.removeTempLockedObject();
                }
            }
        }

    }

    public boolean exclusiveLock(ITransaction transaction, String path,
            String owner, int depth, int timeout) throws LockFailedException {
        return lock(transaction, path, owner, true, depth, timeout, false);
    }

    public boolean sharedLock(ITransaction transaction, String path,
            String owner, int depth, int timeout) throws LockFailedException {
        return lock(transaction, path, owner, false, depth, timeout, false);
    }

    public LockedObject getLockedObjectByID(ITransaction transaction, String id) {
        if (_locksByID.containsKey(id)) {
            return _locksByID.get(id);
        } else {
            return null;
        }
    }

    public LockedObject getLockedObjectByPath(ITransaction transaction,
            String path) {
        if (_locks.containsKey(path)) {
            return (LockedObject) this._locks.get(path);
        } else {
            return null;
        }
    }

    public LockedObject getTempLockedObjectByID(ITransaction transaction,
            String id) {
        if (_tempLocksByID.containsKey(id)) {
            return _tempLocksByID.get(id);
        } else {
            return null;
        }
    }

    public LockedObject getTempLockedObjectByPath(ITransaction transaction,
            String path) {
        if (_tempLocks.containsKey(path)) {
            return (LockedObject) this._tempLocks.get(path);
        } else {
            return null;
        }
    }

    /**
     * generates real LockedObjects for the resource at path and its parent
     * folders. does not create new LockedObjects if they already exist
     * 
     * @param transaction
     * @param path
     *      path to the (new) LockedObject
     * @return the LockedObject for path.
     */
    private MemoryLockedObject generateLockedObjects(ITransaction transaction,
            String path) {
        if (!_locks.containsKey(path)) {
        	MemoryLockedObject returnObject = new MemoryLockedObject(this, path,
                    !_temporary);
            String parentPath = getParentPath(path);
            if (parentPath != null) {
            	MemoryLockedObject parentLockedObject = generateLockedObjects(
                        transaction, parentPath);
                parentLockedObject.addChild(returnObject);
                returnObject._parent = parentLockedObject;
            }
            return returnObject;
        } else {
            // there is already a LockedObject on the specified path
            return (MemoryLockedObject) this._locks.get(path);
        }

    }

    /**
     * generates temporary LockedObjects for the resource at path and its parent
     * folders. does not create new LockedObjects if they already exist
     * 
     * @param transaction
     * @param path
     *      path to the (new) LockedObject
     * @return the LockedObject for path.
     */
    private MemoryLockedObject generateTempLockedObjects(ITransaction transaction,
            String path) {
        if (!_tempLocks.containsKey(path)) {
        	MemoryLockedObject returnObject = new MemoryLockedObject(this, path, _temporary);
            String parentPath = getParentPath(path);
            if (parentPath != null) {
            	MemoryLockedObject parentLockedObject = generateTempLockedObjects(
                        transaction, parentPath);
                parentLockedObject.addChild(returnObject);
                returnObject._parent = parentLockedObject;
            }
            return returnObject;
        } else {
            // there is already a LockedObject on the specified path
            return (MemoryLockedObject) this._tempLocks.get(path);
        }

    }

    /**
     * deletes unused LockedObjects and resets the counter. works recursively
     * starting at the given LockedObject
     * 
     * @param transaction
     * @param lo
     *      LockedObject
     * @param temporary
     *      Clean temporary or real locks
     * 
     * @return if cleaned
     */
    private boolean cleanLockedObjects(ITransaction transaction,
            LockedObject lo, boolean temporary) {

        if (lo._children == null) {
            if (lo._owner == null) {
                if (temporary) {
                    lo.removeTempLockedObject();
                } else {
                    lo.removeLockedObject();
                }

                return true;
            } else {
                return false;
            }
        } else {
            boolean canDelete = true;
            int limit = lo._children.length;
            for (int i = 0; i < limit; i++) {
                if (!cleanLockedObjects(transaction, lo._children[i], temporary)) {
                    canDelete = false;
                } else {

                    // because the deleting shifts the array
                    i--;
                    limit--;
                }
            }
            if (canDelete) {
                if (lo._owner == null) {
                    if (temporary) {
                        lo.removeTempLockedObject();
                    } else {
                        lo.removeLockedObject();
                    }
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
    }

    /**
     * creates the parent path from the given path by removing the last '/' and
     * everything after that
     * 
     * @param path
     *      the path
     * @return parent path
     */
    private String getParentPath(String path) {
        int slash = path.lastIndexOf('/');
        if (slash == -1) {
            return null;
        } else {
            if (slash == 0) {
                // return "root" if parent path is empty string
                return "/";
            } else {
                return path.substring(0, slash);
            }
        }
    }

	public Hashtable<String, LockedObject> get_locks() {
		return _locks;
	}

	public void set_locks(Hashtable<String, LockedObject> _locks) {
		this._locks = _locks;
	}

	public Hashtable<String, LockedObject> get_locksByID() {
		return _locksByID;
	}

	public void set_locksByID(Hashtable<String, LockedObject> _locksByID) {
		this._locksByID = _locksByID;
	}

	public Hashtable<String, LockedObject> get_tempLocks() {
		return _tempLocks;
	}

	public void set_tempLocks(Hashtable<String, LockedObject> _tempLocks) {
		this._tempLocks = _tempLocks;
	}

	public Hashtable<String, LockedObject> get_tempLocksByID() {
		return _tempLocksByID;
	}

	public void set_tempLocksByID(Hashtable<String, LockedObject> _tempLocksByID) {
		this._tempLocksByID = _tempLocksByID;
	}

	
    
    public LockedObject get_root() {
		return _root;
	}

	public void set_root(LockedObject _root) {
		this._root = _root;
	}

	public void addCleanupCounter(){
    	this._cleanupCounter++;
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/AbstractMethod.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.io.Writer;
import java.text.SimpleDateFormat;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Locale;
import java.util.TimeZone;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import com.ejie.x38.webdav.IMethodExecutor;
import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.fromcatalina.URLEncoder;
import com.ejie.x38.webdav.fromcatalina.XMLWriter;
import com.ejie.x38.webdav.locking.IResourceLocks;
import com.ejie.x38.webdav.locking.LockedObject;

public abstract class AbstractMethod implements IMethodExecutor {

    /**
     * Array containing the safe characters set.
     */
    protected static URLEncoder URL_ENCODER;

    /**
     * Default depth is infite.
     */
    protected static final int INFINITY = 3;

    /**
     * Simple date format for the creation date ISO 8601 representation
     * (partial).
     */
    protected static final SimpleDateFormat CREATION_DATE_FORMAT = new SimpleDateFormat(
            "yyyy-MM-dd'T'HH:mm:ss'Z'");

    /**
     * Simple date format for the last modified date. (RFC 822 updated by RFC
     * 1123)
     */
    protected static final SimpleDateFormat LAST_MODIFIED_DATE_FORMAT = new SimpleDateFormat(
            "EEE, dd MMM yyyy HH:mm:ss z", Locale.US);

    static {
        CREATION_DATE_FORMAT.setTimeZone(TimeZone.getTimeZone("GMT"));
        LAST_MODIFIED_DATE_FORMAT.setTimeZone(TimeZone.getTimeZone("GMT"));
        /**
         * GMT timezone - all HTTP dates are on GMT
         */
        URL_ENCODER = new URLEncoder();
        URL_ENCODER.addSafeCharacter('-');
        URL_ENCODER.addSafeCharacter('_');
        URL_ENCODER.addSafeCharacter('.');
        URL_ENCODER.addSafeCharacter('*');
        URL_ENCODER.addSafeCharacter('/');
    }

    /**
     * size of the io-buffer
     */
    protected static int BUF_SIZE = 65536;

    /**
     * Default lock timeout value.
     */
    protected static final int DEFAULT_TIMEOUT = 3600;

    /**
     * Maximum lock timeout.
     */
    protected static final int MAX_TIMEOUT = 604800;

    /**
     * Boolean value to temporary lock resources (for method locks)
     */
    protected static final boolean TEMPORARY = true;

    /**
     * Timeout for temporary locks
     */
    protected static final int TEMP_TIMEOUT = 10;

    /**
     * Return the relative path associated with this servlet.
     * 
     * @param request
     *      The servlet request we are processing
     */
    protected String getRelativePath(HttpServletRequest request) {

        // Are we being processed by a RequestDispatcher.include()?
        if (request.getAttribute("javax.servlet.include.request_uri") != null) {
            String result = (String) request
                    .getAttribute("javax.servlet.include.path_info");
            // if (result == null)
            // result = (String) request
            // .getAttribute("javax.servlet.include.servlet_path");
            if ((result == null) || (result.equals("")))
                result = "/";
            return (result);
        }

        // No, extract the desired path directly from the request
        String result = request.getPathInfo();
        // if (result == null) {
        // result = request.getServletPath();
        // }
        if ((result == null) || (result.equals(""))) {
            result = "/";
        }
        return (result);

    }

    /**
     * creates the parent path from the given path by removing the last '/' and
     * everything after that
     * 
     * @param path
     *      the path
     * @return parent path
     */
    protected String getParentPath(String path) {
        int slash = path.lastIndexOf('/');
        if (slash != -1) {
            return path.substring(0, slash);
        }
        return null;
    }

    /**
     * removes a / at the end of the path string, if present
     * 
     * @param path
     *      the path
     * @return the path without trailing /
     */
    protected String getCleanPath(String path) {

        if (path.endsWith("/") && path.length() > 1)
            path = path.substring(0, path.length() - 1);
        return path;
    }

    /**
     * Return JAXP document builder instance.
     */
    protected DocumentBuilder getDocumentBuilder() throws ServletException {
        DocumentBuilder documentBuilder = null;
        DocumentBuilderFactory documentBuilderFactory = null;
        try {
            documentBuilderFactory = DocumentBuilderFactory.newInstance();
            documentBuilderFactory.setNamespaceAware(true);
            documentBuilder = documentBuilderFactory.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            throw new ServletException("jaxp failed");
        }
        return documentBuilder;
    }

    /**
     * reads the depth header from the request and returns it as a int
     * 
     * @param req
     * @return the depth from the depth header
     */
    protected int getDepth(HttpServletRequest req) {
        int depth = INFINITY;
        String depthStr = req.getHeader("Depth");
        if (depthStr != null) {
            if (depthStr.equals("0")) {
                depth = 0;
            } else if (depthStr.equals("1")) {
                depth = 1;
            }
        }
        return depth;
    }

    /**
     * URL rewriter.
     * 
     * @param path
     *      Path which has to be rewiten
     * @return the rewritten path
     */
    protected String rewriteUrl(String path) {
        return URL_ENCODER.encode(path);
    }

    /**
     * Get the ETag associated with a file.
     * 
     * @param so
     *      StoredObject to get resourceLength, lastModified and a hashCode of
     *      StoredObject
     * @return the ETag
     */
    protected String getETag(StoredObject so) {

        String resourceLength = "";
        String lastModified = "";

        if (so != null && so.isResource()) {
            resourceLength = Long.valueOf(so.getResourceLength()).toString();
            lastModified = Long.valueOf(so.getLastModified().getTime()).toString();
        }

        return "W/\"" + resourceLength + "-" + lastModified + "\"";

    }

    protected String[] getLockIdFromIfHeader(HttpServletRequest req) {
        String[] ids = new String[2];
        String id = req.getHeader("If");

        if (id != null && !id.equals("")) {
            if (id.indexOf(">)") == id.lastIndexOf(">)")) {
                id = id.substring(id.indexOf("(<"), id.indexOf(">)"));

                if (id.indexOf("locktoken:") != -1) {
                    id = id.substring(id.indexOf(':') + 1);
                }
                ids[0] = id;
            } else {
                String firstId = id.substring(id.indexOf("(<"), id
                        .indexOf(">)"));
                if (firstId.indexOf("locktoken:") != -1) {
                    firstId = firstId.substring(firstId.indexOf(':') + 1);
                }
                ids[0] = firstId;

                String secondId = id.substring(id.lastIndexOf("(<"), id
                        .lastIndexOf(">)"));
                if (secondId.indexOf("locktoken:") != -1) {
                    secondId = secondId.substring(secondId.indexOf(':') + 1);
                }
                ids[1] = secondId;
            }

        } else {
            ids = null;
        }
        return ids;
    }

    protected String getLockIdFromLockTokenHeader(HttpServletRequest req) {
        String id = req.getHeader("Lock-Token");

        if (id != null) {
            id = id.substring(id.indexOf(":") + 1, id.indexOf(">"));

        }

        return id;
    }

    /**
     * Checks if locks on resources at the given path exists and if so checks
     * the If-Header to make sure the If-Header corresponds to the locked
     * resource. Returning true if no lock exists or the If-Header is
     * corresponding to the locked resource
     * 
     * @param req
     *      Servlet request
     * @param resp
     *      Servlet response
     * @param resourceLocks
     * @param path
     *      path to the resource
     * @return true if no lock on a resource with the given path exists or if
     *  the If-Header corresponds to the locked resource
     * @throws IOException
     * @throws LockFailedException
     */
    protected boolean checkLocks(ITransaction transaction,
            HttpServletRequest req, HttpServletResponse resp,
            IResourceLocks resourceLocks, String path) throws IOException,
            LockFailedException {

        LockedObject loByPath = resourceLocks.getLockedObjectByPath(
                transaction, path);
        if (loByPath != null) {

            if (loByPath.isShared())
                return true;

            // the resource is locked
            String[] lockTokens = getLockIdFromIfHeader(req);
            String lockToken = null;
            if (lockTokens != null)
                lockToken = lockTokens[0];
            else {
                return false;
            }
            if (lockToken != null) {
                LockedObject loByIf = resourceLocks.getLockedObjectByID(
                        transaction, lockToken);
                if (loByIf == null) {
                    // no locked resource to the given lockToken
                    return false;
                }
                if (!loByIf.equals(loByPath)) {
                    loByIf = null;
                    return false;
                }
                loByIf = null;
            }

        }
        loByPath = null;
        return true;
    }

    /**
     * Send a multistatus element containing a complete error report to the
     * client.
     * 
     * @param req
     *      Servlet request
     * @param resp
     *      Servlet response
     * @param errorList
     *      List of error to be displayed
     */
    protected void sendReport(HttpServletRequest req, HttpServletResponse resp,
            Hashtable<String, Integer> errorList) throws IOException {

        resp.setStatus(WebdavStatus.SC_MULTI_STATUS);

        String absoluteUri = req.getRequestURI();
        // String relativePath = getRelativePath(req);

        HashMap<String, String> namespaces = new HashMap<String, String>();
        namespaces.put("DAV:", "D");

        XMLWriter generatedXML = new XMLWriter(namespaces);
        generatedXML.writeXMLHeader();

        generatedXML.writeElement("DAV::multistatus", XMLWriter.OPENING);

        Enumeration<String> pathList = errorList.keys();
        while (pathList.hasMoreElements()) {

            String errorPath = (String) pathList.nextElement();
            int errorCode = ((Integer) errorList.get(errorPath)).intValue();

            generatedXML.writeElement("DAV::response", XMLWriter.OPENING);

            generatedXML.writeElement("DAV::href", XMLWriter.OPENING);
            String toAppend = null;
            if (absoluteUri.endsWith(errorPath)) {
                toAppend = absoluteUri;

            } else if (absoluteUri.contains(errorPath)) {

                int endIndex = absoluteUri.indexOf(errorPath)
                        + errorPath.length();
                toAppend = absoluteUri.substring(0, endIndex);
            }
            if (!toAppend.startsWith("/") && !toAppend.startsWith("http:"))
                toAppend = "/" + toAppend;
            generatedXML.writeText(errorPath);
            generatedXML.writeElement("DAV::href", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::status", XMLWriter.OPENING);
            generatedXML.writeText("HTTP/1.1 " + errorCode + " "
                    + WebdavStatus.getStatusText(errorCode));
            generatedXML.writeElement("DAV::status", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::response", XMLWriter.CLOSING);

        }

        generatedXML.writeElement("DAV::multistatus", XMLWriter.CLOSING);

        Writer writer = resp.getWriter();
        writer.write(generatedXML.toString());
        writer.close();

    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DeterminableMethod.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import com.ejie.x38.webdav.StoredObject;

public abstract class DeterminableMethod extends AbstractMethod {

    private static final String NULL_RESOURCE_METHODS_ALLOWED = "OPTIONS, MKCOL, PUT, PROPFIND, LOCK, UNLOCK";

    private static final String RESOURCE_METHODS_ALLOWED = "OPTIONS, GET, HEAD, POST, DELETE, TRACE"
            + ", PROPPATCH, COPY, MOVE, LOCK, UNLOCK, PROPFIND";

    private static final String FOLDER_METHOD_ALLOWED = ", PUT";

    private static final String LESS_ALLOWED_METHODS = "OPTIONS, MKCOL, PUT";

    /**
     * Determines the methods normally allowed for the resource.
     * 
     * @param so
     *      StoredObject representing the resource
     * @return all allowed methods, separated by commas
     */
    protected static String determineMethodsAllowed(StoredObject so) {

        try {
            if (so != null) {
                if (so.isNullResource()) {

                    return NULL_RESOURCE_METHODS_ALLOWED;

                } else if (so.isFolder()) {
                    return RESOURCE_METHODS_ALLOWED + FOLDER_METHOD_ALLOWED;
                }
                // else resource
                return RESOURCE_METHODS_ALLOWED;
            }
        } catch (Exception e) {
            // we do nothing, just return less allowed methods
        }

        return LESS_ALLOWED_METHODS;
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoCopy.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.Hashtable;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.ObjectAlreadyExistsException;
import com.ejie.x38.webdav.exceptions.ObjectNotFoundException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.fromcatalina.RequestUtil;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoCopy extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoCopy.class);

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;
    private DoDelete _doDelete;
    private boolean _readOnly;

    public DoCopy(IWebdavStore store, IResourceLocks resourceLocks,
            DoDelete doDelete, boolean readOnly) {
        _store = store;
        _resourceLocks = resourceLocks;
        _doDelete = doDelete;
        _readOnly = readOnly;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        String path = getRelativePath(req);
        if (!_readOnly) {

            String tempLockOwner = "doCopy" + System.currentTimeMillis()
                    + req.toString();
            if (_resourceLocks.lock(transaction, path, tempLockOwner, false, 0,
                    TEMP_TIMEOUT, TEMPORARY)) {
                try {
                    if (!copyResource(transaction, req, resp))
                        return;
                } catch (AccessDeniedException e) {
                    resp.sendError(WebdavStatus.SC_FORBIDDEN);
                } catch (ObjectAlreadyExistsException e) {
                    resp.sendError(WebdavStatus.SC_CONFLICT, req
                            .getRequestURI());
                } catch (ObjectNotFoundException e) {
                    resp.sendError(WebdavStatus.SC_NOT_FOUND, req
                            .getRequestURI());
                } catch (WebdavException e) {
                    resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                } finally {
                    _resourceLocks.unlockTemporaryLockedObjects(transaction,
                            path, tempLockOwner);
                }
            } else {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            }

        } else {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
        }

    }

    /**
     * Copy a resource.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param req
     *      Servlet request
     * @param resp
     *      Servlet response
     * @return true if the copy is successful
     * @throws WebdavException
     *      if an error in the underlying store occurs
     * @throws IOException
     *      when an error occurs while sending the response
     * @throws LockFailedException
     */
    public boolean copyResource(ITransaction transaction,
            HttpServletRequest req, HttpServletResponse resp)
            throws WebdavException, IOException, LockFailedException {

        // Parsing destination header
        String destinationPath = parseDestinationHeader(req, resp);

        if (destinationPath == null)
            return false;

        String path = getRelativePath(req);

        if (path.equals(destinationPath)) {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
            return false;
        }

        Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();
        String parentDestinationPath = getParentPath(getCleanPath(destinationPath));

        if (!checkLocks(transaction, req, resp, _resourceLocks,
                parentDestinationPath)) {
            errorList.put(parentDestinationPath, WebdavStatus.SC_LOCKED);
            sendReport(req, resp, errorList);
            return false; // parentDestination is locked
        }

        if (!checkLocks(transaction, req, resp, _resourceLocks, destinationPath)) {
            errorList.put(destinationPath, WebdavStatus.SC_LOCKED);
            sendReport(req, resp, errorList);
            return false; // destination is locked
        }

        // Parsing overwrite header

        boolean overwrite = true;
        String overwriteHeader = req.getHeader("Overwrite");

        if (overwriteHeader != null) {
            overwrite = overwriteHeader.equalsIgnoreCase("T");
        }

        // Overwriting the destination
        String lockOwner = "copyResource" + System.currentTimeMillis()
                + req.toString();

        if (_resourceLocks.lock(transaction, destinationPath, lockOwner, false,
                0, TEMP_TIMEOUT, TEMPORARY)) {
            StoredObject copySo, destinationSo = null;
            try {
                copySo = _store.getStoredObject(transaction, path);
                // Retrieve the resources
                if (copySo == null) {
                    resp.sendError(HttpServletResponse.SC_NOT_FOUND);
                    return false;
                }

                if (copySo.isNullResource()) {
                    String methodsAllowed = DeterminableMethod
                            .determineMethodsAllowed(copySo);
                    resp.addHeader("Allow", methodsAllowed);
                    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
                    return false;
                }

                errorList = new Hashtable<String, Integer>();

                destinationSo = _store.getStoredObject(transaction,
                        destinationPath);

                if (overwrite) {

                    // Delete destination resource, if it exists
                    if (destinationSo != null) {
                        _doDelete.deleteResource(transaction, destinationPath,
                                errorList, req, resp);

                    } else {
                        resp.setStatus(WebdavStatus.SC_CREATED);
                    }
                } else {

                    // If the destination exists, then it's a conflict
                    if (destinationSo != null) {
                        resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
                        return false;
                    } else {
                        resp.setStatus(WebdavStatus.SC_CREATED);
                    }

                }
                copy(transaction, path, destinationPath, errorList, req, resp);

                if (!errorList.isEmpty()) {
                    sendReport(req, resp, errorList);
                }

            } finally {
                _resourceLocks.unlockTemporaryLockedObjects(transaction,
                        destinationPath, lockOwner);
            }
        } else {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            return false;
        }
        return true;

    }

    /**
     * copies the specified resource(s) to the specified destination.
     * preconditions must be handled by the caller. Standard status codes must
     * be handled by the caller. a multi status report in case of errors is
     * created here.
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param sourcePath
     *      path from where to read
     * @param destinationPath
     *      path where to write
     * @param req
     *      HttpServletRequest
     * @param resp
     *      HttpServletResponse
     * @throws WebdavException
     *      if an error in the underlying store occurs
     * @throws IOException
     */
    private void copy(ITransaction transaction, String sourcePath,
            String destinationPath, Hashtable<String, Integer> errorList,
            HttpServletRequest req, HttpServletResponse resp)
            throws WebdavException, IOException {

        StoredObject sourceSo = _store.getStoredObject(transaction, sourcePath);
        if (sourceSo.isResource()) {
            _store.createResource(transaction, destinationPath);
            long resourceLength = _store.setResourceContent(transaction,
                    destinationPath, _store.getResourceContent(transaction,
                            sourcePath), null, null);

            if (resourceLength != -1) {
                StoredObject destinationSo = _store.getStoredObject(
                        transaction, destinationPath);
                destinationSo.setResourceLength(resourceLength);
            }

        } else {

            if (sourceSo.isFolder()) {
                copyFolder(transaction, sourcePath, destinationPath, errorList,
                        req, resp);
            } else {
                resp.sendError(WebdavStatus.SC_NOT_FOUND);
            }
        }
    }

    /**
     * helper method of copy() recursively copies the FOLDER at source path to
     * destination path
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param sourcePath
     *      where to read
     * @param destinationPath
     *      where to write
     * @param errorList
     *      all errors that ocurred
     * @param req
     *      HttpServletRequest
     * @param resp
     *      HttpServletResponse
     * @throws WebdavException
     *      if an error in the underlying store occurs
     */
    private void copyFolder(ITransaction transaction, String sourcePath,
            String destinationPath, Hashtable<String, Integer> errorList,
            HttpServletRequest req, HttpServletResponse resp)
            throws WebdavException {

        _store.createFolder(transaction, destinationPath);
        boolean infiniteDepth = true;
        String depth = req.getHeader("Depth");
        if (depth != null) {
            if (depth.equals("0")) {
                infiniteDepth = false;
            }
        }
        if (infiniteDepth) {
            String[] children = _store
                    .getChildrenNames(transaction, sourcePath);
            children = children == null ? new String[] {} : children;

            StoredObject childSo;
            for (int i = children.length - 1; i >= 0; i--) {
                children[i] = "/" + children[i];
                try {
                    childSo = _store.getStoredObject(transaction,
                            (sourcePath + children[i]));
                    if (childSo.isResource()) {
                        _store.createResource(transaction, destinationPath
                                + children[i]);
                        long resourceLength = _store.setResourceContent(
                                transaction, destinationPath + children[i],
                                _store.getResourceContent(transaction,
                                        sourcePath + children[i]), null, null);

                        if (resourceLength != -1) {
                            StoredObject destinationSo = _store
                                    .getStoredObject(transaction,
                                            destinationPath + children[i]);
                            destinationSo.setResourceLength(resourceLength);
                        }

                    } else {
                        copyFolder(transaction, sourcePath + children[i],
                                destinationPath + children[i], errorList, req,
                                resp);
                    }
                } catch (AccessDeniedException e) {
                    errorList.put(destinationPath + children[i], Integer.valueOf(
                            WebdavStatus.SC_FORBIDDEN));
                } catch (ObjectNotFoundException e) {
                    errorList.put(destinationPath + children[i], Integer.valueOf(
                            WebdavStatus.SC_NOT_FOUND));
                } catch (ObjectAlreadyExistsException e) {
                    errorList.put(destinationPath + children[i], Integer.valueOf(
                            WebdavStatus.SC_CONFLICT));
                } catch (WebdavException e) {
                    errorList.put(destinationPath + children[i], Integer.valueOf(
                            WebdavStatus.SC_INTERNAL_SERVER_ERROR));
                }
            }
        }
    }

    /**
     * Parses and normalizes the destination header.
     * 
     * @param req
     *      Servlet request
     * @param resp
     *      Servlet response
     * @return destinationPath
     * @throws IOException
     *      if an error occurs while sending response
     */
    private String parseDestinationHeader(HttpServletRequest req,
            HttpServletResponse resp) throws IOException {
        String destinationPath = req.getHeader("Destination");

        if (destinationPath == null) {
            resp.sendError(WebdavStatus.SC_BAD_REQUEST);
            return null;
        }

        // Remove url encoding from destination
        destinationPath = RequestUtil.URLDecode(destinationPath, "UTF8");

        int protocolIndex = destinationPath.indexOf("://");
        if (protocolIndex >= 0) {
            // if the Destination URL contains the protocol, we can safely
            // trim everything upto the first "/" character after "://"
            int firstSeparator = destinationPath
                    .indexOf("/", protocolIndex + 4);
            if (firstSeparator < 0) {
                destinationPath = "/";
            } else {
                destinationPath = destinationPath.substring(firstSeparator);
            }
        } else {
            String hostName = req.getServerName();
            if ((hostName != null) && (destinationPath.startsWith(hostName))) {
                destinationPath = destinationPath.substring(hostName.length());
            }

            int portIndex = destinationPath.indexOf(":");
            if (portIndex >= 0) {
                destinationPath = destinationPath.substring(portIndex);
            }

            if (destinationPath.startsWith(":")) {
                int firstSeparator = destinationPath.indexOf("/");
                if (firstSeparator < 0) {
                    destinationPath = "/";
                } else {
                    destinationPath = destinationPath.substring(firstSeparator);
                }
            }
        }

        // Normalize destination path (remove '.' and' ..')
        destinationPath = normalize(destinationPath);

        String contextPath = req.getContextPath();
        if ((contextPath != null) && (destinationPath.startsWith(contextPath))) {
            destinationPath = destinationPath.substring(contextPath.length());
        }

        String pathInfo = req.getPathInfo();
        if (pathInfo != null) {
            String servletPath = req.getServletPath();
            if ((servletPath != null)
                    && (destinationPath.startsWith(servletPath))) {
                destinationPath = destinationPath.substring(servletPath
                        .length());
            }
        }

        return destinationPath;
    }

    /**
     * Return a context-relative path, beginning with a "/", that represents the
     * canonical version of the specified path after ".." and "." elements are
     * resolved out. If the specified path attempts to go outside the boundaries
     * of the current context (i.e. too many ".." path elements are present),
     * return <code>null</code> instead.
     * 
     * @param path
     *      Path to be normalized
     * @return normalized path
     */
    protected String normalize(String path) {

        if (path == null)
            return null;

        // Create a place for the normalized path
        String normalized = path;

        if (normalized.equals("/."))
            return "/";

        // Normalize the slashes and add leading slash if necessary
        if (normalized.indexOf('\\') >= 0)
            normalized = normalized.replace('\\', '/');
        if (!normalized.startsWith("/"))
            normalized = "/" + normalized;

        // Resolve occurrences of "//" in the normalized path
        while (true) {
            int index = normalized.indexOf("//");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index)
                    + normalized.substring(index + 1);
        }

        // Resolve occurrences of "/./" in the normalized path
        while (true) {
            int index = normalized.indexOf("/./");
            if (index < 0)
                break;
            normalized = normalized.substring(0, index)
                    + normalized.substring(index + 2);
        }

        // Resolve occurrences of "/../" in the normalized path
        while (true) {
            int index = normalized.indexOf("/../");
            if (index < 0)
                break;
            if (index == 0)
                return (null); // Trying to go outside our context
            int index2 = normalized.lastIndexOf('/', index - 1);
            normalized = normalized.substring(0, index2)
                    + normalized.substring(index + 3);
        }

        // Return the normalized path that we have completed
        return (normalized);

    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoDelete.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.Hashtable;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.ObjectAlreadyExistsException;
import com.ejie.x38.webdav.exceptions.ObjectNotFoundException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoDelete extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoDelete.class);

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;
    private boolean _readOnly;

    public DoDelete(IWebdavStore store, IResourceLocks resourceLocks,
            boolean readOnly) {
        _store = store;
        _resourceLocks = resourceLocks;
        _readOnly = readOnly;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        if (!_readOnly) {
            String path = getRelativePath(req);
            String parentPath = getParentPath(getCleanPath(path));

            Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();

            if (!checkLocks(transaction, req, resp, _resourceLocks, parentPath)) {
                errorList.put(parentPath, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return; // parent is locked
            }

            if (!checkLocks(transaction, req, resp, _resourceLocks, path)) {
                errorList.put(path, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return; // resource is locked
            }

            String tempLockOwner = "doDelete" + System.currentTimeMillis()
                    + req.toString();
            if (_resourceLocks.lock(transaction, path, tempLockOwner, false, 0,
                    TEMP_TIMEOUT, TEMPORARY)) {
                try {
                    errorList = new Hashtable<String, Integer>();
                    deleteResource(transaction, path, errorList, req, resp);
                    if (!errorList.isEmpty()) {
                        sendReport(req, resp, errorList);
                    }
                } catch (AccessDeniedException e) {
                    resp.sendError(WebdavStatus.SC_FORBIDDEN);
                } catch (ObjectAlreadyExistsException e) {
                    resp.sendError(WebdavStatus.SC_NOT_FOUND, req
                            .getRequestURI());
                } catch (WebdavException e) {
                    resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                } finally {
                    _resourceLocks.unlockTemporaryLockedObjects(transaction,
                            path, tempLockOwner);
                }
            } else {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            }
        } else {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
        }

    }

    /**
     * deletes the recources at "path"
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param path
     *      the folder to be deleted
     * @param errorList
     *      all errors that ocurred
     * @param req
     *      HttpServletRequest
     * @param resp
     *      HttpServletResponse
     * @throws WebdavException
     *      if an error in the underlying store occurs
     * @throws IOException
     *      when an error occurs while sending the response
     */
    public void deleteResource(ITransaction transaction, String path,
            Hashtable<String, Integer> errorList, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, WebdavException {

        resp.setStatus(WebdavStatus.SC_NO_CONTENT);

        if (!_readOnly) {

            StoredObject so = _store.getStoredObject(transaction, path);
            if (so != null) {

                if (so.isResource()) {
                    _store.removeObject(transaction, path);
                } else {
                    if (so.isFolder()) {
                        deleteFolder(transaction, path, errorList, req, resp);
                        _store.removeObject(transaction, path);
                    } else {
                        resp.sendError(WebdavStatus.SC_NOT_FOUND);
                    }
                }
            } else {
                resp.sendError(WebdavStatus.SC_NOT_FOUND);
            }
            so = null;

        } else {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
        }
    }

    /**
     * 
     * helper method of deleteResource() deletes the folder and all of its
     * contents
     * 
     * @param transaction
     *      indicates that the method is within the scope of a WebDAV
     *      transaction
     * @param path
     *      the folder to be deleted
     * @param errorList
     *      all errors that ocurred
     * @param req
     *      HttpServletRequest
     * @param resp
     *      HttpServletResponse
     * @throws WebdavException
     *      if an error in the underlying store occurs
     */
    private void deleteFolder(ITransaction transaction, String path,
            Hashtable<String, Integer> errorList, HttpServletRequest req,
            HttpServletResponse resp) throws WebdavException {

        String[] children = _store.getChildrenNames(transaction, path);
        children = children == null ? new String[] {} : children;
        StoredObject so = null;
        for (int i = children.length - 1; i >= 0; i--) {
            children[i] = "/" + children[i];
            try {
                so = _store.getStoredObject(transaction, path + children[i]);
                if (so.isResource()) {
                    _store.removeObject(transaction, path + children[i]);

                } else {
                    deleteFolder(transaction, path + children[i], errorList,
                            req, resp);

                    _store.removeObject(transaction, path + children[i]);

                }
            } catch (AccessDeniedException e) {
                errorList.put(path + children[i], Integer.valueOf(
                        WebdavStatus.SC_FORBIDDEN));
            } catch (ObjectNotFoundException e) {
                errorList.put(path + children[i], Integer.valueOf(
                        WebdavStatus.SC_NOT_FOUND));
            } catch (WebdavException e) {
                errorList.put(path + children[i], Integer.valueOf(
                        WebdavStatus.SC_INTERNAL_SERVER_ERROR));
            }
        }
        so = null;

    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoGet.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Locale;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.IMimeTyper;
import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoGet extends DoHead {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoGet.class);

    public DoGet(IWebdavStore store, String dftIndexFile, String insteadOf404,
            IResourceLocks resourceLocks, IMimeTyper mimeTyper,
            int contentLengthHeader) {
        super(store, dftIndexFile, insteadOf404, resourceLocks, mimeTyper,
                contentLengthHeader);

    }

    @Override
    protected void doBody(ITransaction transaction, HttpServletResponse resp,
            String path) {

        try {
            StoredObject so = _store.getStoredObject(transaction, path);
            if (so.isNullResource()) {
                String methodsAllowed = DeterminableMethod
                        .determineMethodsAllowed(so);
                resp.addHeader("Allow", methodsAllowed);
                resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
                return;
            }
            OutputStream out = resp.getOutputStream();
            InputStream in = _store.getResourceContent(transaction, path);
            try {
                int read = -1;
                byte[] copyBuffer = new byte[BUF_SIZE];

                while ((read = in.read(copyBuffer, 0, copyBuffer.length)) != -1) {
                    out.write(copyBuffer, 0, read);
                }
            } finally {
                // flushing causes a IOE if a file is opened on the webserver
                // client disconnected before server finished sending response
                try {
                    in.close();
                } catch (Exception e) {
                    LOG.warn("Closing InputStream causes Exception!\n"
                            + e.toString());
                }
                try {
                    out.flush();
                    out.close();
                } catch (Exception e) {
                    LOG.warn("Flushing OutputStream causes Exception!\n"
                            + e.toString());
                }
            }
        } catch (Exception e) {
            LOG.trace(e.toString());
        }
    }

    @Override
    protected void folderBody(ITransaction transaction, String path,
            HttpServletResponse resp, HttpServletRequest req)
            throws IOException {

        StoredObject so = _store.getStoredObject(transaction, path);
        if (so == null) {
            resp.sendError(HttpServletResponse.SC_NOT_FOUND, req
                    .getRequestURI());
        } else {

            if (so.isNullResource()) {
                String methodsAllowed = DeterminableMethod
                        .determineMethodsAllowed(so);
                resp.addHeader("Allow", methodsAllowed);
                resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
                return;
            }

            if (so.isFolder()) {
                // TODO some folder response (for browsers, DAV tools
                // use propfind) in html?
                DateFormat shortDF= getDateTimeFormat(req.getLocale());
                resp.setContentType("text/html");
                resp.setCharacterEncoding("UTF8");
                OutputStream out = resp.getOutputStream();
                String[] children = _store.getChildrenNames(transaction, path);
                children = children == null ? new String[] {} : children;
                StringBuilder childrenTemp = new StringBuilder();
                childrenTemp.append("<html><head><title>Content of folder");
                childrenTemp.append(path);
                childrenTemp.append("</title><style type=\"text/css\">");
                childrenTemp.append(getCSS());
                childrenTemp.append("</style></head>");
                childrenTemp.append("<body>");
                childrenTemp.append(getHeader(transaction, path, resp, req));
                childrenTemp.append("<table>");
                childrenTemp.append("<tr><th>Name</th><th>Size</th><th>Created</th><th>Modified</th></tr>");
                childrenTemp.append("<tr>");
                childrenTemp.append("<td colspan=\"4\"><a href=\"../\">Parent</a></td></tr>");
                boolean isEven= false;
                for (String child : children) {
                    isEven= !isEven;
                    childrenTemp.append("<tr class=\"");
                    childrenTemp.append(isEven ? "even" : "odd");
                    childrenTemp.append("\">");
                    childrenTemp.append("<td>");
                    childrenTemp.append("<a href=\"");
                    childrenTemp.append(child);
                    StoredObject obj= _store.getStoredObject(transaction, path+"/"+child);
                    if (obj.isFolder())
                    {
                        childrenTemp.append("/");
                    }
                    childrenTemp.append("\">");
                    childrenTemp.append(child);
                    childrenTemp.append("</a></td>");
                    if (obj.isFolder())
                    {
                        childrenTemp.append("<td>Folder</td>");
                    }
                    else
                    {
                        childrenTemp.append("<td>");
                        childrenTemp.append(obj.getResourceLength());
                        childrenTemp.append(" Bytes</td>");
                    }
                    if (obj.getCreationDate() != null)
                    {
                        childrenTemp.append("<td>");
                        childrenTemp.append(shortDF.format(obj.getCreationDate()));
                        childrenTemp.append("</td>");
                    }
                    else
                    {
                        childrenTemp.append("<td></td>");
                    }
                    if (obj.getLastModified() != null)
                    {
                        childrenTemp.append("<td>");
                        childrenTemp.append(shortDF.format(obj.getLastModified()));
                        childrenTemp.append("</td>");
                    }
                    else
                    {
                        childrenTemp.append("<td></td>");
                    }
                    childrenTemp.append("</tr>");
                }
                childrenTemp.append("</table>");
                childrenTemp.append(getFooter(transaction, path, resp, req));
                childrenTemp.append("</body></html>");
                out.write(childrenTemp.toString().getBytes("UTF-8"));
            }
        }
    }

    /**
     * Return the CSS styles used to display the HTML representation
     * of the webdav content.
     * 
     * @return String returning the CSS style sheet used to display result in html format
     */
    protected String getCSS()
    {
        // The default styles to use
       String retVal= "body {\n"+
                "	font-family: Arial, Helvetica, sans-serif;\n"+
                "}\n"+
                "h1 {\n"+
                "	font-size: 1.5em;\n"+
                "}\n"+
                "th {\n"+
                "	background-color: #9DACBF;\n"+
                "}\n"+
                "table {\n"+
                "	border-top-style: solid;\n"+
                "	border-right-style: solid;\n"+
                "	border-bottom-style: solid;\n"+
                "	border-left-style: solid;\n"+
                "}\n"+
                "td {\n"+
                "	margin: 0px;\n"+
                "	padding-top: 2px;\n"+
                "	padding-right: 5px;\n"+
                "	padding-bottom: 2px;\n"+
                "	padding-left: 5px;\n"+
                "}\n"+
                "tr.even {\n"+
                "	background-color: #CCCCCC;\n"+
                "}\n"+
                "tr.odd {\n"+
                "	background-color: #FFFFFF;\n"+
                "}\n"+
                "";
        try
        {
            // Try loading one via class loader and use that one instead
            ClassLoader cl = getClass().getClassLoader();
            InputStream iStream = cl.getResourceAsStream("webdav.css");
            if(iStream != null)
            {
                // Found css via class loader, use that one
                StringBuilder out = new StringBuilder();
                byte[] b = new byte[4096];
                for (int n; (n = iStream.read(b)) != -1;)
                {
                    out.append(new String(b, 0, n));
                }
                retVal= out.toString();
            }
        }
        catch (Exception ex)
        {
            LOG.error("Error in reading webdav.css", ex);
        }

        return retVal;
    }

    /**
     * Return this as the Date/Time format for displaying Creation + Modification dates
     * 
     * @param browserLocale
     * @return DateFormat used to display creation and modification dates
     */
    protected DateFormat getDateTimeFormat(Locale browserLocale)
    {
        return SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.SHORT, SimpleDateFormat.MEDIUM, browserLocale);
    }

    /**
     * Return the header to be displayed in front of the folder content
     * 
     * @param transaction
     * @param path
     * @param resp
     * @param req
     * @return String representing the header to be display in front of the folder content
     */
    protected String getHeader(ITransaction transaction, String path,
            HttpServletResponse resp, HttpServletRequest req)
    {
        return "<h1>Content of folder "+path+"</h1>";
    }

    /**
     * Return the footer to be displayed after the folder content
     * 
     * @param transaction
     * @param path
     * @param resp
     * @param req
     * @return String representing the footer to be displayed after the folder content
     */
    protected String getFooter(ITransaction transaction, String path,
            HttpServletResponse resp, HttpServletRequest req)
    {
        return "";
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoHead.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.IMimeTyper;
import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.ObjectAlreadyExistsException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoHead extends AbstractMethod {

    protected String _dftIndexFile;
    protected IWebdavStore _store;
    protected String _insteadOf404;
    protected IResourceLocks _resourceLocks;
    protected IMimeTyper _mimeTyper;
    protected int _contentLength;

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoHead.class);

    public DoHead(IWebdavStore store, String dftIndexFile, String insteadOf404,
            IResourceLocks resourceLocks, IMimeTyper mimeTyper,
            int contentLengthHeader) {
        _store = store;
        _dftIndexFile = dftIndexFile;
        _insteadOf404 = insteadOf404;
        _resourceLocks = resourceLocks;
        _mimeTyper = mimeTyper;
        _contentLength = contentLengthHeader;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {

        // determines if the uri exists.

        boolean bUriExists = false;

        String path = getRelativePath(req);
        LOG.trace("-- " + this.getClass().getName());

        StoredObject so = _store.getStoredObject(transaction, path);
        if (so == null) {
            if (this._insteadOf404 != null && !_insteadOf404.trim().equals("")) {
                path = this._insteadOf404;
                so = _store.getStoredObject(transaction, this._insteadOf404);
            }
        } else
            bUriExists = true;

        if (so != null) {
            if (so.isFolder()) {
                if (_dftIndexFile != null && !_dftIndexFile.trim().equals("")) {
                    resp.sendRedirect(resp.encodeRedirectURL(req
                            .getRequestURI()
                            + this._dftIndexFile));
                    return;
                }
            } else if (so.isNullResource()) {
                String methodsAllowed = DeterminableMethod
                        .determineMethodsAllowed(so);
                resp.addHeader("Allow", methodsAllowed);
                resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
                return;
            }

            String tempLockOwner = "doGet" + System.currentTimeMillis()
                    + req.toString();

            if (_resourceLocks.lock(transaction, path, tempLockOwner, false, 0,
                    TEMP_TIMEOUT, TEMPORARY)) {
                try {

                    String eTagMatch = req.getHeader("If-None-Match");
                    if (eTagMatch != null) {
                        if (eTagMatch.equals(getETag(so))) {
                            resp.setStatus(WebdavStatus.SC_NOT_MODIFIED);
                            return;
                        }
                    }

                    if (so.isResource()) {
                        // path points to a file but ends with / or \
                        if (path.endsWith("/") || (path.endsWith("\\"))) {
                            resp.sendError(HttpServletResponse.SC_NOT_FOUND,
                                    req.getRequestURI());
                        } else {

                            // setting headers
                            long lastModified = so.getLastModified().getTime();
                            resp.setDateHeader("last-modified", lastModified);

                            String eTag = getETag(so);
                            resp.addHeader("ETag", eTag);

                            long resourceLength = so.getResourceLength();

                            if (_contentLength == 1) {
                                if (resourceLength > 0) {
                                    if (resourceLength <= Integer.MAX_VALUE) {
                                        resp
                                                .setContentLength((int) resourceLength);
                                    } else {
                                        resp.setHeader("content-length", ""
                                                + resourceLength);
                                        // is "content-length" the right header?
                                        // is long a valid format?
                                    }
                                }
                            }

                            String mimeType;
                            if (_mimeTyper!=null){
                            	mimeType = _mimeTyper.getMimeType(path);
                            }else{
                            	mimeType = req.getSession().getServletContext().getMimeType(path);
                            }
                            
                            if (mimeType != null) {
                                resp.setContentType(mimeType);
                            } else {
                                int lastSlash = path.replace('\\', '/')
                                        .lastIndexOf('/');
                                int lastDot = path.indexOf(".", lastSlash);
                                if (lastDot == -1) {
                                    resp.setContentType("text/html");
                                }
                            }

                            doBody(transaction, resp, path);
                        }
                    } else {
                        folderBody(transaction, path, resp, req);
                    }
                } catch (AccessDeniedException e) {
                    resp.sendError(WebdavStatus.SC_FORBIDDEN);
                } catch (ObjectAlreadyExistsException e) {
                    resp.sendError(WebdavStatus.SC_NOT_FOUND, req
                            .getRequestURI());
                } catch (WebdavException e) {
                    resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                } finally {
                    _resourceLocks.unlockTemporaryLockedObjects(transaction,
                            path, tempLockOwner);
                }
            } else {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            }
        } else {
            folderBody(transaction, path, resp, req);
        }

        if (!bUriExists)
            resp.setStatus(WebdavStatus.SC_NOT_FOUND);

    }

    protected void folderBody(ITransaction transaction, String path,
            HttpServletResponse resp, HttpServletRequest req)
            throws IOException {
        // no body for HEAD
    }

    protected void doBody(ITransaction transaction, HttpServletResponse resp,
            String path) throws IOException {
        // no body for HEAD
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoLock.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.HashMap;
import java.util.Hashtable;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.fromcatalina.XMLWriter;
import com.ejie.x38.webdav.locking.IResourceLocks;
import com.ejie.x38.webdav.locking.LockedObject;

public class DoLock extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoLock.class);

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;
    private boolean _readOnly;

    private boolean _macLockRequest = false;

    private boolean _exclusive = false;
    private String _type = null;
    private String _lockOwner = null;

    private String _path = null;
    private String _parentPath = null;

    private String _userAgent = null;

    public DoLock(IWebdavStore store, IResourceLocks resourceLocks,
            boolean readOnly) {
        _store = store;
        _resourceLocks = resourceLocks;
        _readOnly = readOnly;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        if (_readOnly) {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
            return;
        } else {
            _path = getRelativePath(req);
            _parentPath = getParentPath(getCleanPath(_path));

            Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();

            if (!checkLocks(transaction, req, resp, _resourceLocks, _path)) {
                errorList.put(_path, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return; // resource is locked
            }

            if (!checkLocks(transaction, req, resp, _resourceLocks, _parentPath)) {
                errorList.put(_parentPath, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return; // parent is locked
            }

            // Mac OS Finder (whether 10.4.x or 10.5) can't store files
            // because executing a LOCK without lock information causes a
            // SC_BAD_REQUEST
            _userAgent = req.getHeader("User-Agent");
            if (_userAgent != null && _userAgent.indexOf("Darwin") != -1) {
                _macLockRequest = true;

                String timeString = Long.valueOf(System.currentTimeMillis())
                        .toString();
                _lockOwner = _userAgent.concat(timeString);
            }

            String tempLockOwner = "doLock" + System.currentTimeMillis()
                    + req.toString();
            if (_resourceLocks.lock(transaction, _path, tempLockOwner, false,
                    0, TEMP_TIMEOUT, TEMPORARY)) {
                try {
                    if (req.getHeader("If") != null) {
                        doRefreshLock(transaction, req, resp);
                    } else {
                        doLock(transaction, req, resp);
                    }
                } catch (LockFailedException e) {
                    resp.sendError(WebdavStatus.SC_LOCKED);
                    e.printStackTrace();
                } finally {
                    _resourceLocks.unlockTemporaryLockedObjects(transaction,
                            _path, tempLockOwner);
                }
            }
        }
    }

    private void doLock(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {

        StoredObject so = _store.getStoredObject(transaction, _path);

        if (so != null) {
            doLocking(transaction, req, resp);
        } else {
            // resource doesn't exist, null-resource lock
            doNullResourceLock(transaction, req, resp);
        }

        so = null;
        _exclusive = false;
        _type = null;
        _lockOwner = null;

    }

    private void doLocking(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException {

        // Tests if LockObject on requested path exists, and if so, tests
        // exclusivity
        LockedObject lo = _resourceLocks.getLockedObjectByPath(transaction,
                _path);
        if (lo != null) {
            if (lo.isExclusive()) {
                sendLockFailError(transaction, req, resp);
                return;
            }
        }
        try {
            // Thats the locking itself
            executeLock(transaction, req, resp);

        } catch (ServletException e) {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            LOG.trace(e.toString());
        } catch (LockFailedException e) {
            sendLockFailError(transaction, req, resp);
        } finally {
            lo = null;
        }

    }

    private void doNullResourceLock(ITransaction transaction,
            HttpServletRequest req, HttpServletResponse resp)
            throws IOException {

        StoredObject parentSo, nullSo = null;

        try {
            parentSo = _store.getStoredObject(transaction, _parentPath);
            if (_parentPath != null && parentSo == null) {
                _store.createFolder(transaction, _parentPath);
            } else if (_parentPath != null && parentSo != null
                    && parentSo.isResource()) {
                resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
                return;
            }

            nullSo = _store.getStoredObject(transaction, _path);
            if (nullSo == null) {
                // resource doesn't exist
                _store.createResource(transaction, _path);

                // Transmit expects 204 response-code, not 201
                if (_userAgent != null && _userAgent.indexOf("Transmit") != -1) {
                    LOG
                            .trace("DoLock.execute() : do workaround for user agent '"
                                    + _userAgent + "'");
                    resp.setStatus(WebdavStatus.SC_NO_CONTENT);
                } else {
                    resp.setStatus(WebdavStatus.SC_CREATED);
                }

            } else {
                // resource already exists, could not execute null-resource lock
                sendLockFailError(transaction, req, resp);
                return;
            }
            nullSo = _store.getStoredObject(transaction, _path);
            // define the newly created resource as null-resource
            nullSo.setNullResource(true);

            // Thats the locking itself
            executeLock(transaction, req, resp);

        } catch (LockFailedException e) {
            sendLockFailError(transaction, req, resp);
        } catch (WebdavException e) {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            e.printStackTrace();
        } catch (ServletException e) {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            e.printStackTrace();
        } finally {
            parentSo = null;
            nullSo = null;
        }
    }

    private void doRefreshLock(ITransaction transaction,
            HttpServletRequest req, HttpServletResponse resp)
            throws IOException, LockFailedException {

        String[] lockTokens = getLockIdFromIfHeader(req);
        String lockToken = null;
        if (lockTokens != null)
            lockToken = lockTokens[0];

        if (lockToken != null) {
            // Getting LockObject of specified lockToken in If header
            LockedObject refreshLo = _resourceLocks.getLockedObjectByID(
                    transaction, lockToken);
            if (refreshLo != null) {
                int timeout = getTimeout(transaction, req);

                refreshLo.refreshTimeout(timeout);
                // sending success response
                generateXMLReport(transaction, resp, refreshLo);

                refreshLo = null;
            } else {
                // no LockObject to given lockToken
                resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
            }

        } else {
            resp.sendError(WebdavStatus.SC_PRECONDITION_FAILED);
        }
    }

    // ------------------------------------------------- helper methods

    /**
     * Executes the LOCK
     */
    private void executeLock(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws LockFailedException, IOException,
            ServletException {

        // Mac OS lock request workaround
        if (_macLockRequest) {
            LOG.trace("DoLock.execute() : do workaround for user agent '"
                    + _userAgent + "'");

            doMacLockRequestWorkaround(transaction, req, resp);
        } else {
            // Getting LockInformation from request
            if (getLockInformation(transaction, req, resp)) {
                int depth = getDepth(req);
                int lockDuration = getTimeout(transaction, req);

                boolean lockSuccess = false;
                if (_exclusive) {
                    lockSuccess = _resourceLocks.exclusiveLock(transaction,
                            _path, _lockOwner, depth, lockDuration);
                } else {
                    lockSuccess = _resourceLocks.sharedLock(transaction, _path,
                            _lockOwner, depth, lockDuration);
                }

                if (lockSuccess) {
                    // Locks successfully placed - return information about
                    LockedObject lo = _resourceLocks.getLockedObjectByPath(
                            transaction, _path);
                    if (lo != null) {
                        generateXMLReport(transaction, resp, lo);
                    } else {
                        resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                    }
                } else {
                    sendLockFailError(transaction, req, resp);

                    throw new LockFailedException();
                }
            } else {
                // information for LOCK could not be read successfully
                resp.setContentType("text/xml; charset=UTF-8");
                resp.sendError(WebdavStatus.SC_BAD_REQUEST);
            }
        }
    }

    /**
     * Tries to get the LockInformation from LOCK request
     */
    private boolean getLockInformation(ITransaction transaction,
            HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {

        Node lockInfoNode = null;
        DocumentBuilder documentBuilder = null;

        documentBuilder = getDocumentBuilder();
        try {
            Document document = documentBuilder.parse(new InputSource(req
                    .getInputStream()));

            // Get the root element of the document
            Element rootElement = document.getDocumentElement();

            lockInfoNode = rootElement;

            if (lockInfoNode != null) {
                NodeList childList = lockInfoNode.getChildNodes();
                Node lockScopeNode = null;
                Node lockTypeNode = null;
                Node lockOwnerNode = null;

                Node currentNode = null;
                String nodeName = null;

                for (int i = 0; i < childList.getLength(); i++) {
                    currentNode = childList.item(i);

                    if (currentNode.getNodeType() == Node.ELEMENT_NODE
                            || currentNode.getNodeType() == Node.TEXT_NODE) {

                        nodeName = currentNode.getNodeName();

                        if (nodeName.endsWith("locktype")) {
                            lockTypeNode = currentNode;
                        }
                        if (nodeName.endsWith("lockscope")) {
                            lockScopeNode = currentNode;
                        }
                        if (nodeName.endsWith("owner")) {
                            lockOwnerNode = currentNode;
                        }
                    } else {
                        return false;
                    }
                }

                if (lockScopeNode != null) {
                    String scope = null;
                    childList = lockScopeNode.getChildNodes();
                    for (int i = 0; i < childList.getLength(); i++) {
                        currentNode = childList.item(i);

                        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                            scope = currentNode.getNodeName();

                            if (scope.endsWith("exclusive")) {
                                _exclusive = true;
                            } else if (scope.equals("shared")) {
                                _exclusive = false;
                            }
                        }
                    }
                    if (scope == null) {
                        return false;
                    }

                } else {
                    return false;
                }

                if (lockTypeNode != null) {
                    childList = lockTypeNode.getChildNodes();
                    for (int i = 0; i < childList.getLength(); i++) {
                        currentNode = childList.item(i);

                        if (currentNode.getNodeType() == Node.ELEMENT_NODE) {
                            _type = currentNode.getNodeName();

                            if (_type.endsWith("write")) {
                                _type = "write";
                            } else if (_type.equals("read")) {
                                _type = "read";
                            }
                        }
                    }
                    if (_type == null) {
                        return false;
                    }
                } else {
                    return false;
                }

                if (lockOwnerNode != null) {
                    childList = lockOwnerNode.getChildNodes();
                    for (int i = 0; i < childList.getLength(); i++) {
                        currentNode = childList.item(i);

                        if (currentNode.getNodeType() == Node.ELEMENT_NODE
                             || currentNode.getNodeType() == Node.TEXT_NODE ) {
                            _lockOwner = currentNode.getTextContent();
                        }
                    }
                }
                if (_lockOwner == null) {
                    return false;
                }
            } else {
                return false;
            }

        } catch (DOMException e) {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            e.printStackTrace();
            return false;
        } catch (SAXException e) {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            e.printStackTrace();
            return false;
        }

        return true;
    }

    /**
     * Ties to read the timeout from request
     */
    private int getTimeout(ITransaction transaction, HttpServletRequest req) {

        int lockDuration = DEFAULT_TIMEOUT;
        String lockDurationStr = req.getHeader("Timeout");

        if (lockDurationStr == null) {
            lockDuration = DEFAULT_TIMEOUT;
        } else {
            int commaPos = lockDurationStr.indexOf(',');
            // if multiple timeouts, just use the first one
            if (commaPos != -1) {
                lockDurationStr = lockDurationStr.substring(0, commaPos);
            }
            if (lockDurationStr.startsWith("Second-")) {
                lockDuration = Integer.valueOf(lockDurationStr.substring(7))
                        .intValue();
            } else {
                if (lockDurationStr.equalsIgnoreCase("infinity")) {
                    lockDuration = MAX_TIMEOUT;
                } else {
                    try {
                        lockDuration = Integer.valueOf(lockDurationStr).intValue();
                    } catch (NumberFormatException e) {
                        lockDuration = MAX_TIMEOUT;
                    }
                }
            }
            if (lockDuration <= 0) {
                lockDuration = DEFAULT_TIMEOUT;
            }
            if (lockDuration > MAX_TIMEOUT) {
                lockDuration = MAX_TIMEOUT;
            }
        }
        return lockDuration;
    }

    /**
     * Generates the response XML with all lock information
     */
    private void generateXMLReport(ITransaction transaction,
            HttpServletResponse resp, LockedObject lo) throws IOException {

        HashMap<String, String> namespaces = new HashMap<String, String>();
        namespaces.put("DAV:", "D");

        resp.setStatus(WebdavStatus.SC_OK);
        resp.setContentType("text/xml; charset=UTF-8");

        XMLWriter generatedXML = new XMLWriter(resp.getWriter(), namespaces);
        generatedXML.writeXMLHeader();
        generatedXML.writeElement("DAV::prop", XMLWriter.OPENING);
        generatedXML.writeElement("DAV::lockdiscovery", XMLWriter.OPENING);
        generatedXML.writeElement("DAV::activelock", XMLWriter.OPENING);

        generatedXML.writeElement("DAV::locktype", XMLWriter.OPENING);
        generatedXML.writeProperty("DAV::" + _type);
        generatedXML.writeElement("DAV::locktype", XMLWriter.CLOSING);

        generatedXML.writeElement("DAV::lockscope", XMLWriter.OPENING);
        if (_exclusive) {
            generatedXML.writeProperty("DAV::exclusive");
        } else {
            generatedXML.writeProperty("DAV::shared");
        }
        generatedXML.writeElement("DAV::lockscope", XMLWriter.CLOSING);

        int depth = lo.getLockDepth();

        generatedXML.writeElement("DAV::depth", XMLWriter.OPENING);
        if (depth == INFINITY) {
            generatedXML.writeText("Infinity");
        } else {
            generatedXML.writeText(String.valueOf(depth));
        }
        generatedXML.writeElement("DAV::depth", XMLWriter.CLOSING);

        generatedXML.writeElement("DAV::owner", XMLWriter.OPENING);
     // encapsulating the owner with an href-element will trigger the bug
//        generatedXML.writeElement("DAV::href", XMLWriter.OPENING);
        generatedXML.writeText(_lockOwner);
//        generatedXML.writeElement("DAV::href", XMLWriter.CLOSING);
        generatedXML.writeElement("DAV::owner", XMLWriter.CLOSING);

        long timeout = lo.getTimeoutMillis();
        generatedXML.writeElement("DAV::timeout", XMLWriter.OPENING);
        generatedXML.writeText("Second-" + timeout / 1000);
        generatedXML.writeElement("DAV::timeout", XMLWriter.CLOSING);

        String lockToken = lo.getID();
        generatedXML.writeElement("DAV::locktoken", XMLWriter.OPENING);
        generatedXML.writeElement("DAV::href", XMLWriter.OPENING);
        generatedXML.writeText("opaquelocktoken:" + lockToken);
        generatedXML.writeElement("DAV::href", XMLWriter.CLOSING);
        generatedXML.writeElement("DAV::locktoken", XMLWriter.CLOSING);

        generatedXML.writeElement("DAV::activelock", XMLWriter.CLOSING);
        generatedXML.writeElement("DAV::lockdiscovery", XMLWriter.CLOSING);
        generatedXML.writeElement("DAV::prop", XMLWriter.CLOSING);

        resp.addHeader("Lock-Token", "<opaquelocktoken:" + lockToken + ">");

        generatedXML.sendData();

    }

    /**
     * Executes the lock for a Mac OS Finder client
     */
    private void doMacLockRequestWorkaround(ITransaction transaction,
            HttpServletRequest req, HttpServletResponse resp)
            throws LockFailedException, IOException {
        LockedObject lo;
        int depth = getDepth(req);
        int lockDuration = getTimeout(transaction, req);
        if (lockDuration < 0 || lockDuration > MAX_TIMEOUT)
            lockDuration = DEFAULT_TIMEOUT;

        boolean lockSuccess = false;
        lockSuccess = _resourceLocks.exclusiveLock(transaction, _path,
                _lockOwner, depth, lockDuration);

        if (lockSuccess) {
            // Locks successfully placed - return information about
            lo = _resourceLocks.getLockedObjectByPath(transaction, _path);
            if (lo != null) {
                generateXMLReport(transaction, resp, lo);
            } else {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            }
        } else {
            // Locking was not successful
            sendLockFailError(transaction, req, resp);
        }
    }

    /**
     * Sends an error report to the client
     */
    private void sendLockFailError(ITransaction transaction,
            HttpServletRequest req, HttpServletResponse resp)
            throws IOException {
        Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();
        errorList.put(_path, WebdavStatus.SC_LOCKED);
        sendReport(req, resp, errorList);
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoMkcol.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.Hashtable;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;
import com.ejie.x38.webdav.locking.LockedObject;

public class DoMkcol extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoMkcol.class);

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;
    private boolean _readOnly;

    public DoMkcol(IWebdavStore store, IResourceLocks resourceLocks,
            boolean readOnly) {
        _store = store;
        _resourceLocks = resourceLocks;
        _readOnly = readOnly;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        if (!_readOnly) {
            String path = getRelativePath(req);
            String parentPath = getParentPath(getCleanPath(path));

            Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();

            if (!checkLocks(transaction, req, resp, _resourceLocks, parentPath)) {
                // TODO remove
                LOG
                        .trace("MkCol on locked resource (parentPath) not executable!"
                                + "\n Sending SC_FORBIDDEN (403) error response!");

                resp.sendError(WebdavStatus.SC_FORBIDDEN);
                return;
            }

            String tempLockOwner = "doMkcol" + System.currentTimeMillis()
                    + req.toString();

            if (_resourceLocks.lock(transaction, path, tempLockOwner, false, 0,
                    TEMP_TIMEOUT, TEMPORARY)) {
                StoredObject parentSo, so = null;
                try {
                    parentSo = _store.getStoredObject(transaction, parentPath);
					if (parentSo == null) {
						// parent not exists
						resp.sendError(WebdavStatus.SC_CONFLICT);
						return;
					}
					if (parentPath != null && parentSo.isFolder()) {
                        so = _store.getStoredObject(transaction, path);
                        if (so == null) {
                            _store.createFolder(transaction, path);
                            resp.setStatus(WebdavStatus.SC_CREATED);
                        } else {
                            // object already exists
                            if (so.isNullResource()) {

                                LockedObject nullResourceLo = _resourceLocks
                                        .getLockedObjectByPath(transaction,
                                                path);
                                if (nullResourceLo == null) {
                                    resp
                                            .sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                                    return;
                                }
                                String nullResourceLockToken = nullResourceLo
                                        .getID();
                                String[] lockTokens = getLockIdFromIfHeader(req);
                                String lockToken = null;
                                if (lockTokens != null)
                                    lockToken = lockTokens[0];
                                else {
                                    resp.sendError(WebdavStatus.SC_BAD_REQUEST);
                                    return;
                                }
                                if (lockToken.equals(nullResourceLockToken)) {
                                    so.setNullResource(false);
                                    so.setFolder(true);

                                    String[] nullResourceLockOwners = nullResourceLo
                                            .getOwner();
                                    String owner = null;
                                    if (nullResourceLockOwners != null)
                                        owner = nullResourceLockOwners[0];

                                    if (_resourceLocks.unlock(transaction,
                                            lockToken, owner)) {
                                        resp.setStatus(WebdavStatus.SC_CREATED);
                                    } else {
                                        resp
                                                .sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                                    }

                                } else {
                                    // TODO remove
                                    LOG
                                            .trace("MkCol on lock-null-resource with wrong lock-token!"
                                                    + "\n Sending multistatus error report!");

                                    errorList.put(path, WebdavStatus.SC_LOCKED);
                                    sendReport(req, resp, errorList);
                                }

                            } else {
                                String methodsAllowed = DeterminableMethod
                                        .determineMethodsAllowed(so);
                                resp.addHeader("Allow", methodsAllowed);
                                resp
                                        .sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
                            }
                        }

					} else if (parentPath != null && parentSo.isResource()) {
                        // TODO remove
                        LOG
                                .trace("MkCol on resource is not executable"
                                        + "\n Sending SC_METHOD_NOT_ALLOWED (405) error response!");

                        String methodsAllowed = DeterminableMethod
                                .determineMethodsAllowed(parentSo);
                        resp.addHeader("Allow", methodsAllowed);
                        resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);

                    } else {
                        resp.sendError(WebdavStatus.SC_FORBIDDEN);
                    }
                } catch (AccessDeniedException e) {
                    resp.sendError(WebdavStatus.SC_FORBIDDEN);
                } catch (WebdavException e) {
                    resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                } finally {
                    _resourceLocks.unlockTemporaryLockedObjects(transaction,
                            path, tempLockOwner);
                }
            } else {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            }

        } else {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
        }
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoMove.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.Hashtable;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.ObjectAlreadyExistsException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoMove extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoMove.class);

    private IResourceLocks _resourceLocks;
    private DoDelete _doDelete;
    private DoCopy _doCopy;
    private boolean _readOnly;

    public DoMove(IResourceLocks resourceLocks, DoDelete doDelete,
            DoCopy doCopy, boolean readOnly) {
        _resourceLocks = resourceLocks;
        _doDelete = doDelete;
        _doCopy = doCopy;
        _readOnly = readOnly;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {

        if (!_readOnly) {
            LOG.trace("-- " + this.getClass().getName());

            String sourcePath = getRelativePath(req);
            Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();

            if (!checkLocks(transaction, req, resp, _resourceLocks, sourcePath)) {
                errorList.put(sourcePath, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return;
            }

            String destinationPath = req.getHeader("Destination");
            if (destinationPath == null) {
                resp.sendError(WebdavStatus.SC_BAD_REQUEST);
                return;
            }

            if (!checkLocks(transaction, req, resp, _resourceLocks,
                    destinationPath)) {
                errorList.put(destinationPath, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return;
            }

            String tempLockOwner = "doMove" + System.currentTimeMillis()
                    + req.toString();

            if (_resourceLocks.lock(transaction, sourcePath, tempLockOwner,
                    false, 0, TEMP_TIMEOUT, TEMPORARY)) {
                try {

                    if (_doCopy.copyResource(transaction, req, resp)) {

                        errorList = new Hashtable<String, Integer>();
                        _doDelete.deleteResource(transaction, sourcePath,
                                errorList, req, resp);
                        if (!errorList.isEmpty()) {
                            sendReport(req, resp, errorList);
                        }
                    }

                } catch (AccessDeniedException e) {
                    resp.sendError(WebdavStatus.SC_FORBIDDEN);
                } catch (ObjectAlreadyExistsException e) {
                    resp.sendError(WebdavStatus.SC_NOT_FOUND, req
                            .getRequestURI());
                } catch (WebdavException e) {
                    resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                } finally {
                    _resourceLocks.unlockTemporaryLockedObjects(transaction,
                            sourcePath, tempLockOwner);
                }
            } else {
                errorList.put(req.getHeader("Destination"),
                        WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
            }
        } else {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);

        }

    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoNotImplemented.java
================================================
package com.ejie.x38.webdav.methods;

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.IMethodExecutor;
import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.WebdavStatus;

public class DoNotImplemented implements IMethodExecutor {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoNotImplemented.class);
    private boolean _readOnly;

    public DoNotImplemented(boolean readOnly) {
        _readOnly = readOnly;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException {
        LOG.trace("-- " + req.getMethod());

        if (_readOnly) {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
        } else
            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED);
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoOptions.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoOptions extends DeterminableMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoOptions.class);

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;

    public DoOptions(IWebdavStore store, IResourceLocks resLocks) {
        _store = store;
        _resourceLocks = resLocks;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {

        LOG.trace("-- " + this.getClass().getName());

        String tempLockOwner = "doOptions" + System.currentTimeMillis()
                + req.toString();
        String path = getRelativePath(req);
        if (_resourceLocks.lock(transaction, path, tempLockOwner, false, 0,
                TEMP_TIMEOUT, TEMPORARY)) {
            StoredObject so = null;
            try {
                resp.addHeader("DAV", "1, 2");

                so = _store.getStoredObject(transaction, path);
                String methodsAllowed = determineMethodsAllowed(so);
                resp.addHeader("Allow", methodsAllowed);
                resp.addHeader("MS-Author-Via", "DAV");
            } catch (AccessDeniedException e) {
                resp.sendError(WebdavStatus.SC_FORBIDDEN);
            } catch (WebdavException e) {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            } finally {
                _resourceLocks.unlockTemporaryLockedObjects(transaction, path,
                        tempLockOwner);
            }
        } else {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
        }
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoPropfind.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

import com.ejie.x38.webdav.IMimeTyper;
import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.fromcatalina.XMLHelper;
import com.ejie.x38.webdav.fromcatalina.XMLWriter;
import com.ejie.x38.webdav.locking.LockedObject;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoPropfind extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoPropfind.class);

    /**
     * PROPFIND - Specify a property mask.
     */
    private static final int FIND_BY_PROPERTY = 0;

    /**
     * PROPFIND - Display all properties.
     */
    private static final int FIND_ALL_PROP = 1;

    /**
     * PROPFIND - Return property names.
     */
    private static final int FIND_PROPERTY_NAMES = 2;

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;
    private IMimeTyper _mimeTyper;

    private int _depth;

    public DoPropfind(IWebdavStore store, IResourceLocks resLocks,
            IMimeTyper mimeTyper) {
        _store = store;
        _resourceLocks = resLocks;
        _mimeTyper = mimeTyper;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        // Retrieve the resources
        String path = getCleanPath(getRelativePath(req));
        String tempLockOwner = "doPropfind" + System.currentTimeMillis()
                + req.toString();
        _depth = getDepth(req);

        if (_resourceLocks.lock(transaction, path, tempLockOwner, false,
                _depth, TEMP_TIMEOUT, TEMPORARY)) {

            StoredObject so = null;
            try {
                so = _store.getStoredObject(transaction, path);
                if (so == null) {
                    resp.setContentType("text/xml; charset=UTF-8");
                    resp.sendError(HttpServletResponse.SC_NOT_FOUND, req
                            .getRequestURI());
                    return;
                }

                List<String> properties = null;
                path = getCleanPath(getRelativePath(req));

                int propertyFindType = FIND_ALL_PROP;
                Node propNode = null;

                // Windows 7 does a propfind with content length 0
                if (req.getContentLength() > 0)
                {
                    DocumentBuilder documentBuilder = getDocumentBuilder();
                    try {
                        Document document = documentBuilder
                                .parse(new InputSource(req.getInputStream()));
                        // Get the root element of the document
                        Element rootElement = document.getDocumentElement();

                        propNode = XMLHelper
                                .findSubElement(rootElement, "prop");
                        if (propNode != null) {
                            propertyFindType = FIND_BY_PROPERTY;
                        } else if (XMLHelper.findSubElement(rootElement,
                                "propname") != null) {
                            propertyFindType = FIND_PROPERTY_NAMES;
                        } else if (XMLHelper.findSubElement(rootElement,
                                "allprop") != null) {
                            propertyFindType = FIND_ALL_PROP;
                        }
                    } catch (Exception e) {
                        resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                        return;
                    }
                } else {
                    // no content, which means it is a allprop request
                    propertyFindType = FIND_ALL_PROP;
                }

                HashMap<String, String> namespaces = new HashMap<String, String>();
                namespaces.put("DAV:", "D");

                if (propertyFindType == FIND_BY_PROPERTY) {
                    propertyFindType = 0;
                    properties = XMLHelper.getPropertiesFromXML(propNode);
                }

                resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
                resp.setContentType("text/xml; charset=UTF-8");

                // Create multistatus object
                XMLWriter generatedXML = new XMLWriter(resp.getWriter(),
                        namespaces);
                generatedXML.writeXMLHeader();
                generatedXML
                        .writeElement("DAV::multistatus", XMLWriter.OPENING);
                
                String mimeType;
                if (_mimeTyper!=null){
                	mimeType = _mimeTyper.getMimeType(path);
                }else{
                	mimeType = req.getSession().getServletContext().getMimeType(path);
                }
                
                
                if (_depth == 0) {
                    parseProperties(transaction, req, generatedXML, path,
                            propertyFindType, properties, mimeType);
                } else {
                    recursiveParseProperties(transaction, path, req,
                            generatedXML, propertyFindType, properties, _depth,
                            mimeType);
                }
                generatedXML
                        .writeElement("DAV::multistatus", XMLWriter.CLOSING);

                generatedXML.sendData();
            } catch (AccessDeniedException e) {
                resp.sendError(WebdavStatus.SC_FORBIDDEN);
            } catch (WebdavException e) {
                LOG.warn("Sending internal error!");
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            } catch (ServletException e) {
                e.printStackTrace(); // To change body of catch statement use
                // File | Settings | File Templates.
            } finally {
                _resourceLocks.unlockTemporaryLockedObjects(transaction, path,
                        tempLockOwner);
            }
        } else {
            Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();
            errorList.put(path, WebdavStatus.SC_LOCKED);
            sendReport(req, resp, errorList);
        }
    }

    /**
     * goes recursive through all folders. used by propfind
     * 
     * @param currentPath
     *      the current path
     * @param req
     *      HttpServletRequest
     * @param generatedXML
     * @param propertyFindType
     * @param properties
     * @param depth
     *      depth of the propfind
     * @throws IOException
     *      if an error in the underlying store occurs
     */
    private void recursiveParseProperties(ITransaction transaction,
            String currentPath, HttpServletRequest req, XMLWriter generatedXML,
            int propertyFindType, List<String> properties, int depth,
            String mimeType) throws WebdavException {

        parseProperties(transaction, req, generatedXML, currentPath,
                propertyFindType, properties, mimeType);

        if (depth > 0) {
            // no need to get name if depth is already zero
            String[] names = _store.getChildrenNames(transaction, currentPath);
            names = names == null ? new String[] {} : names;
            String newPath = null;

            for (String name : names) {
                newPath = currentPath;
                if (!(newPath.endsWith("/"))) {
                    newPath += "/";
                }
                newPath += name;
                recursiveParseProperties(transaction, newPath, req,
                        generatedXML, propertyFindType, properties, depth - 1,
                        mimeType);
            }
        }
    }

    /**
     * Propfind helper method.
     * 
     * @param req
     *      The servlet request
     * @param generatedXML
     *      XML response to the Propfind request
     * @param path
     *      Path of the current resource
     * @param type
     *      Propfind type
     * @param propertiesVector
     *      If the propfind type is find properties by name, then this Vector
     *      contains those properties
     */
    private void parseProperties(ITransaction transaction,
            HttpServletRequest req, XMLWriter generatedXML, String path,
            int type, List<String> propertiesVector, String mimeType)
            throws WebdavException {

        StoredObject so = _store.getStoredObject(transaction, path);

        boolean isFolder = so.isFolder();
        String creationdate = CREATION_DATE_FORMAT.format(so.getCreationDate());
        String lastModified = LAST_MODIFIED_DATE_FORMAT.format(so
                .getLastModified());
        String resourceLength = String.valueOf(so.getResourceLength());

        // ResourceInfo resourceInfo = new ResourceInfo(path, resources);

        generatedXML.writeElement("DAV::response", XMLWriter.OPENING);
        String status = new String("HTTP/1.1 " + WebdavStatus.SC_OK + " "
                + WebdavStatus.getStatusText(WebdavStatus.SC_OK));

        // Generating href element
        generatedXML.writeElement("DAV::href", XMLWriter.OPENING);

        String href = req.getContextPath();
        String servletPath = req.getServletPath();
        if (servletPath != null) {
            if ((href.endsWith("/")) && (servletPath.startsWith("/")))
                href += servletPath.substring(1);
            else
                href += servletPath;
        }
        if ((href.endsWith("/")) && (path.startsWith("/")))
            href += path.substring(1);
        else
            href += path;
        if ((isFolder) && (!href.endsWith("/")))
            href += "/";

        generatedXML.writeText(rewriteUrl(href));

        generatedXML.writeElement("DAV::href", XMLWriter.CLOSING);

        String resourceName = path;
        int lastSlash = path.lastIndexOf('/');
        if (lastSlash != -1)
            resourceName = resourceName.substring(lastSlash + 1);

        switch (type) {

        case FIND_ALL_PROP:

            generatedXML.writeElement("DAV::propstat", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::prop", XMLWriter.OPENING);

            generatedXML.writeProperty("DAV::creationdate", creationdate);
            generatedXML.writeElement("DAV::displayname", XMLWriter.OPENING);
            generatedXML.writeData(resourceName);
            generatedXML.writeElement("DAV::displayname", XMLWriter.CLOSING);
            if (!isFolder) {
                generatedXML
                        .writeProperty("DAV::getlastmodified", lastModified);
                generatedXML.writeProperty("DAV::getcontentlength",
                        resourceLength);
                String contentType = mimeType;
                if (contentType != null) {
                    generatedXML.writeProperty("DAV::getcontenttype",
                            contentType);
                }
                generatedXML.writeProperty("DAV::getetag", getETag(so));
                generatedXML.writeElement("DAV::resourcetype",
                        XMLWriter.NO_CONTENT);
            } else {
                generatedXML.writeElement("DAV::resourcetype",
                        XMLWriter.OPENING);
                generatedXML.writeElement("DAV::collection",
                        XMLWriter.NO_CONTENT);
                generatedXML.writeElement("DAV::resourcetype",
                        XMLWriter.CLOSING);
            }

            writeSupportedLockElements(transaction, generatedXML, path);

            writeLockDiscoveryElements(transaction, generatedXML, path);

            generatedXML.writeProperty("DAV::source", "");
            generatedXML.writeElement("DAV::prop", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::status", XMLWriter.OPENING);
            generatedXML.writeText(status);
            generatedXML.writeElement("DAV::status", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::propstat", XMLWriter.CLOSING);

            break;

        case FIND_PROPERTY_NAMES:

            generatedXML.writeElement("DAV::propstat", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::prop", XMLWriter.OPENING);

            generatedXML
                    .writeElement("DAV::creationdate", XMLWriter.NO_CONTENT);
            generatedXML.writeElement("DAV::displayname", XMLWriter.NO_CONTENT);
            if (!isFolder) {
                generatedXML.writeElement("DAV::getcontentlanguage",
                        XMLWriter.NO_CONTENT);
                generatedXML.writeElement("DAV::getcontentlength",
                        XMLWriter.NO_CONTENT);
                generatedXML.writeElement("DAV::getcontenttype",
                        XMLWriter.NO_CONTENT);
                generatedXML.writeElement("DAV::getetag", XMLWriter.NO_CONTENT);
                generatedXML.writeElement("DAV::getlastmodified",
                        XMLWriter.NO_CONTENT);
            }
            generatedXML
                    .writeElement("DAV::resourcetype", XMLWriter.NO_CONTENT);
            generatedXML.writeElement("DAV::supportedlock",
                    XMLWriter.NO_CONTENT);
            generatedXML.writeElement("DAV::source", XMLWriter.NO_CONTENT);

            generatedXML.writeElement("DAV::prop", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::status", XMLWriter.OPENING);
            generatedXML.writeText(status);
            generatedXML.writeElement("DAV::status", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::propstat", XMLWriter.CLOSING);

            break;

        case FIND_BY_PROPERTY:

            List<String> propertiesNotFound = new ArrayList<String>();

            // Parse the list of properties

            generatedXML.writeElement("DAV::propstat", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::prop", XMLWriter.OPENING);

            Iterator<String> properties = propertiesVector.iterator();

            while (properties.hasNext()) {

                String property = properties.next();

                if (property.equals("DAV::creationdate")) {
                    generatedXML.writeProperty("DAV::creationdate",
                            creationdate);
                } else if (property.equals("DAV::displayname")) {
                    generatedXML.writeElement("DAV::displayname",
                            XMLWriter.OPENING);
                    generatedXML.writeData(resourceName);
                    generatedXML.writeElement("DAV::displayname",
                            XMLWriter.CLOSING);
                } else if (property.equals("DAV::getcontentlanguage")) {
                    if (isFolder) {
                        propertiesNotFound.add(property);
                    } else {
                        generatedXML.writeElement("DAV::getcontentlanguage",
                                XMLWriter.NO_CONTENT);
                    }
                } else if (property.equals("DAV::getcontentlength")) {
                    if (isFolder) {
                        propertiesNotFound.add(property);
                    } else {
                        generatedXML.writeProperty("DAV::getcontentlength",
                                resourceLength);
                    }
                } else if (property.equals("DAV::getcontenttype")) {
                    if (isFolder) {
                        propertiesNotFound.add(property);
                    } else {
                        generatedXML.writeProperty("DAV::getcontenttype",
                                mimeType);
                    }
                } else if (property.equals("DAV::getetag")) {
                    if (isFolder || so.isNullResource()) {
                        propertiesNotFound.add(property);
                    } else {
                        generatedXML.writeProperty("DAV::getetag", getETag(so));
                    }
                } else if (property.equals("DAV::getlastmodified")) {
                    if (isFolder) {
                        propertiesNotFound.add(property);
                    } else {
                        generatedXML.writeProperty("DAV::getlastmodified",
                                lastModified);
                    }
                } else if (property.equals("DAV::resourcetype")) {
                    if (isFolder) {
                        generatedXML.writeElement("DAV::resourcetype",
                                XMLWriter.OPENING);
                        generatedXML.writeElement("DAV::collection",
                                XMLWriter.NO_CONTENT);
                        generatedXML.writeElement("DAV::resourcetype",
                                XMLWriter.CLOSING);
                    } else {
                        generatedXML.writeElement("DAV::resourcetype",
                                XMLWriter.NO_CONTENT);
                    }
                } else if (property.equals("DAV::source")) {
                    generatedXML.writeProperty("DAV::source", "");
                } else if (property.equals("DAV::supportedlock")) {

                    writeSupportedLockElements(transaction, generatedXML, path);

                } else if (property.equals("DAV::lockdiscovery")) {

                    writeLockDiscoveryElements(transaction, generatedXML, path);

                } else {
                    propertiesNotFound.add(property);
                }

            }

            generatedXML.writeElement("DAV::prop", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::status", XMLWriter.OPENING);
            generatedXML.writeText(status);
            generatedXML.writeElement("DAV::status", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::propstat", XMLWriter.CLOSING);

            Iterator<String> propertiesNotFoundList = propertiesNotFound
                    .iterator();

            if (propertiesNotFoundList.hasNext()) {

                status = new String("HTTP/1.1 " + WebdavStatus.SC_NOT_FOUND
                        + " "
                        + WebdavStatus.getStatusText(WebdavStatus.SC_NOT_FOUND));

                generatedXML.writeElement("DAV::propstat", XMLWriter.OPENING);
                generatedXML.writeElement("DAV::prop", XMLWriter.OPENING);

                while (propertiesNotFoundList.hasNext()) {
                    generatedXML.writeElement((String) propertiesNotFoundList
                            .next(), XMLWriter.NO_CONTENT);
                }

                generatedXML.writeElement("DAV::prop", XMLWriter.CLOSING);
                generatedXML.writeElement("DAV::status", XMLWriter.OPENING);
                generatedXML.writeText(status);
                generatedXML.writeElement("DAV::status", XMLWriter.CLOSING);
                generatedXML.writeElement("DAV::propstat", XMLWriter.CLOSING);

            }

            break;

        }

        generatedXML.writeElement("DAV::response", XMLWriter.CLOSING);

        so = null;
    }

    private void writeSupportedLockElements(ITransaction transaction,
            XMLWriter generatedXML, String path) {

        LockedObject lo = _resourceLocks.getLockedObjectByPath(transaction,
                path);

        generatedXML.writeElement("DAV::supportedlock", XMLWriter.OPENING);

        if (lo == null) {
            // both locks (shared/exclusive) can be granted
            generatedXML.writeElement("DAV::lockentry", XMLWriter.OPENING);

            generatedXML.writeElement("DAV::lockscope", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::exclusive", XMLWriter.NO_CONTENT);
            generatedXML.writeElement("DAV::lockscope", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::locktype", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::write", XMLWriter.NO_CONTENT);
            generatedXML.writeElement("DAV::locktype", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::lockentry", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::lockentry", XMLWriter.OPENING);

            generatedXML.writeElement("DAV::lockscope", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::shared", XMLWriter.NO_CONTENT);
            generatedXML.writeElement("DAV::lockscope", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::locktype", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::write", XMLWriter.NO_CONTENT);
            generatedXML.writeElement("DAV::locktype", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::lockentry", XMLWriter.CLOSING);

        } else {
            // LockObject exists, checking lock state
            // if an exclusive lock exists, no further lock is possible
            if (lo.isShared()) {

                generatedXML.writeElement("DAV::lockentry", XMLWriter.OPENING);

                generatedXML.writeElement("DAV::lockscope", XMLWriter.OPENING);
                generatedXML.writeElement("DAV::shared", XMLWriter.NO_CONTENT);
                generatedXML.writeElement("DAV::lockscope", XMLWriter.CLOSING);

                generatedXML.writeElement("DAV::locktype", XMLWriter.OPENING);
                generatedXML.writeElement("DAV::" + lo.getType(),
                        XMLWriter.NO_CONTENT);
                generatedXML.writeElement("DAV::locktype", XMLWriter.CLOSING);

                generatedXML.writeElement("DAV::lockentry", XMLWriter.CLOSING);
            }
        }

        generatedXML.writeElement("DAV::supportedlock", XMLWriter.CLOSING);

        lo = null;
    }

    private void writeLockDiscoveryElements(ITransaction transaction,
            XMLWriter generatedXML, String path) {

        LockedObject lo = _resourceLocks.getLockedObjectByPath(transaction,
                path);

        if (lo != null && !lo.hasExpired()) {

            generatedXML.writeElement("DAV::lockdiscovery", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::activelock", XMLWriter.OPENING);

            generatedXML.writeElement("DAV::locktype", XMLWriter.OPENING);
            generatedXML.writeProperty("DAV::" + lo.getType());
            generatedXML.writeElement("DAV::locktype", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::lockscope", XMLWriter.OPENING);
            if (lo.isExclusive()) {
                generatedXML.writeProperty("DAV::exclusive");
            } else {
                generatedXML.writeProperty("DAV::shared");
            }
            generatedXML.writeElement("DAV::lockscope", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::depth", XMLWriter.OPENING);
            if (_depth == INFINITY) {
                generatedXML.writeText("Infinity");
            } else {
                generatedXML.writeText(String.valueOf(_depth));
            }
            generatedXML.writeElement("DAV::depth", XMLWriter.CLOSING);

            String[] owners = lo.getOwner();
            if (owners != null) {
                for (int i = 0; i < owners.length; i++) {
                    generatedXML.writeElement("DAV::owner", XMLWriter.OPENING);
                    generatedXML.writeElement("DAV::href", XMLWriter.OPENING);
                    generatedXML.writeText(owners[i]);
                    generatedXML.writeElement("DAV::href", XMLWriter.CLOSING);
                    generatedXML.writeElement("DAV::owner", XMLWriter.CLOSING);
                }
            } else {
                generatedXML.writeElement("DAV::owner", XMLWriter.NO_CONTENT);
            }

            int timeout = (int) (lo.getTimeoutMillis() / 1000);
            String timeoutStr = Integer.valueOf(timeout).toString();
            generatedXML.writeElement("DAV::timeout", XMLWriter.OPENING);
            generatedXML.writeText("Second-" + timeoutStr);
            generatedXML.writeElement("DAV::timeout", XMLWriter.CLOSING);

            String lockToken = lo.getID();

            generatedXML.writeElement("DAV::locktoken", XMLWriter.OPENING);
            generatedXML.writeElement("DAV::href", XMLWriter.OPENING);
            generatedXML.writeText("opaquelocktoken:" + lockToken);
            generatedXML.writeElement("DAV::href", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::locktoken", XMLWriter.CLOSING);

            generatedXML.writeElement("DAV::activelock", XMLWriter.CLOSING);
            generatedXML.writeElement("DAV::lockdiscovery", XMLWriter.CLOSING);

        } else {
            generatedXML.writeElement("DAV::lockdiscovery",
                    XMLWriter.NO_CONTENT);
        }

        lo = null;
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoProppatch.java
================================================
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Vector;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.parsers.DocumentBuilder;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.xml.sax.InputSource;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.fromcatalina.XMLHelper;
import com.ejie.x38.webdav.fromcatalina.XMLWriter;
import com.ejie.x38.webdav.locking.LockedObject;
import com.ejie.x38.webdav.locking.IResourceLocks;

public class DoProppatch extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoProppatch.class);

    private boolean _readOnly;
    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;

    public DoProppatch(IWebdavStore store, IResourceLocks resLocks,
            boolean readOnly) {
        _readOnly = readOnly;
        _store = store;
        _resourceLocks = resLocks;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        if (_readOnly) {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
            return;
        }

        String path = getRelativePath(req);
        String parentPath = getParentPath(getCleanPath(path));

        Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();

        if (!checkLocks(transaction, req, resp, _resourceLocks, parentPath)) {
            errorList.put(parentPath, WebdavStatus.SC_LOCKED);
            sendReport(req, resp, errorList);
            return; // parent is locked
        }

        if (!checkLocks(transaction, req, resp, _resourceLocks, path)) {
            errorList.put(path, WebdavStatus.SC_LOCKED);
            sendReport(req, resp, errorList);
            return; // resource is locked
        }

        // TODO for now, PROPPATCH just sends a valid response, stating that
        // everything is fine, but doesn't do anything.

        // Retrieve the resources
        String tempLockOwner = "doProppatch" + System.currentTimeMillis()
                + req.toString();

        if (_resourceLocks.lock(transaction, path, tempLockOwner, false, 0,
                TEMP_TIMEOUT, TEMPORARY)) {
            StoredObject so = null;
            LockedObject lo = null;
            try {
                so = _store.getStoredObject(transaction, path);
                lo = _resourceLocks.getLockedObjectByPath(transaction,
                        getCleanPath(path));

                if (so == null) {
                    resp.sendError(HttpServletResponse.SC_NOT_FOUND);
                    return;
                    // we do not to continue since there is no root
                    // resource
                }

                if (so.isNullResource()) {
                    String methodsAllowed = DeterminableMethod
                            .determineMethodsAllowed(so);
                    resp.addHeader("Allow", methodsAllowed);
                    resp.sendError(WebdavStatus.SC_METHOD_NOT_ALLOWED);
                    return;
                }

                if (lo != null && lo.isExclusive()) {
                    // Object on specified path is LOCKED
                    errorList = new Hashtable<String, Integer>();
                    errorList.put(path, Integer.valueOf(WebdavStatus.SC_LOCKED));
                    sendReport(req, resp, errorList);
                    return;
                }

                List<String> toset = null;
                List<String> toremove = null;
                List<String> tochange = new Vector<String>();
                // contains all properties from
                // toset and toremove

                path = getCleanPath(getRelativePath(req));

                Node tosetNode = null;
                Node toremoveNode = null;

                if (req.getContentLength() != 0) {
                    DocumentBuilder documentBuilder = getDocumentBuilder();
                    try {
                        Document document = documentBuilder
                                .parse(new InputSource(req.getInputStream()));
                        // Get the root element of the document
                        Element rootElement = document.getDocumentElement();

                        tosetNode = XMLHelper.findSubElement(XMLHelper
                                .findSubElement(rootElement, "set"), "prop");
                        toremoveNode = XMLHelper.findSubElement(XMLHelper
                                .findSubElement(rootElement, "remove"), "prop");
                    } catch (Exception e) {
                        resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                        return;
                    }
                } else {
                    // no content: error
                    resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                    return;
                }

                HashMap<String, String> namespaces = new HashMap<String, String>();
                namespaces.put("DAV:", "D");

                if (tosetNode != null) {
                    toset = XMLHelper.getPropertiesFromXML(tosetNode);
                    tochange.addAll(toset);
                }

                if (toremoveNode != null) {
                    toremove = XMLHelper.getPropertiesFromXML(toremoveNode);
                    tochange.addAll(toremove);
                }

                resp.setStatus(WebdavStatus.SC_MULTI_STATUS);
                resp.setContentType("text/xml; charset=UTF-8");

                // Create multistatus object
                XMLWriter generatedXML = new XMLWriter(resp.getWriter(),
                        namespaces);
                generatedXML.writeXMLHeader();
                generatedXML
                        .writeElement("DAV::multistatus", XMLWriter.OPENING);

                generatedXML.writeElement("DAV::response", XMLWriter.OPENING);
                String status = new String("HTTP/1.1 " + WebdavStatus.SC_OK
                        + " " + WebdavStatus.getStatusText(WebdavStatus.SC_OK));

                // Generating href element
                generatedXML.writeElement("DAV::href", XMLWriter.OPENING);

                String href = req.getContextPath();
                if ((href.endsWith("/")) && (path.startsWith("/")))
                    href += path.substring(1);
                else
                    href += path;
                if ((so.isFolder()) && (!href.endsWith("/")))
                    href += "/";

                generatedXML.writeText(rewriteUrl(href));

                generatedXML.writeElement("DAV::href", XMLWriter.CLOSING);

                for (Iterator<String> iter = tochange.iterator(); iter
                        .hasNext();) {
                    String property = (String) iter.next();

                    generatedXML.writeElement("DAV::propstat",
                            XMLWriter.OPENING);

                    generatedXML.writeElement("DAV::prop", XMLWriter.OPENING);
                    generatedXML.writeElement(property, XMLWriter.NO_CONTENT);
                    generatedXML.writeElement("DAV::prop", XMLWriter.CLOSING);

                    generatedXML.writeElement("DAV::status", XMLWriter.OPENING);
                    generatedXML.writeText(status);
                    generatedXML.writeElement("DAV::status", XMLWriter.CLOSING);

                    generatedXML.writeElement("DAV::propstat",
                            XMLWriter.CLOSING);
                }

                generatedXML.writeElement("DAV::response", XMLWriter.CLOSING);

                generatedXML
                        .writeElement("DAV::multistatus", XMLWriter.CLOSING);

                generatedXML.sendData();
            } catch (AccessDeniedException e) {
                resp.sendError(WebdavStatus.SC_FORBIDDEN);
            } catch (WebdavException e) {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            } catch (ServletException e) {
                e.printStackTrace(); // To change body of catch statement use
                // File | Settings | File Templates.
            } finally {
                _resourceLocks.unlockTemporaryLockedObjects(transaction, path,
                        tempLockOwner);
            }
        } else {
            resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
        }
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoPut.java
================================================
/*
 * Copyright 1999,2004 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ejie.x38.webdav.methods;

import java.io.IOException;
import java.util.Hashtable;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.AccessDeniedException;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.exceptions.WebdavException;
import com.ejie.x38.webdav.locking.IResourceLocks;
import com.ejie.x38.webdav.locking.LockedObject;

public class DoPut extends AbstractMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoPut.class);

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;
    private boolean _readOnly;
    private boolean _lazyFolderCreationOnPut;

    private String _userAgent;

    public DoPut(IWebdavStore store, IResourceLocks resLocks, boolean readOnly,
            boolean lazyFolderCreationOnPut) {
        _store = store;
        _resourceLocks = resLocks;
        _readOnly = readOnly;
        _lazyFolderCreationOnPut = lazyFolderCreationOnPut;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        if (!_readOnly) {
            String path = getRelativePath(req);
            String parentPath = getParentPath(path);

            _userAgent = req.getHeader("User-Agent");

            Hashtable<String, Integer> errorList = new Hashtable<String, Integer>();

            if (!checkLocks(transaction, req, resp, _resourceLocks, parentPath)) {
                errorList.put(parentPath, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return; // parent is locked
            }

            if (!checkLocks(transaction, req, resp, _resourceLocks, path)) {
                errorList.put(path, WebdavStatus.SC_LOCKED);
                sendReport(req, resp, errorList);
                return; // resource is locked
            }

            String tempLockOwner = "doPut" + System.currentTimeMillis()
                    + req.toString();
            if (_resourceLocks.lock(transaction, path, tempLockOwner, false, 0,
                    TEMP_TIMEOUT, TEMPORARY)) {
                StoredObject parentSo, so = null;
                try {
                    parentSo = _store.getStoredObject(transaction, parentPath);
                    if (parentPath != null && parentSo != null
                            && parentSo.isResource()) {
                        resp.sendError(WebdavStatus.SC_FORBIDDEN);
                        return;

                    } else if (parentPath != null && parentSo == null
                            && _lazyFolderCreationOnPut) {
                        _store.createFolder(transaction, parentPath);

                    } else if (parentPath != null && parentSo == null
                            && !_lazyFolderCreationOnPut) {
                        errorList.put(parentPath, WebdavStatus.SC_NOT_FOUND);
                        sendReport(req, resp, errorList);
                        return;
                    }

                    so = _store.getStoredObject(transaction, path);

                    if (so == null) {
                        _store.createResource(transaction, path);
                        // resp.setStatus(WebdavStatus.SC_CREATED);
                    } else {
                        // This has already been created, just update the data
                        if (so.isNullResource()) {

                            LockedObject nullResourceLo = _resourceLocks
                                    .getLockedObjectByPath(transaction, path);
                            if (nullResourceLo == null) {
                                resp
                                        .sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                                return;
                            }
                            String nullResourceLockToken = nullResourceLo
                                    .getID();
                            String[] lockTokens = getLockIdFromIfHeader(req);
                            String lockToken = null;
                            if (lockTokens != null) {
                                lockToken = lockTokens[0];
                            } else {
                                resp.sendError(WebdavStatus.SC_BAD_REQUEST);
                                return;
                            }
                            if (lockToken.equals(nullResourceLockToken)) {
                                so.setNullResource(false);
                                so.setFolder(false);

                                String[] nullResourceLockOwners = nullResourceLo
                                        .getOwner();
                                String owner = null;
                                if (nullResourceLockOwners != null)
                                    owner = nullResourceLockOwners[0];

                                if (!_resourceLocks.unlock(transaction,
                                        lockToken, owner)) {
                                    resp
                                            .sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                                }
                            } else {
                                errorList.put(path, WebdavStatus.SC_LOCKED);
                                sendReport(req, resp, errorList);
                            }
                        }
                    }
                    // User-Agent workarounds
                    doUserAgentWorkaround(resp);

                    // setting resourceContent
                    long resourceLength = _store
                            .setResourceContent(transaction, path, req
                                    .getInputStream(), null, null);

                    so = _store.getStoredObject(transaction, path);
                    if (resourceLength != -1)
                        so.setResourceLength(resourceLength);
                    // Now lets report back what was actually saved

                } catch (AccessDeniedException e) {
                    resp.sendError(WebdavStatus.SC_FORBIDDEN);
                } catch (WebdavException e) {
                    resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
                } finally {
                    _resourceLocks.unlockTemporaryLockedObjects(transaction,
                            path, tempLockOwner);
                }
            } else {
                resp.sendError(WebdavStatus.SC_INTERNAL_SERVER_ERROR);
            }
        } else {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
        }

    }

    /**
     * @param resp
     */
    private void doUserAgentWorkaround(HttpServletResponse resp) {
        if (_userAgent != null && _userAgent.indexOf("WebDAVFS") != -1
                && _userAgent.indexOf("Transmit") == -1) {
            LOG.trace("DoPut.execute() : do workaround for user agent '"
                    + _userAgent + "'");
            resp.setStatus(WebdavStatus.SC_CREATED);
        } else if (_userAgent != null && _userAgent.indexOf("Transmit") != -1) {
            // Transmit also uses WEBDAVFS 1.x.x but crashes
            // with SC_CREATED response
            LOG.trace("DoPut.execute() : do workaround for user agent '"
                    + _userAgent + "'");
            resp.setStatus(WebdavStatus.SC_NO_CONTENT);
        } else {
            resp.setStatus(WebdavStatus.SC_CREATED);
        }
    }
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/methods/DoUnlock.java
================================================
package com.ejie.x38.webdav.methods;

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.ejie.x38.webdav.ITransaction;
import com.ejie.x38.webdav.IWebdavStore;
import com.ejie.x38.webdav.StoredObject;
import com.ejie.x38.webdav.WebdavStatus;
import com.ejie.x38.webdav.exceptions.LockFailedException;
import com.ejie.x38.webdav.locking.IResourceLocks;
import com.ejie.x38.webdav.locking.LockedObject;

public class DoUnlock extends DeterminableMethod {

    private static org.slf4j.Logger LOG = org.slf4j.LoggerFactory
            .getLogger(DoUnlock.class);

    private IWebdavStore _store;
    private IResourceLocks _resourceLocks;
    private boolean _readOnly;

    public DoUnlock(IWebdavStore store, IResourceLocks resourceLocks,
            boolean readOnly) {
        _store = store;
        _resourceLocks = resourceLocks;
        _readOnly = readOnly;
    }

    public void execute(ITransaction transaction, HttpServletRequest req,
            HttpServletResponse resp) throws IOException, LockFailedException {
        LOG.trace("-- " + this.getClass().getName());

        if (_readOnly) {
            resp.sendError(WebdavStatus.SC_FORBIDDEN);
            return;
        } else {

            String path = getRelativePath(req);
            String tempLockOwner = "doUnlock" + System.currentTimeMillis()
                    + req.toString();
            try {
                if (_resourceLocks.lock(transaction, path, tempLockOwner,
                        false, 0, TEMP_TIMEOUT, TEMPORARY)) {

                    String lockId = getLockIdFromLockTokenHeader(req);
                    LockedObject lo;
                    if (lockId != null
                            && ((lo = _resourceLocks.getLockedObjectByID(
                                    transaction, lockId)) != null)) {

                        String[] owners = lo.getOwner();
                        String owner = null;
                        if (lo.isShared()) {
                            // more than one owner is possible
                            if (owners != null) {
                                for (int i = 0; i < owners.length; i++) {
                                    // remove owner from LockedObject
                                    lo.removeLockedObjectOwner(owners[i]);
                                }
                            }
                        } else {
                            // exclusive, only one lock owner
                            if (owners != null)
                                owner = owners[0];
                            else
                                owner = null;
                        }

                        if (_resourceLocks.unlock(transaction, lockId, owner)) {
                            StoredObject so = _store.getStoredObject(
                                    transaction, path);
                            if (so.isNullResource()) {
                                _store.removeObject(transaction, path);
                            }

                            resp.setStatus(WebdavStatus.SC_NO_CONTENT);
                        } else {
                            LOG.trace("DoUnlock failure at " + lo.getPath());
                            resp.sendError(WebdavStatus.SC_METHOD_FAILURE);
                        }

                    } else {
                        resp.sendError(WebdavStatus.SC_BAD_REQUEST);
                    }
                }
            } catch (LockFailedException e) {
                e.printStackTrace();
            } finally {
                _resourceLocks.unlockTemporaryLockedObjects(transaction, path,
                        tempLockOwner);
            }
        }
    }

}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/security/WebDAVHttpServletRequestWrapper.java
================================================
package com.ejie.x38.webdav.security;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;

public class WebDAVHttpServletRequestWrapper extends HttpServletRequestWrapper{

	public List<Cookie> extraCookies;
	
	public WebDAVHttpServletRequestWrapper(
			HttpServletRequest paramHttpServletRequest) {
		super(paramHttpServletRequest);
		extraCookies = new ArrayList<Cookie>();
		Cookie[] cookies = paramHttpServletRequest.getCookies();
		
		if (cookies !=null && cookies.length>0){
			List<Cookie> asList = Arrays.asList();
			extraCookies.addAll(asList);
		}
	}
	
	
	public void addCookie(Cookie cookie){
		extraCookies.add(cookie);
	}


	@Override
	public Cookie[] getCookies() {
		Cookie[] cookieArray = new Cookie[extraCookies.size()];
		return this.extraCookies.toArray(cookieArray);
	}
	
	
}

================================================
File: x38ShLibClasses/x38ShLibClasses-dav/src/main/java/com/ejie/x38/webdav/security/WebDAVXLNetsAuthenticationFilter.java
================================================
package com.ejie.x38.webdav.security;

import java.io.IOException;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.xml.bind.DatatypeConverter;

import org.springframework.web.filter.GenericFilterBean;

/**
 * Servlet Filter implementation class Y31HttpBasicAuthenticationFilter
 */
public class WebDAVXLNetsAuthenticationFilter extends GenericFilterBean {

	public String paramName = "c";
	
	/**
	 * Default constructor.
	 */
	public WebDAVXLNetsAuthenticationFilter() {
	}

	public void setParamName(String paramName){
		this.paramName = paramName;
	}
	
	@Override
	public void doFilter(final ServletRequest request, final ServletResponse response, final FilterChain chain) throws IOException, ServletException {

		HttpServletRequest httpRequest = (HttpServletRequest) request;
		HttpServletResponse httpResponse = (HttpServletResponse) response;

		String webdavXLNetsParam = httpRequest.getParameter(this.paramName);
		
		WebDAVHttpServletRequestWrapper wrapedRequest = new WebDAVHttpServletRequestWrapper(httpRequest);
		
		
		if (webdavXLNetsParam!=null){
			String param = new String(DatatypeConverter.parseBase64Binary(webdavXLNetsParam));
			
			String[] arrParam = param.split("&");

			for (String s : arrParam) {
				String[] paramKeyValue = s.split("=");
				final Cookie cookie = new Cookie(paramKeyValue[0], paramKeyValue[1]);
				cookie.setSecure(true);
				wrapedRequest.addCookie(cookie);

			}
		}
		
		chain.doFilter(wrapedRequest, httpResponse);
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.settings/org.eclipse.core.resources.prefs
================================================
eclipse.preferences.version=1
encoding//src/main/java=UTF-8
encoding//src/main/resources=UTF-8
encoding//src/test/java=UTF-8
encoding//src/test/resources=UTF-8
encoding/<project>=UTF-8
encoding/src=UTF-8


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.settings/org.eclipse.jdt.core.prefs
================================================
eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
org.eclipse.jdt.core.compiler.codegen.targetPlatform=11
org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
org.eclipse.jdt.core.compiler.compliance=11
org.eclipse.jdt.core.compiler.debug.lineNumber=generate
org.eclipse.jdt.core.compiler.debug.localVariable=generate
org.eclipse.jdt.core.compiler.debug.sourceFile=generate
org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
org.eclipse.jdt.core.compiler.release=disabled
org.eclipse.jdt.core.compiler.source=11


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.settings/org.eclipse.m2e.core.prefs
================================================
activeProfiles=
eclipse.preferences.version=1
resolveWorkspaceProjects=true
version=1


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.settings/org.eclipse.wst.common.component
================================================
<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
                    
    
    
    
    <wb-module deploy-name="x38ShLibClasses-dav">
                                
        
        
        <wb-resource deploy-path="/" source-path="/test-integration"/>
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/java"/>
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/resources"/>
                                    
    
    
    
    </wb-module>
                



</project-modules>


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.settings/org.eclipse.wst.common.project.facet.core.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <runtime name="Oracle WebLogic Server 14.1.1.0"/>
  <installed facet="jst.utility" version="1.0"/>
  <installed facet="java" version="11"/>
</faceted-project>


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.settings/org.eclipse.wst.validation.prefs
================================================
disabled=06target
eclipse.preferences.version=1


================================================
File: x38ShLibClasses/x38ShLibClasses-dav/.settings/org.hibernate.eclipse.console.prefs
================================================
default.configuration=x38ShLibClasses-dav
eclipse.preferences.version=1
hibernate3.enabled=true


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/LICENSE.txt
================================================
                    Licencia Pública de la Unión Europea
                                 Versión 1.1
                        EUPL © Comunidad Europea 2007
                     http://ec.europa.eu/idabc/eupl.html


   La presente Licencia Pública de la Unión Europea («EUPL»), se aplica a la 
   obra o al programa de ordenador (definidos a continuación) suministrados en
   las condiciones fijadas en la presente licencia. Queda prohibido cualquier
   uso de la obra distinto del autorizado por la presente licencia (en la 
   medida en que tal uso esté protegido por un derecho del titular de los 
   derechos de autor de la obra). 
   
   La obra original se suministrará en las condiciones fijadas en la presente 
   licencia cuando el licenciante (definido a continuación) haya colocado la 
   siguiente advertencia inmediatamente después de la mención a los derechos 
   de autor de la obra original: 
   
   			Licencia cedida con arreglo a la EUPL V.1.1 
   
   o haya expresado por otro procedimiento su voluntad de conceder una 
   licencia con arreglo a la EUPL. 
   
   
   1. Definiciones 
      En la presente licencia, se entenderá por: 
      – licencia: la presente licencia. 
      – obra original o programa de ordenador: el programa de ordenador 
        distribuido o comunicado por el licenciante con arreglo a la presente 
        licencia en forma de código fuente o, en su caso, de código ejecutable;
      – obras derivadas: las obras o el programa de ordenador que pudiera crear
        el licenciatario sobre la base de la obra original o de alguna de las 
        modificaciones de ésta. La presente licencia no define el grado de 
        modificación o dependencia de la obra original necesario para 
        clasificar una obra como derivada; dicho grado se determinará de 
        acuerdo con la legislación sobre derechos de autor aplicable en el país
        contemplado en el artículo 15;
      – obra: la obra original o sus obras derivadas; 
      – código fuente: la forma de la obra legible por seres humanos que pueda 
        ser estudiada y modificada más fácilmente; 
      – código ejecutable: cualquier código, en general compilado, destinado a 
        ser ejecutado como programa por un ordenador; 
      – licenciante: la persona física o jurídica que distribuye o comunica la 
        obra con arreglo a la licencia; 
      – colaborador: la persona física o jurídica que modifica la obra con 
        arreglo a la licencia o contribuye de cualquier otra manera a crear una
        obra derivada; 
      – licenciatario: la persona física o jurídica que hace un uso cualquiera 
        del programa de ordenador en las condiciones fijadas en la licencia; 
      – distribución o comunicación: cualquier acto de venta, donación,
        préstamo, alquiler, distribución, comunicación, transmisión o cualquier
        otro acto de puesta a disposición, en línea o fuera de línea, de copias
        de la obra o de acceso a sus funcionalidades esenciales a otra persona 
        física o jurídica.
   
   2. Ámbito de los derechos otorgados por la Licencia 
      El licenciante concede al licenciatario una licencia de ámbito mundial, a
      título gratuito, no exclusiva y que el licenciatario puede subcontratar 
      mientras sigan vigentes los derechos de autor sobre la obra original, y 
      lo autoriza a: 
      
      – utilizar la obra en cualquier circunstancia y para cualquier uso; 
      – reproducir la obra; 
      – modificar la obra original y realizar obras derivadas de la misma; 
      – comunicar al público la obra o copias de la misma, poner a su 
        disposición o exhibir la obra o las copias y, en su caso, ejecutar 
        públicamente la Obra; 
      – distribuir la obra o copias de la misma; 
      – prestar y alquilar la obra o copias de la misma; 
      – subcontratar los derechos relativos a la obra o a las copias de la
        misma. 
      
      Dichos derechos se podrán ejercer a través de cualquier medio, soporte y 
      formato, conocido en el presente o que pueda inventarse en el futuro, en 
      la medida en que así lo permita la legislación aplicable. 
      
      En los países cuyo ordenamiento contemple los derechos morales, el 
      Licenciante renunciará al ejercicio de los mismos en la medida en que lo 
      permita la legislación, a fin de hacer efectiva la licencia de los 
      derechos patrimoniales anteriormente enumerados. 
      
      El licenciante cede al licenciatario, libre de cánones, los derechos de 
      uso no exclusivos sobre cualquier patente de que sea titular, en la 
      medida necesaria para que el licenciatario haga uso de los derechos sobre
      la obra otorgados por la presente licencia. 
   
   3. Comunicación del Código Fuente 
      El licenciante podrá suministrar la obra en forma de código fuente o 
      código ejecutable. Si la suministrara en forma de código ejecutable, 
      deberá facilitar además una copia legible automáticamente del código 
      fuente de la obra junto con cada copia de la obra que distribuya, o bien 
      indicar, en una advertencia inserta a continuación de la mención a los 
      derechos de autor adjunta a la obra, un repositorio en el que se pueda 
      acceder al código fuente fácilmente y de manera gratuita durante el 
      período en que el licenciante siga distribuyendo o comunicando la obra. 
   
   4. Limitaciones a los derechos de autor 
      En ningún caso podrá interpretarse la presente licencia de modo que prive
      al licenciatario de los beneficios de los que pudiera disfrutar como 
      consecuencia de las excepciones o limitaciones a los derechos exclusivos 
      de los titulares de los derechos de la obra original o del programa de 
      ordenador, de la extinción de dichos derechos o de cualquier otra 
      limitación aplicable. 
   
   5. Obligaciones del licenciatario 
      La cesión de los derechos en virtud de la presente licencia queda 
      supeditada a ciertas restricciones u obligaciones que habrá de respetar 
      el licenciatario. Dichas obligaciones son: 
      
      Derecho de atribución: El licenciatario deberá mantener íntegramente 
      todas las advertencias y menciones a los derechos de autor, patentes o 
      marcas registradas, así como las que se refieran a la licencia y a la 
      exención de responsabilidad. El licenciatario deberá adjuntar copias de 
      dichas advertencias y menciones y de la Licencia con cada copia de la 
      obra que distribuya o comunique. El licenciatario se responsabilizará de 
      que sus modificaciones u obras derivadas incluyan una advertencia bien 
      destacada declarando que ha modificado la obra, y la fecha de 
      modificación.
      
      Cláusula de «izquierdo de copia» (copyleft): Si el licenciatario 
      distribuyera o comunicara copias de la obra original o de obras derivadas
      basadas en la obra original, dicha distribución o comunicación deberá 
      hacerse en las condiciones fijadas en la presente licencia o de una 
      versión posterior de la presente licencia, salvo si la obra original se 
      distribuye expresamente solo en la presente versión de la licencia. El 
      licenciatario (ahora en su calidad de licenciante) no podrá ofrecer ni 
      imponer condiciones adicionales sobre la obra o las obras derivadas que 
      modifiquen o limiten las condiciones de la licencia. 
      
      Cláusula de compatibilidad: Si el licenciatario distribuyera o comunicara
      obras derivadas o copias de estas últimas basadas a su vez en la obra 
      original y en otra obra licenciada bajo una licencia compatible, la 
      distribución o comunicación podrán efectuarse con arreglo a las 
      condiciones de dicha licencia compatible. A efectos de la presente 
      cláusula, se entenderá por «licencia compatible» cualquiera de las 
      licencias enumeradas en el apéndice adjunto a la presente licencia. En 
      caso de que las obligaciones del licenciatario con arreglo a la licencia 
      compatible estén en colisión con las derivadas de la presente licencia, 
      prevalecerán las obligaciones de la licencia compatible. 
      
      Suministro del código fuente: Cuando distribuya o comunique copias de la 
      obra, el licenciatario deberá facilitar una copia del código fuente 
      legible automáticamente o indicar un repositorio en que se pueda acceder 
      al código fuente fácilmente y de manera gratuita durante el período en 
      que siga distribuyendo o comunicando la obra. 
      
      Salvaguardia de otros derechos: La presente licencia no faculta para 
      utilizar los nombres comerciales, marcas de producto o de servicio o 
      nombres del licenciante, excepto cuando ello, realizado en la medida de 
      lo razonable y conforme a los usos habituales, sea necesario para indicar
      el origen de la obra y reproducir el contenido de la mención a los 
      derechos de autor. 
   
   6. Secuencia de autoría 
      El licenciante original garantiza ser titular originario de los derechos 
      de autor sobre la obra original objeto de la presente licencia o haberlos
      adquirido mediante la licencia correspondiente y estar facultado para 
      otorgar licencias sobre tales derechos.
      
      Cada colaborador garantiza ser titular de los derechos de autor sobre las
      modificaciones que aporta a la obra o haberlos adquirido mediante la 
      correspondiente licencia y estar facultado para otorgar licencias sobre 
      tales derechos.
      
      Cada vez que el licenciatario acepta la licencia, el licenciante original
      y los colaboradores posteriores le otorgan una licencia sobre sus propias
      contribuciones a la obra en las condiciones fijadas en la presente
      licencia.
   
   7. Exclusión de garantía 
      La obra se encuentra en proceso de elaboración, siendo objeto de 
      continuas mejoras por parte de numerosos colaboradores. No es una obra 
      acabada y por tanto puede contener defectos o fallos inherentes al 
      desarrollo de este tipo de programas. 
      
      Por este motivo, la obra, en virtud de la licencia, se suministra «tal 
      cual», sin garantías de ningún tipo, en particular, en una enumeración no
      exhaustiva, en cuanto a su comercialización, adecuación a un propósito 
      determinado, ausencia de defectos 
      
      o errores, exactitud y ausencia de infracción de los derechos de 
      propiedad intelectual distintos de los derechos de autor según se afirma
      en el artículo 6 de la presente licencia. 
      Esta exclusión de garantía forma parte esencial de la licencia y es 
      condición para la cesión de cualquier derecho con respecto a la obra. 
   
   8. Exclusión de responsabilidad 
      Excepto en casos de dolo o de daños ocasionados directamente a personas 
      físicas, el licenciante no será responsable de los daños y perjuicios de 
      cualquier clase, directos o indirectos, materiales o morales, que 
      pudieran derivarse de la licencia o del uso de la obra, en particular, en
      una enumeración no exhaustiva, de los daños y perjuicios por pérdida de 
      buena reputación, paro técnico, avería o mal funcionamiento de equipos 
      informáticos, pérdida de datos o cualquier perjuicio comercial, incluso 
      si el licenciante conocía la posibilidad de dichos daños. No obstante, el
      licenciante será responsable, de acuerdo con las normas legales que 
      regulen la responsabilidad por los daños causados por productos, en la 
      medida en que dichas normas sean aplicables a la obra. 
   
   9. Acuerdos adicionales 
      Al distribuir la obra original o las obras derivadas, el licenciatario 
      podrá suscribir un acuerdo adicional, y cobrar una remuneración para 
      ofrecer asistencia y proporcionar garantías o asumir indemnizaciones u 
      otras obligaciones en materia de responsabilidad o proporcionar servicios
      compatibles con la presente licencia. No obstante, al aceptar tales 
      obligaciones, el licenciatario actuará únicamente en nombre propio y bajo
      su exclusiva responsabilidad, y nunca en nombre del licenciante original
      ni de ningún otro colaborador, y ello a condición de que acceda a 
      indemnizar, defender y amparar a todo colaborador frente a cualquier 
      responsabilidad en que éste pudiera incurrir y frente a las reclamaciones
      que pudieran presentarse contra él por haber aceptado el licenciatario la
      mencionada garantía o responsabilidad adicional.
   
   10. Aceptación de la licencia 
      Lo dispuesto en la presente licencia puede aceptarse haciendo clic en el 
      icono «Aceptar» situado en la parte inferior de la ventana en que aparece
      el texto de la presente licencia o manifestando el consentimiento de 
      cualquier otra forma similar, de conformidad con lo previsto en la 
      legislación aplicable. Haciendo clic en dicho icono, se expresa la 
      aceptación inequívoca e irrevocable de la presente licencia y de todo su 
      contenido. 
      
      Asimismo, el licenciatario acepta irrevocablemente la presente licencia y
      todas sus condiciones por el mero hecho de ejercer cualquiera de los 
      derechos que le otorga el artículo 2 de la presente licencia, tales como
      el uso de la obra, la creación de una obra derivada o la distribución o 
      comunicación de la obra o de copias de la misma. 
   
   11. Información al público 
      En caso de que el licenciatario proceda a la distribución o comunicación
      de la obra por medios electrónicos (por ejemplo, ofreciendo la descarga 
      de la obra a distancia), el canal o medio de distribución (por ejemplo, 
      un sitio web) deberá facilitar al público, como mínimo, la información 
      exigida por la legislación aplicable acerca del licenciante, la licencia 
      y la manera en que el licenciatario puede acceder a dichos datos, 
      aceptarlos, conservarlos y reproducirlos. 
   
   12. Extinción de la licencia 
      La licencia y los derechos otorgados a su amparo se extinguirán 
      automáticamente si el licenciatario incumple alguna de las condiciones de
      la licencia.
      
      Tal extinción no supondrá, sin embargo, la de las licencias de que 
      disfruten las personas que hayan recibido la obra del licenciatario en
      virtud de la licencia, siempre que dichas personas sigan cumpliendo 
      plenamente las condiciones de la licencia. 
   
   13. Varios 
      No obstante lo dispuesto en el artículo 9, la licencia representará la 
      totalidad del acuerdo entre las partes en cuanto a la obra objeto de la 
      misma. 
      
      La eventual invalidez o ineficacia de alguna disposición de la presente 
      licencia con arreglo a la legislación vigente no afectará a la validez o 
      eficacia general de la licencia. En tales casos, la disposición se 
      interpretará o reformulará según proceda para hacerla válida y eficaz. 
      
      La Comisión Europea podrá publicar otras versiones lingüísticas o nuevas 
      versiones de la presente licencia en la medida en que resulte necesario y
      razonable y sin reducir el ámbito de los derechos concedidos por la 
      licencia. Las nuevas versiones de la licencia se publicarán con un número
      de versión único. 
      
      Todas las versiones lingüísticas de la presente licencia aprobadas por la
      Comisión European tienen idéntico valor. Las partes pueden utilizar la
      versión lingüística de su preferencia. 
   
   14. Tribunales competentes 
      Los litigios relativos a la interpretación de la presente licencia que se
      planteen entre la Comisión Europea, en calidad de licenciante, y un 
      licenciatario, se someterán a la jurisdicción del Tribunal de Justicia de
      las Comunidades Europeas, con arreglo al artículo 238 del Tratado
      constitutivo de la Comunidad Europea. 
      
      Los litigios relativos la interpretación de la presente licencia que se
      planteen entre partes distintas de la Comisión Europea, se someterán a la
      jurisdicción exclusiva del tribunal que sea competente en el lugar en que
      resida o ejerza su actividad principal el licenciante. 
   
   15. Legislación aplicable 
      La presente Licencia se regirá por la legislación del país de la Unión 
      Europea en el que resida o tenga su domicilio social el licenciante. 
      
      La presente licencia se regirá por la legislación belga si: 
      
      – se planteara un litigio entre la Comisión Europea, en calidad de 
        licenciante, y un licenciatario; 
      – el licenciante, distinto de la Comisión Europea, no residiera o no 
        tuviera su domicilio social en un Estado miembro de la Unión Europea. 
   
   Apéndice 
   
   Son «licencias compatibles» con la EUPL con arreglo al artículo 5: 
   
   – GNU General Public License (GNU GPL) v. 2 
   – Open Software License (OSL) v. 2.1, v. 3.0 
   – Common Public License v. 1.0 
   – Eclipse Public License v. 1.0 
   – Cecill v. 2.0 
   


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/NOTICE.txt
================================================
NOTICE.txt - UDA copyright notices

UDA is Copyright 2011 by E.J.I.E., S.A.
	
	* The plug-in and RUP components are licensed under the EUPL, Version 1.1 only 
	(the "Licence");
	* Documentation is licensed under the Creative Commons Attribution-NonCommercial-
	ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) 
	
THIRD PARTY COMPONENTS

	The UDA plug-in includes software developed by:
	
		* Enterprise JavaBeans 3.0
			http://www.oracle.com/technetwork/java/javaee/ejb/index.html
			Sun Microsystems, Inc.
			License: COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0

		* Oracle JDBC Drivers 
			http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html
			Oracle Corporation
			License: OTN (http://www.oracle.com/technetwork/licenses/standard-license-152015.html)

		* The JBoss Community
			Hibernate Tools (http://www.hibernate.org/subprojects/tools.html)
			Copyright (c) 2010 JBoss by Red Hat and others.
			License: FSF Lesser Gnu Public License (LGPL v2.1) (http://www.hibernate.org/license)

		* Eclipse
			Eclipse Platform (http://www.eclipse.org/platform)
			Copyright (c) Eclipse contributors and others 2000, 2011.  All rights reserved.
			License: Eclipse Foundation Software User Agreement
						
		* Oracle Enterprise Pack for Eclipse (OEPE)
			http://www.oracle.com/technetwork/developer-tools/eclipse/overview/index.html
			Copyright © 2008, 2011, Oracle and/or its affiliates. All rights reserved.
			License: ORACLE ENTERPRISE PACK FOR ECLIPSE LICENSE AGREEMENT
						
		* PMD (http://pmd.sourceforge.net)
			PMD plugin For Eclipse
			Copyright (c) 1997-2009, PMD for Eclipse Development Team
			License: "BSD-style" license (http://pmd.sourceforge.net/license.html)									

		* Eclipse Checkstyle Plugin (http://eclipse-cs.sf.net/)
			Checkstyle integration plugin for Eclipse
			(c) Copyright David Schneider, Lars Koedderitzsch and others, 2002-2010
			License: GNU Lesser General Public License Version 2.1 
						
		* FindBugs (http://findbugs.sourceforge.net)
			FindBugs plugin for Eclipse
			(c) Trademark and Copyright 2003-2008 by the University of Maryland.
			License: GNU Lesser General Public License (LGPL) (http://findbugs.sourceforge.net/manual/license.html)
			
		* Eclipse Subversive - SVN Team Provider Project
			The Eclipse Team Provider for the Subversion version control system.
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement 
			
		* Polarion Subversive SVN Connectors (http://www.polarion.org and http://www.polarion.com)
			Set of the SVN connectors for the Eclipse Subversive - SVN Team Provider. 
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement
			
		* Resource Bundle Editor (http://sourceforge.net/projects/eclipse-rbe/)
			Essiembre ResourceBundle Editor
			Copyright (C) 2003, 2004  Pascal Essiembre, Essiembre Consultant Inc.
			License: GNU Lesser General Public License Version 2.1

		* FreeMarker IDE (http://www.jboss.org/tools)
			FreeMarkerIDE provides editor for FreeMarker templates
			Copyright (c) 2008-2011 Red Hat, Inc. and others.
			License: Eclipse Public License - v 1.0 (http://www.eclipse.org/legal/epl-v10.html)


			
	The RUP (Rich UDA Patterns) components includes software developed by:

		* The jQuery Project
			jQuery core (http://jquery.com/)
			Copyright 2011, John Resig
			License: Gnu Public License v2 (GPLv2), MIT license
			
		* The jQueryUI Team
			jQueryUI (http://jqueryui.com/)
			Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
			License: Gnu Public License v2 (GPLv2), MIT license

		* The jQuery Grid Plugin
			jQuery Grid Plugin (http://www.trirand.com/blog/)
			Copyright (c) 2007-2011 jQuery Grid Plugin 
			License: Gnu Public License v2 (GPLv2), MIT license

		* ajaxBlender.com
			xBreadcrumbs (Extended Breadcrums) jQuery Plugin (http://www.ajaxblender.com/xbreadcrumbs.html)
			Copyright 2009 ajaxBlender.com 
			
		* form2object			
			form2object (https://github.com/maxatwork/form2js)
			Copyright (c) 2010 Maxim Vasiliev
			License: (https://github.com/maxatwork/form2js/blob/master/license.txt)
			
			

================================================
File: x38ShLibClasses/x38ShLibClasses-pif/pom.xml
================================================
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<parent>
		<groupId>com.ejie.x38</groupId>
		<artifactId>x38</artifactId>
		<version>6.1.0-RELEASE</version>
	</parent>
	<modelVersion>4.0.0</modelVersion>
	<artifactId>x38ShLibClasses-pif</artifactId>
	<packaging>jar</packaging>
	<name>x38ShLibClasses-pif</name>
	<url>http://www.ejie.eus</url>
	<dependencies>
		<dependency>
			<groupId>com.ejie.x38</groupId>
			<artifactId>x38ShLibClasses</artifactId>
			<version>6.1.0-RELEASE</version>
		</dependency>
		<dependency>
			<groupId>ejie.xlnets</groupId>
			<artifactId>n38</artifactId>
			<version>1.0</version>
			<scope>provided</scope>
		</dependency>
	</dependencies>
</project>


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.classpath
================================================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" output="target/classes" path="src/main/java">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="org.eclipse.jst.component.nondependency" value=""/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-11">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="output" path="target/classes"/>
</classpath>


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.gitignore
================================================
/target/


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.project
================================================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>x38ShLibClasses-pif_v6</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.wst.common.project.facet.core.builder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.hibernate.eclipse.console.hibernateBuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.wst.validation.validationbuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.m2e.core.maven2Builder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jem.workbench.JavaEMFNature</nature>
		<nature>org.eclipse.wst.common.modulecore.ModuleCoreNature</nature>
		<nature>org.eclipse.jdt.core.javanature</nature>
		<nature>org.eclipse.m2e.core.maven2Nature</nature>
		<nature>org.hibernate.eclipse.console.hibernateNature</nature>
		<nature>org.eclipse.wst.common.project.facet.core.nature</nature>
	</natures>
</projectDescription>


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/bin/.gitignore
================================================
/bin/
/target/


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/src/main/java/META-INF/MANIFEST.MF
================================================
Manifest-Version: 1.0
Class-Path: 



================================================
File: x38ShLibClasses/x38ShLibClasses-pif/src/main/java/com/ejie/x38/pif/PifServletHelper.java
================================================
package com.ejie.x38.pif;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collection;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import n38a.exe.N38APISesion;
import n38c.exe.N38API;

import org.apache.commons.fileupload.FileItemIterator;
import org.apache.commons.fileupload.FileItemStream;
import org.apache.commons.fileupload.FileUploadException;
import org.apache.commons.fileupload.servlet.ServletFileUpload;
import org.apache.commons.fileupload.util.Streams;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.FileCopyUtils;
import org.w3c.dom.Document;

import com.ejie.x38.json.JSONArray;
import com.ejie.x38.json.JSONObject;
import com.ejie.x38.security.XlnetCore;
import com.ejie.y31.exception.Y31JanoServiceAccesDeniedException;
import com.ejie.y31.exception.Y31JanoServiceEventJmsException;
import com.ejie.y31.exception.Y31JanoServiceFileNameFormatException;
import com.ejie.y31.exception.Y31JanoServiceFileNotFoundException;
import com.ejie.y31.exception.Y31JanoServiceGenericException;
import com.ejie.y31.exception.Y31JanoServiceMongoDbGenericException;
import com.ejie.y31.exception.Y31JanoServiceOracleGenericException;
import com.ejie.y31.factory.Y31JanoServiceAbstractFactory;
import com.ejie.y31.service.Y31JanoService;
import com.ejie.y31.vo.Y31AttachmentBean;

import eu.medsea.mimeutil.MimeType;
import eu.medsea.mimeutil.MimeUtil;
import eu.medsea.mimeutil.detector.ExtensionMimeDetector;

public class PifServletHelper {

	private static final Logger logger = LoggerFactory.getLogger(PifServletHelper.class);
	
	private static final String HTTP_BASE_URL_PARAM_NAME = "base_url";
	private static final String HTTP_SECURITY_TOKEN_PARAM_NAME = "securityToken";
	
	private static final String SECURITY_TOKEN_APP = "APP";
	
	
	public void processRequest(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException{
		try{
			String method = httpRequest.getMethod();
			
			if ("POST".equals(method)){
				this.doPost(httpRequest, httpResponse);
			}else if ("GET".equals(method)){
				this.doGet(httpRequest, httpResponse);
			}else if ("DELETE".equals(method)){
				this.doDelete(httpRequest, httpResponse);
			}
		
		} catch (Y31JanoServiceGenericException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceGenericException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		} catch (Y31JanoServiceFileNameFormatException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceFileNameFormatException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		} catch (Y31JanoServiceFileNotFoundException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceFileNotFoundException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		} catch (Y31JanoServiceMongoDbGenericException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceMongoDbGenericException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		} catch (Y31JanoServiceOracleGenericException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceOracleGenericException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		} catch (Y31JanoServiceAccesDeniedException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceAccesDeniedException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		}  catch (IOException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceGenericException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		} catch (Y31JanoServiceEventJmsException e) {
			this.translateY31JanoErrorCode(httpResponse, e, Y31JanoServiceEventJmsException.HTTP_ERROR_CODE_TRANSLATE_BASE);
		}
		finally
		{
			httpResponse.getWriter().flush();
			httpResponse.getWriter().close();
		}
	}
	
	private void doPost(HttpServletRequest request, HttpServletResponse response) throws Y31JanoServiceGenericException, Y31JanoServiceFileNameFormatException, Y31JanoServiceMongoDbGenericException, Y31JanoServiceEventJmsException, Y31JanoServiceAccesDeniedException{
		try {
			ServletFileUpload upload = new ServletFileUpload();
			FileItemIterator iter;
			iter = upload.getItemIterator(request);
			
			String baseUrl = "";
			String folder = "";
			Long fileTtl = null;
			Boolean preserveName = Boolean.FALSE;
			Y31AttachmentBean result;
			Boolean appSecurityToken = Boolean.TRUE;
			Boolean isIEEmulate = request.getParameter("_emulate_iframe_http_status") != null? Boolean.TRUE:Boolean.FALSE;

			while (iter.hasNext()) {
				FileItemStream item = iter.next();
				String name = item.getFieldName();
				InputStream stream = item.openStream();
				if (item.isFormField()) {
					if (PifServletHelper.HTTP_BASE_URL_PARAM_NAME.equals(name)){
						baseUrl = Streams.asString(stream);
					}else if (Y31JanoService.HTTP_FOLDER_PATH_PARAM_NAME.equals(name)){
						folder = Streams.asString(stream);
					}else if (Y31JanoService.HTTP_PRESERVE_NAME_PARAM_NAME.equals(name)){
						preserveName = Boolean.TRUE.toString().toUpperCase().equals(Streams.asString(stream).toUpperCase())?Boolean.TRUE:Boolean.FALSE;
					}else if (Y31JanoService.Y31_TTL_NAME_PARM.equals(name)){
						fileTtl = Long.valueOf(Streams.asString(stream));
					}else if (PifServletHelper.HTTP_SECURITY_TOKEN_PARAM_NAME.equals(name)){
						appSecurityToken = SECURITY_TOKEN_APP.equals(Streams.asString(stream).toUpperCase())?Boolean.TRUE:Boolean.FALSE;
					}
					
				} else {
					
					Y31JanoService service = null;
					try {
						
						String fileName;
						if (isIEEmulate){
							fileName = item.getName();
							int indexOf = fileName.lastIndexOf("\\");
							if (indexOf != -1){
								fileName = fileName.substring(indexOf+1);
							}
						}else{
							fileName = item.getName();
						}
								
						service = Y31JanoServiceAbstractFactory.getInstance();
						StringBuilder rutaFichTmp = new StringBuilder(folder).append("/").append(fileName);
				
						Document xmlSession = null;
						
						xmlSession = this.getXLNetsDocument(request, appSecurityToken);
						
						result = service.put(xmlSession, stream, rutaFichTmp.toString(),
								preserveName, fileTtl);
					} finally {
						if (stream != null) {
							try {
								stream.close();
							} catch (IOException ioe) {
								logger.warn("Se ha producido un error al cerrar el stream de lectura: "+ ioe.getMessage());
							}
						}
					}
					
					
					if (!isIEEmulate){
						response.setContentType("application/json");
					}
					response.getWriter().write(this.getJsonResponsePut(baseUrl, result));
				}
				
			}
		} catch (FileUploadException fue) {
			logger.error("Se ha producido un error la realizar la subida del fichero: ", fue);
			throw new Y31JanoServiceGenericException(fue); 
		} catch (IOException ioe) {
			logger.error("Se ha producido un error la realizar la subida del fichero: ", ioe);
			throw new Y31JanoServiceGenericException(ioe); 
		}
	}
	
	private void doGet(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws Y31JanoServiceGenericException, Y31JanoServiceFileNameFormatException, Y31JanoServiceMongoDbGenericException, Y31JanoServiceAccesDeniedException, Y31JanoServiceFileNotFoundException, Y31JanoServiceOracleGenericException, IOException{
			
			String path = httpRequest.getParameter(Y31JanoService.HTTP_PATH_PARAM_NAME);
			
			Document xlnetsToken = this.getXLNetsDocument(httpRequest, Boolean.TRUE);
			
			OutputStream out = null;
			
			// info
			Y31AttachmentBean file = Y31JanoServiceAbstractFactory.getInstance().info(xlnetsToken, path);
			
			if (file != null){
				
				try {
					httpResponse.setContentType(getMimeTypeFromCompletePath(path));
					out = httpResponse.getOutputStream();
				} catch (IOException ioe) {
					logger.error("Se ha producido un error la realizar la subida del fichero: ", ioe);
					httpResponse.setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
				}
				
				httpResponse.setHeader("Content-disposition", "attachment; filename=" + file.getFileName());
				httpResponse.setContentLength(file.getSize().intValue());
				
				InputStream is = Y31JanoServiceAbstractFactory.getInstance().get(xlnetsToken, path);
				FileCopyUtils.copy(is, out);
				is.close();
				out.flush();
				out.close();
				httpResponse.setStatus(HttpServletResponse.SC_OK);	
			}else{
				throw new Y31JanoServiceFileNotFoundException("El path " + path + " no existe en remoto");
			}
			
	}
	
	private void doDelete(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws Y31JanoServiceFileNameFormatException, Y31JanoServiceGenericException, Y31JanoServiceAccesDeniedException, Y31JanoServiceFileNotFoundException{
		
				
		// Preparando los parámetros
		Document sesion = this.getXLNetsDocument(httpRequest, Boolean.TRUE);
				
		String path = httpRequest.getParameter(Y31JanoService.HTTP_PATH_PARAM_NAME);
		
		// invocando el metodo
		Y31JanoServiceAbstractFactory.getInstance().delete(sesion, path);
		
	}
	
	
	private Document getXLNetsDocument(HttpServletRequest httpRequest, Boolean appToken){
		
		if (Boolean.TRUE.equals(appToken)){
			return this.getTokenAppDocument(httpRequest);
		}else{
			
			N38API n38api = XlnetCore.getN38API(httpRequest);
			return XlnetCore.getN38ItemSesion(n38api);
		}
		
	}
	
	private Document getTokenAppDocument(HttpServletRequest httpRequest) {
		final String webAppName = httpRequest.getSession().getServletContext().getInitParameter("webAppName");
		
		final N38APISesion miAPISesion = new N38APISesion();
		final Document docAPISesionApp = miAPISesion.n38APISesionCrearApp(webAppName);
		
		PifServletHelper.logger.trace("INI - getTokenAppDocument");
		Document doc = null;
			
		PifServletHelper.logger.info(" logueandose en XLNets ...");

		N38API n38api = new N38API(docAPISesionApp);
		PifServletHelper.logger.info(webAppName + " logueada en XLNets.");
		
		doc = n38api.n38ItemSesion();

		PifServletHelper.logger.trace("FIN - getTokenAppDocument");
		return doc;
	}

	private static String getMimeTypeFromCompletePath(String path) throws Y31JanoServiceFileNameFormatException {
		/*
		 * File f = new File(path); String m = new
		 * MimetypesFileTypeMap().getContentType(f);
		 */
		try {
			ExtensionMimeDetector emd = new ExtensionMimeDetector();
			@SuppressWarnings("unchecked")
			Collection<MimeType> mimeTypes = emd.getMimeTypesFileName(path);
			MimeType mimeType = MimeUtil.getMostSpecificMimeType(mimeTypes);
			return mimeType.toString();
		} catch (Exception e) {
			return "application/octet-stream";
		}
	}
	
	private void translateY31JanoErrorCode(HttpServletResponse httpResponse, Exception e, int errorCode) throws IOException {
		e.printStackTrace();
		httpResponse.setStatus(errorCode);
		String s = "{\"success\": false, \"statusCode\":"+errorCode+", \"message\":\""+e.getMessage()+"\" }";
		httpResponse.getWriter().print(s);
		httpResponse.addHeader("HTTP_ERROR_CODE_TRANSLATE",s);
		httpResponse.addHeader("HTTP_ERROR_CODE_TRANSLATE_CODE","Y31-"+errorCode);
		httpResponse.addHeader("HTTP_ERROR_CODE_TRANSLATE_MESSAGE",e.getMessage());
	}
	
	
	private String getJsonResponsePut(String baseUrl, Y31AttachmentBean y31AttachmentBean) {

		JSONArray files = new JSONArray();
		JSONObject file;
		file = new JSONObject();
		file.put(
				"url",
				baseUrl+"?hadoop_file_path="
						+ y31AttachmentBean.getFilePath());
		file.put("name", y31AttachmentBean.getFileName());
		file.put("type", y31AttachmentBean.getContentType());
		file.put("size", y31AttachmentBean.getSize());
		file.put("delete_url", baseUrl+"?hadoop_file_path="
				+ y31AttachmentBean.getFilePath());
		file.put("delete_type", "DELETE");
		files.put(file);

		return files.toString();

	}
	
}


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/src/main/java/com/ejie/x38/pif/PifSpringServlet.java
================================================
package com.ejie.x38.pif;

import java.io.IOException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.HttpRequestHandler;


public class PifSpringServlet implements HttpRequestHandler  {

	private static final Logger logger = LoggerFactory.getLogger(PifSpringServlet.class);
	
	@Override
	public void handleRequest(HttpServletRequest httpRequest, HttpServletResponse httpResponse)
			throws ServletException, IOException {
		logger.debug("PifSpringServlet - Inicio");
		
		PifServletHelper pifServletHelper = new PifServletHelper();
		pifServletHelper.processRequest(httpRequest, httpResponse);
		
		logger.debug("PifSpringServlet - Fin");
	}
}


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.settings/org.eclipse.core.resources.prefs
================================================
eclipse.preferences.version=1
encoding//src/main/java=UTF-8
encoding//src/main/resources=UTF-8
encoding//src/test/java=UTF-8
encoding//src/test/resources=UTF-8
encoding/<project>=UTF-8
encoding/src=UTF-8


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.settings/org.eclipse.jdt.core.prefs
================================================
eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
org.eclipse.jdt.core.compiler.codegen.targetPlatform=11
org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
org.eclipse.jdt.core.compiler.compliance=11
org.eclipse.jdt.core.compiler.debug.lineNumber=generate
org.eclipse.jdt.core.compiler.debug.localVariable=generate
org.eclipse.jdt.core.compiler.debug.sourceFile=generate
org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
org.eclipse.jdt.core.compiler.release=disabled
org.eclipse.jdt.core.compiler.source=11


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.settings/org.eclipse.m2e.core.prefs
================================================
activeProfiles=
eclipse.preferences.version=1
resolveWorkspaceProjects=true
version=1


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.settings/org.eclipse.wst.common.component
================================================
<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
                    
    
    
    
    <wb-module deploy-name="x38ShLibClasses-pif">
                                
        
        
        <wb-resource deploy-path="/" source-path="/test-integration"/>
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/java"/>
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/resources"/>
                                    
    
    
    
    </wb-module>
                



</project-modules>


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.settings/org.eclipse.wst.common.project.facet.core.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <runtime name="Oracle WebLogic Server 14.1.1.0"/>
  <installed facet="jst.utility" version="1.0"/>
  <installed facet="java" version="11"/>
</faceted-project>


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.settings/org.eclipse.wst.validation.prefs
================================================
disabled=06target
eclipse.preferences.version=1


================================================
File: x38ShLibClasses/x38ShLibClasses-pif/.settings/org.hibernate.eclipse.console.prefs
================================================
default.configuration=x38ShLibClasses-pif
eclipse.preferences.version=1
hibernate3.enabled=true


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/LICENSE.txt
================================================
                    Licencia Pública de la Unión Europea
                                 Versión 1.1
                        EUPL © Comunidad Europea 2007
                     http://ec.europa.eu/idabc/eupl.html


   La presente Licencia Pública de la Unión Europea («EUPL»), se aplica a la 
   obra o al programa de ordenador (definidos a continuación) suministrados en
   las condiciones fijadas en la presente licencia. Queda prohibido cualquier
   uso de la obra distinto del autorizado por la presente licencia (en la 
   medida en que tal uso esté protegido por un derecho del titular de los 
   derechos de autor de la obra). 
   
   La obra original se suministrará en las condiciones fijadas en la presente 
   licencia cuando el licenciante (definido a continuación) haya colocado la 
   siguiente advertencia inmediatamente después de la mención a los derechos 
   de autor de la obra original: 
   
   			Licencia cedida con arreglo a la EUPL V.1.1 
   
   o haya expresado por otro procedimiento su voluntad de conceder una 
   licencia con arreglo a la EUPL. 
   
   
   1. Definiciones 
      En la presente licencia, se entenderá por: 
      – licencia: la presente licencia. 
      – obra original o programa de ordenador: el programa de ordenador 
        distribuido o comunicado por el licenciante con arreglo a la presente 
        licencia en forma de código fuente o, en su caso, de código ejecutable;
      – obras derivadas: las obras o el programa de ordenador que pudiera crear
        el licenciatario sobre la base de la obra original o de alguna de las 
        modificaciones de ésta. La presente licencia no define el grado de 
        modificación o dependencia de la obra original necesario para 
        clasificar una obra como derivada; dicho grado se determinará de 
        acuerdo con la legislación sobre derechos de autor aplicable en el país
        contemplado en el artículo 15;
      – obra: la obra original o sus obras derivadas; 
      – código fuente: la forma de la obra legible por seres humanos que pueda 
        ser estudiada y modificada más fácilmente; 
      – código ejecutable: cualquier código, en general compilado, destinado a 
        ser ejecutado como programa por un ordenador; 
      – licenciante: la persona física o jurídica que distribuye o comunica la 
        obra con arreglo a la licencia; 
      – colaborador: la persona física o jurídica que modifica la obra con 
        arreglo a la licencia o contribuye de cualquier otra manera a crear una
        obra derivada; 
      – licenciatario: la persona física o jurídica que hace un uso cualquiera 
        del programa de ordenador en las condiciones fijadas en la licencia; 
      – distribución o comunicación: cualquier acto de venta, donación,
        préstamo, alquiler, distribución, comunicación, transmisión o cualquier
        otro acto de puesta a disposición, en línea o fuera de línea, de copias
        de la obra o de acceso a sus funcionalidades esenciales a otra persona 
        física o jurídica.
   
   2. Ámbito de los derechos otorgados por la Licencia 
      El licenciante concede al licenciatario una licencia de ámbito mundial, a
      título gratuito, no exclusiva y que el licenciatario puede subcontratar 
      mientras sigan vigentes los derechos de autor sobre la obra original, y 
      lo autoriza a: 
      
      – utilizar la obra en cualquier circunstancia y para cualquier uso; 
      – reproducir la obra; 
      – modificar la obra original y realizar obras derivadas de la misma; 
      – comunicar al público la obra o copias de la misma, poner a su 
        disposición o exhibir la obra o las copias y, en su caso, ejecutar 
        públicamente la Obra; 
      – distribuir la obra o copias de la misma; 
      – prestar y alquilar la obra o copias de la misma; 
      – subcontratar los derechos relativos a la obra o a las copias de la
        misma. 
      
      Dichos derechos se podrán ejercer a través de cualquier medio, soporte y 
      formato, conocido en el presente o que pueda inventarse en el futuro, en 
      la medida en que así lo permita la legislación aplicable. 
      
      En los países cuyo ordenamiento contemple los derechos morales, el 
      Licenciante renunciará al ejercicio de los mismos en la medida en que lo 
      permita la legislación, a fin de hacer efectiva la licencia de los 
      derechos patrimoniales anteriormente enumerados. 
      
      El licenciante cede al licenciatario, libre de cánones, los derechos de 
      uso no exclusivos sobre cualquier patente de que sea titular, en la 
      medida necesaria para que el licenciatario haga uso de los derechos sobre
      la obra otorgados por la presente licencia. 
   
   3. Comunicación del Código Fuente 
      El licenciante podrá suministrar la obra en forma de código fuente o 
      código ejecutable. Si la suministrara en forma de código ejecutable, 
      deberá facilitar además una copia legible automáticamente del código 
      fuente de la obra junto con cada copia de la obra que distribuya, o bien 
      indicar, en una advertencia inserta a continuación de la mención a los 
      derechos de autor adjunta a la obra, un repositorio en el que se pueda 
      acceder al código fuente fácilmente y de manera gratuita durante el 
      período en que el licenciante siga distribuyendo o comunicando la obra. 
   
   4. Limitaciones a los derechos de autor 
      En ningún caso podrá interpretarse la presente licencia de modo que prive
      al licenciatario de los beneficios de los que pudiera disfrutar como 
      consecuencia de las excepciones o limitaciones a los derechos exclusivos 
      de los titulares de los derechos de la obra original o del programa de 
      ordenador, de la extinción de dichos derechos o de cualquier otra 
      limitación aplicable. 
   
   5. Obligaciones del licenciatario 
      La cesión de los derechos en virtud de la presente licencia queda 
      supeditada a ciertas restricciones u obligaciones que habrá de respetar 
      el licenciatario. Dichas obligaciones son: 
      
      Derecho de atribución: El licenciatario deberá mantener íntegramente 
      todas las advertencias y menciones a los derechos de autor, patentes o 
      marcas registradas, así como las que se refieran a la licencia y a la 
      exención de responsabilidad. El licenciatario deberá adjuntar copias de 
      dichas advertencias y menciones y de la Licencia con cada copia de la 
      obra que distribuya o comunique. El licenciatario se responsabilizará de 
      que sus modificaciones u obras derivadas incluyan una advertencia bien 
      destacada declarando que ha modificado la obra, y la fecha de 
      modificación.
      
      Cláusula de «izquierdo de copia» (copyleft): Si el licenciatario 
      distribuyera o comunicara copias de la obra original o de obras derivadas
      basadas en la obra original, dicha distribución o comunicación deberá 
      hacerse en las condiciones fijadas en la presente licencia o de una 
      versión posterior de la presente licencia, salvo si la obra original se 
      distribuye expresamente solo en la presente versión de la licencia. El 
      licenciatario (ahora en su calidad de licenciante) no podrá ofrecer ni 
      imponer condiciones adicionales sobre la obra o las obras derivadas que 
      modifiquen o limiten las condiciones de la licencia. 
      
      Cláusula de compatibilidad: Si el licenciatario distribuyera o comunicara
      obras derivadas o copias de estas últimas basadas a su vez en la obra 
      original y en otra obra licenciada bajo una licencia compatible, la 
      distribución o comunicación podrán efectuarse con arreglo a las 
      condiciones de dicha licencia compatible. A efectos de la presente 
      cláusula, se entenderá por «licencia compatible» cualquiera de las 
      licencias enumeradas en el apéndice adjunto a la presente licencia. En 
      caso de que las obligaciones del licenciatario con arreglo a la licencia 
      compatible estén en colisión con las derivadas de la presente licencia, 
      prevalecerán las obligaciones de la licencia compatible. 
      
      Suministro del código fuente: Cuando distribuya o comunique copias de la 
      obra, el licenciatario deberá facilitar una copia del código fuente 
      legible automáticamente o indicar un repositorio en que se pueda acceder 
      al código fuente fácilmente y de manera gratuita durante el período en 
      que siga distribuyendo o comunicando la obra. 
      
      Salvaguardia de otros derechos: La presente licencia no faculta para 
      utilizar los nombres comerciales, marcas de producto o de servicio o 
      nombres del licenciante, excepto cuando ello, realizado en la medida de 
      lo razonable y conforme a los usos habituales, sea necesario para indicar
      el origen de la obra y reproducir el contenido de la mención a los 
      derechos de autor. 
   
   6. Secuencia de autoría 
      El licenciante original garantiza ser titular originario de los derechos 
      de autor sobre la obra original objeto de la presente licencia o haberlos
      adquirido mediante la licencia correspondiente y estar facultado para 
      otorgar licencias sobre tales derechos.
      
      Cada colaborador garantiza ser titular de los derechos de autor sobre las
      modificaciones que aporta a la obra o haberlos adquirido mediante la 
      correspondiente licencia y estar facultado para otorgar licencias sobre 
      tales derechos.
      
      Cada vez que el licenciatario acepta la licencia, el licenciante original
      y los colaboradores posteriores le otorgan una licencia sobre sus propias
      contribuciones a la obra en las condiciones fijadas en la presente
      licencia.
   
   7. Exclusión de garantía 
      La obra se encuentra en proceso de elaboración, siendo objeto de 
      continuas mejoras por parte de numerosos colaboradores. No es una obra 
      acabada y por tanto puede contener defectos o fallos inherentes al 
      desarrollo de este tipo de programas. 
      
      Por este motivo, la obra, en virtud de la licencia, se suministra «tal 
      cual», sin garantías de ningún tipo, en particular, en una enumeración no
      exhaustiva, en cuanto a su comercialización, adecuación a un propósito 
      determinado, ausencia de defectos 
      
      o errores, exactitud y ausencia de infracción de los derechos de 
      propiedad intelectual distintos de los derechos de autor según se afirma
      en el artículo 6 de la presente licencia. 
      Esta exclusión de garantía forma parte esencial de la licencia y es 
      condición para la cesión de cualquier derecho con respecto a la obra. 
   
   8. Exclusión de responsabilidad 
      Excepto en casos de dolo o de daños ocasionados directamente a personas 
      físicas, el licenciante no será responsable de los daños y perjuicios de 
      cualquier clase, directos o indirectos, materiales o morales, que 
      pudieran derivarse de la licencia o del uso de la obra, en particular, en
      una enumeración no exhaustiva, de los daños y perjuicios por pérdida de 
      buena reputación, paro técnico, avería o mal funcionamiento de equipos 
      informáticos, pérdida de datos o cualquier perjuicio comercial, incluso 
      si el licenciante conocía la posibilidad de dichos daños. No obstante, el
      licenciante será responsable, de acuerdo con las normas legales que 
      regulen la responsabilidad por los daños causados por productos, en la 
      medida en que dichas normas sean aplicables a la obra. 
   
   9. Acuerdos adicionales 
      Al distribuir la obra original o las obras derivadas, el licenciatario 
      podrá suscribir un acuerdo adicional, y cobrar una remuneración para 
      ofrecer asistencia y proporcionar garantías o asumir indemnizaciones u 
      otras obligaciones en materia de responsabilidad o proporcionar servicios
      compatibles con la presente licencia. No obstante, al aceptar tales 
      obligaciones, el licenciatario actuará únicamente en nombre propio y bajo
      su exclusiva responsabilidad, y nunca en nombre del licenciante original
      ni de ningún otro colaborador, y ello a condición de que acceda a 
      indemnizar, defender y amparar a todo colaborador frente a cualquier 
      responsabilidad en que éste pudiera incurrir y frente a las reclamaciones
      que pudieran presentarse contra él por haber aceptado el licenciatario la
      mencionada garantía o responsabilidad adicional.
   
   10. Aceptación de la licencia 
      Lo dispuesto en la presente licencia puede aceptarse haciendo clic en el 
      icono «Aceptar» situado en la parte inferior de la ventana en que aparece
      el texto de la presente licencia o manifestando el consentimiento de 
      cualquier otra forma similar, de conformidad con lo previsto en la 
      legislación aplicable. Haciendo clic en dicho icono, se expresa la 
      aceptación inequívoca e irrevocable de la presente licencia y de todo su 
      contenido. 
      
      Asimismo, el licenciatario acepta irrevocablemente la presente licencia y
      todas sus condiciones por el mero hecho de ejercer cualquiera de los 
      derechos que le otorga el artículo 2 de la presente licencia, tales como
      el uso de la obra, la creación de una obra derivada o la distribución o 
      comunicación de la obra o de copias de la misma. 
   
   11. Información al público 
      En caso de que el licenciatario proceda a la distribución o comunicación
      de la obra por medios electrónicos (por ejemplo, ofreciendo la descarga 
      de la obra a distancia), el canal o medio de distribución (por ejemplo, 
      un sitio web) deberá facilitar al público, como mínimo, la información 
      exigida por la legislación aplicable acerca del licenciante, la licencia 
      y la manera en que el licenciatario puede acceder a dichos datos, 
      aceptarlos, conservarlos y reproducirlos. 
   
   12. Extinción de la licencia 
      La licencia y los derechos otorgados a su amparo se extinguirán 
      automáticamente si el licenciatario incumple alguna de las condiciones de
      la licencia.
      
      Tal extinción no supondrá, sin embargo, la de las licencias de que 
      disfruten las personas que hayan recibido la obra del licenciatario en
      virtud de la licencia, siempre que dichas personas sigan cumpliendo 
      plenamente las condiciones de la licencia. 
   
   13. Varios 
      No obstante lo dispuesto en el artículo 9, la licencia representará la 
      totalidad del acuerdo entre las partes en cuanto a la obra objeto de la 
      misma. 
      
      La eventual invalidez o ineficacia de alguna disposición de la presente 
      licencia con arreglo a la legislación vigente no afectará a la validez o 
      eficacia general de la licencia. En tales casos, la disposición se 
      interpretará o reformulará según proceda para hacerla válida y eficaz. 
      
      La Comisión Europea podrá publicar otras versiones lingüísticas o nuevas 
      versiones de la presente licencia en la medida en que resulte necesario y
      razonable y sin reducir el ámbito de los derechos concedidos por la 
      licencia. Las nuevas versiones de la licencia se publicarán con un número
      de versión único. 
      
      Todas las versiones lingüísticas de la presente licencia aprobadas por la
      Comisión European tienen idéntico valor. Las partes pueden utilizar la
      versión lingüística de su preferencia. 
   
   14. Tribunales competentes 
      Los litigios relativos a la interpretación de la presente licencia que se
      planteen entre la Comisión Europea, en calidad de licenciante, y un 
      licenciatario, se someterán a la jurisdicción del Tribunal de Justicia de
      las Comunidades Europeas, con arreglo al artículo 238 del Tratado
      constitutivo de la Comunidad Europea. 
      
      Los litigios relativos la interpretación de la presente licencia que se
      planteen entre partes distintas de la Comisión Europea, se someterán a la
      jurisdicción exclusiva del tribunal que sea competente en el lugar en que
      resida o ejerza su actividad principal el licenciante. 
   
   15. Legislación aplicable 
      La presente Licencia se regirá por la legislación del país de la Unión 
      Europea en el que resida o tenga su domicilio social el licenciante. 
      
      La presente licencia se regirá por la legislación belga si: 
      
      – se planteara un litigio entre la Comisión Europea, en calidad de 
        licenciante, y un licenciatario; 
      – el licenciante, distinto de la Comisión Europea, no residiera o no 
        tuviera su domicilio social en un Estado miembro de la Unión Europea. 
   
   Apéndice 
   
   Son «licencias compatibles» con la EUPL con arreglo al artículo 5: 
   
   – GNU General Public License (GNU GPL) v. 2 
   – Open Software License (OSL) v. 2.1, v. 3.0 
   – Common Public License v. 1.0 
   – Eclipse Public License v. 1.0 
   – Cecill v. 2.0 
   


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/NOTICE.txt
================================================
NOTICE.txt - UDA copyright notices

UDA is Copyright 2011 by E.J.I.E., S.A.
	
	* The plug-in and RUP components are licensed under the EUPL, Version 1.1 only 
	(the "Licence");
	* Documentation is licensed under the Creative Commons Attribution-NonCommercial-
	ShareAlike 3.0 Unported (CC BY-NC-SA 3.0) 
	
THIRD PARTY COMPONENTS

	The UDA plug-in includes software developed by:
	
		* Enterprise JavaBeans 3.0
			http://www.oracle.com/technetwork/java/javaee/ejb/index.html
			Sun Microsystems, Inc.
			License: COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0

		* Oracle JDBC Drivers 
			http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html
			Oracle Corporation
			License: OTN (http://www.oracle.com/technetwork/licenses/standard-license-152015.html)

		* The JBoss Community
			Hibernate Tools (http://www.hibernate.org/subprojects/tools.html)
			Copyright (c) 2010 JBoss by Red Hat and others.
			License: FSF Lesser Gnu Public License (LGPL v2.1) (http://www.hibernate.org/license)

		* Eclipse
			Eclipse Platform (http://www.eclipse.org/platform)
			Copyright (c) Eclipse contributors and others 2000, 2011.  All rights reserved.
			License: Eclipse Foundation Software User Agreement
						
		* Oracle Enterprise Pack for Eclipse (OEPE)
			http://www.oracle.com/technetwork/developer-tools/eclipse/overview/index.html
			Copyright © 2008, 2011, Oracle and/or its affiliates. All rights reserved.
			License: ORACLE ENTERPRISE PACK FOR ECLIPSE LICENSE AGREEMENT
						
		* PMD (http://pmd.sourceforge.net)
			PMD plugin For Eclipse
			Copyright (c) 1997-2009, PMD for Eclipse Development Team
			License: "BSD-style" license (http://pmd.sourceforge.net/license.html)									

		* Eclipse Checkstyle Plugin (http://eclipse-cs.sf.net/)
			Checkstyle integration plugin for Eclipse
			(c) Copyright David Schneider, Lars Koedderitzsch and others, 2002-2010
			License: GNU Lesser General Public License Version 2.1 
						
		* FindBugs (http://findbugs.sourceforge.net)
			FindBugs plugin for Eclipse
			(c) Trademark and Copyright 2003-2008 by the University of Maryland.
			License: GNU Lesser General Public License (LGPL) (http://findbugs.sourceforge.net/manual/license.html)
			
		* Eclipse Subversive - SVN Team Provider Project
			The Eclipse Team Provider for the Subversion version control system.
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement 
			
		* Polarion Subversive SVN Connectors (http://www.polarion.org and http://www.polarion.com)
			Set of the SVN connectors for the Eclipse Subversive - SVN Team Provider. 
			Copyright (c) 2005, 2008 Polarion Software and other. All rights reserved.
			License: Eclipse Foundation Software User Agreement
			
		* Resource Bundle Editor (http://sourceforge.net/projects/eclipse-rbe/)
			Essiembre ResourceBundle Editor
			Copyright (C) 2003, 2004  Pascal Essiembre, Essiembre Consultant Inc.
			License: GNU Lesser General Public License Version 2.1

		* FreeMarker IDE (http://www.jboss.org/tools)
			FreeMarkerIDE provides editor for FreeMarker templates
			Copyright (c) 2008-2011 Red Hat, Inc. and others.
			License: Eclipse Public License - v 1.0 (http://www.eclipse.org/legal/epl-v10.html)


			
	The RUP (Rich UDA Patterns) components includes software developed by:

		* The jQuery Project
			jQuery core (http://jquery.com/)
			Copyright 2011, John Resig
			License: Gnu Public License v2 (GPLv2), MIT license
			
		* The jQueryUI Team
			jQueryUI (http://jqueryui.com/)
			Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
			License: Gnu Public License v2 (GPLv2), MIT license

		* The jQuery Grid Plugin
			jQuery Grid Plugin (http://www.trirand.com/blog/)
			Copyright (c) 2007-2011 jQuery Grid Plugin 
			License: Gnu Public License v2 (GPLv2), MIT license

		* ajaxBlender.com
			xBreadcrumbs (Extended Breadcrums) jQuery Plugin (http://www.ajaxblender.com/xbreadcrumbs.html)
			Copyright 2009 ajaxBlender.com 
			
		* form2object			
			form2object (https://github.com/maxatwork/form2js)
			Copyright (c) 2010 Maxim Vasiliev
			License: (https://github.com/maxatwork/form2js/blob/master/license.txt)
			
			

================================================
File: x38ShLibClasses/x38ShLibClasses-rup/pom.xml
================================================
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
	<parent>
		<groupId>com.ejie.x38</groupId>
		<artifactId>x38</artifactId>
		<version>6.1.0-RELEASE</version>
	</parent>
	<modelVersion>4.0.0</modelVersion>
	<artifactId>x38ShLibClasses-rup</artifactId>
	<packaging>jar</packaging>
	<name>x38ShLibClasses-rup</name>
	<url>http://www.ejie.eus</url>
	<dependencies>
		<dependency>
			<groupId>com.ejie.x38</groupId>
			<artifactId>x38ShLibClasses</artifactId>
			<version>6.1.0-RELEASE</version>
		</dependency>
	</dependencies>
</project>


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.classpath
================================================
<?xml version="1.0" encoding="UTF-8"?>
<classpath>
	<classpathentry kind="src" output="target/classes" path="src/main/java">
		<attributes>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="src" output="target/test-classes" path="src/test/java">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="optional" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="org.eclipse.jst.component.nondependency" value=""/>
		</attributes>
	</classpathentry>
	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-11">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/classes" path="src/main/resources">
		<attributes>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry excluding="**" kind="src" output="target/test-classes" path="src/test/resources">
		<attributes>
			<attribute name="test" value="true"/>
			<attribute name="maven.pomderived" value="true"/>
			<attribute name="optional" value="true"/>
		</attributes>
	</classpathentry>
	<classpathentry kind="output" path="target/classes"/>
</classpath>


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.gitignore
================================================
/target/


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.project
================================================
<?xml version="1.0" encoding="UTF-8"?>
<projectDescription>
	<name>x38ShLibClasses-rup_v6</name>
	<comment></comment>
	<projects>
	</projects>
	<buildSpec>
		<buildCommand>
			<name>org.eclipse.wst.common.project.facet.core.builder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.jdt.core.javabuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.hibernate.eclipse.console.hibernateBuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.wst.validation.validationbuilder</name>
			<arguments>
			</arguments>
		</buildCommand>
		<buildCommand>
			<name>org.eclipse.m2e.core.maven2Builder</name>
			<arguments>
			</arguments>
		</buildCommand>
	</buildSpec>
	<natures>
		<nature>org.eclipse.jem.workbench.JavaEMFNature</nature>
		<nature>org.eclipse.wst.common.modulecore.ModuleCoreNature</nature>
		<nature>org.eclipse.jdt.core.javanature</nature>
		<nature>org.eclipse.m2e.core.maven2Nature</nature>
		<nature>org.hibernate.eclipse.console.hibernateNature</nature>
		<nature>org.eclipse.wst.common.project.facet.core.nature</nature>
	</natures>
</projectDescription>


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/bin/.gitignore
================================================
/bin/
/target/


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/src/main/java/META-INF/MANIFEST.MF
================================================
Manifest-Version: 1.0
Class-Path: 



================================================
File: x38ShLibClasses/x38ShLibClasses-rup/src/main/java/com/ejie/x38/rup/table/filter/dao/FilterDao.java
================================================
package com.ejie.x38.rup.table.filter.dao;

import java.util.List;

import com.ejie.x38.rup.table.filter.model.Filter;

public interface FilterDao {

	Filter insert(Filter filter);

	Filter update(Filter filter);

	Filter delete(Filter filter);

	// boolean isDefaultAsigned(String selector) ;

	// public boolean isNameRepeated(String selector, String text);

	Filter getById(String id);

	Filter getBySelectorAndName(String selector, String text, String user);

	void setDefaultAsigned(String selector, String text, boolean active, String user);

	Filter getDefaultAsigned(String selector, String user);

	List<Filter> getAll(String selector, String user);
}


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/src/main/java/com/ejie/x38/rup/table/filter/dao/FilterDaoImpl.java
================================================
package com.ejie.x38.rup.table.filter.dao;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.dao.support.DataAccessUtils;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;
import org.springframework.jdbc.support.lob.DefaultLobHandler;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import com.ejie.x38.rup.table.filter.model.Filter;
import com.fasterxml.jackson.databind.ObjectMapper;

@Repository
@Transactional
public class FilterDaoImpl implements FilterDao {

	private static final Logger logger = LoggerFactory.getLogger(FilterDaoImpl.class);

	private NamedParameterJdbcTemplate jdbcTemplate;

	private String db_filterTableName;
	private String col_filterId;
	private String col_filterSelector;
	private String col_filterValue;
	private String col_filterName;
	private String col_filterUser;
	private String col_filterDefault;
	private String filterSeq;

	private DefaultLobHandler defaultLobHandler;

	private RowMapper<Filter> filterRowMapper = new RowMapper<Filter>() {
		public Filter mapRow(ResultSet resultSet, int rowNum) throws SQLException {

			Filter filter = new Filter();

			filter.setId(Integer.toString(resultSet.getInt(col_filterId)));
			filter.setSelector(resultSet.getString(col_filterSelector));
			filter.setText(defaultLobHandler.getClobAsString(resultSet, col_filterName));
			filter.setUser(resultSet.getString(col_filterUser));
			filter.setActive(resultSet.getBoolean(col_filterDefault));

			String data = defaultLobHandler.getClobAsString(resultSet, col_filterValue);

			try {
				// Verificar si el String es JSON antes de realizar la conversión
				if (!isJson(data)) {
					String jsonString = convertToValidJson(data);

					filter.setData(jsonString);
				} else {
					filter.setData(data);
				}
			} catch (Exception e) {
				e.printStackTrace();
			}

			return filter;
		}
	};

	@Override
	public Filter insert(Filter filter) {

		StringBuilder query = new StringBuilder();
		query.append("SELECT ").append(filterSeq).append(".NEXTVAL FROM DUAL");
		SqlParameterSource beanParameterSource = new BeanPropertySqlParameterSource(filter);

		filter.setId(jdbcTemplate.queryForObject(query.toString(), beanParameterSource, String.class));

		beanParameterSource = new BeanPropertySqlParameterSource(filter);

		query = new StringBuilder();
		query.append("INSERT INTO ").append(db_filterTableName).append(" ");
		query.append("(").append(col_filterId).append(",").append(col_filterSelector).append(",").append(col_filterName)
				.append(",").append(col_filterDefault).append(",").append(col_filterValue).append(',')
				.append(col_filterUser).append(")");
		query.append(" VALUES (:id, :selector, :text, :active, :data, :user)");

		logger.debug("FilterDaoImpl.insert()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: " + filter.toString());

		jdbcTemplate.update(query.toString(), beanParameterSource);

		return filter;

	}

	@Override
	public Filter update(Filter filter) {

		StringBuilder query = new StringBuilder();

		query.append("UPDATE ").append(db_filterTableName).append(" ");
		query.append(" SET ").append(col_filterDefault).append("=:active,").append(col_filterValue).append("=:data");
		query.append(" WHERE ").append(getWhereFieldsNameAndSelector());

		SqlParameterSource beanParameterSource = new BeanPropertySqlParameterSource(filter);

		logger.debug("FilterDaoImpl.update()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: " + filter.toString());

		jdbcTemplate.update(query.toString(), beanParameterSource);
		return filter;
	}

	@Override
	public Filter delete(Filter filter) {

		StringBuilder query = new StringBuilder();

		query.append("DELETE FROM ").append(db_filterTableName).append(" ");
		query.append(" WHERE ").append(getWhereFieldsNameAndSelector());

		SqlParameterSource beanParameterSource = new BeanPropertySqlParameterSource(filter);

		logger.debug("FilterDaoImpl.delete()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: " + filter.toString());

		jdbcTemplate.update(query.toString(), beanParameterSource);
		return filter;

	}

	@Override
	public Filter getBySelectorAndName(String selector, String text, String user) {
		StringBuilder query = new StringBuilder();

		query.append("SELECT ").append(getSelectFildsName());
		query.append(" FROM ").append(db_filterTableName);
		query.append(" WHERE ").append(getWhereFieldsNameAndSelector());

		MapSqlParameterSource mapParameterSource = new MapSqlParameterSource();
		mapParameterSource.addValue("text", text);
		mapParameterSource.addValue("selector", selector);
		mapParameterSource.addValue("user", user);

		logger.debug("FilterDaoImpl.getBySelectorAndName()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: {text: " + text + ", selector: " + selector + "}");

		// return jdbcTemplate.queryForObject(query.toString(), mapParameterSource,
		// filterRowMapper);
		List<Filter> respuesta = jdbcTemplate.query(query.toString(), mapParameterSource, filterRowMapper);

		return (Filter) DataAccessUtils.uniqueResult(respuesta);
	}

	@Override
	public Filter getById(String id) {
		StringBuilder query = new StringBuilder();

		query.append("SELECT ").append(getSelectFildsName());
		query.append(" FROM ").append(db_filterTableName);
		query.append(" WHERE ").append(col_filterId).append(":=id");

		MapSqlParameterSource mapParameterSource = new MapSqlParameterSource();
		mapParameterSource.addValue("id", id);

		logger.debug("FilterDaoImpl.getById()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: {id: " + id + "}");

		// return jdbcTemplate.queryForObject(query.toString(), mapParameterSource,
		// filterRowMapper);
		List<Filter> respuesta = jdbcTemplate.query(query.toString(), mapParameterSource, filterRowMapper);
		return (Filter) DataAccessUtils.uniqueResult(respuesta);
	}

//	@Override
//	public boolean isDefaultAsigned(String selector)
//			 {
//		
//		StringBuilder query = new StringBuilder();
//		
//		query.append("SELECT count(1) ");
//		query.append(" FROM ").append(db_filterTableName);
//		query.append(" WHERE ").append(col_filterSelector).append("=:filterSelector AND ").append(col_filterDefault).append("=1");
//		
//		MapSqlParameterSource mapParameterSource =  new MapSqlParameterSource();
//		mapParameterSource.addValue("filterSelector", selector);
//		
//		logger.debug("FilterDaoImpl.isDefaultAsigned()");
//		logger.debug("\tSQL: " +query.toString());
//		logger.debug("\tparams: { filterSelector: "+selector+"}");
//		
//		return jdbcTemplate.queryForObject(query.toString(), mapParameterSource,Integer.class)>0;
//	}

	/*
	 * public boolean isNameRepeated(String selector, String name) {
	 * 
	 * StringBuilder query = new StringBuilder();
	 * 
	 * query.append("SELECT count(1) ");
	 * query.append(" FROM ").append(db_filterTableName);
	 * query.append(" WHERE ").append(getWhereFieldsNameAndSelector());
	 * 
	 * MapSqlParameterSource mapParameterSource = new MapSqlParameterSource();
	 * mapParameterSource.addValue("filterSelector", selector);
	 * mapParameterSource.addValue("filterName", name);
	 * 
	 * 
	 * logger.debug("FilterDaoImpl.isNameRepeated()"); logger.debug("\tSQL: "
	 * +query.toString());
	 * logger.debug("\tparams: { filterSelector: "+selector+"}");
	 * 
	 * return jdbcTemplate.queryForObject(query.toString(),
	 * mapParameterSource,Integer.class)>0; }
	 */

	@Override
	public void setDefaultAsigned(String selector, String text, boolean active, String user) {

		StringBuilder query = new StringBuilder();
		int pred = 0;
		query.append("UPDATE ").append(db_filterTableName).append(" ");
		query.append("SET ").append(col_filterDefault).append("=:active");
		query.append(" WHERE ").append(getWhereFieldsNameAndSelector());

		if (active) {
			pred = 1;
		}

		MapSqlParameterSource mapParameterSource = new MapSqlParameterSource();
		mapParameterSource.addValue("active", pred);
		mapParameterSource.addValue("selector", selector);
		mapParameterSource.addValue("text", text);
		mapParameterSource.addValue("user", user);

		logger.debug("FilterDaoImpl.setDefaultAsigned()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: {active: " + pred + " text: " + text + ", selector: " + selector + "}");

		jdbcTemplate.update(query.toString(), mapParameterSource);
	}

	@Override
	public Filter getDefaultAsigned(String selector, String user) {

		StringBuilder query = new StringBuilder();

		query.append("SELECT ").append(getSelectFildsName());
		query.append(" FROM ").append(db_filterTableName);
		query.append(" WHERE ").append(col_filterSelector).append("= :selector AND ").append(col_filterUser)
				.append("=:user AND ").append(col_filterDefault).append("=1");

		MapSqlParameterSource mapParameterSource = new MapSqlParameterSource();
		mapParameterSource.addValue("selector", selector);
		mapParameterSource.addValue("user", user);

		logger.debug("FilterDaoImpl.getDefaultAsigned()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: { selector: " + selector + "}");
		logger.debug("\tparams: { user: " + user + "}");

		// return jdbcTemplate.queryForObject(query.toString(), mapParameterSource,
		// filterRowMapper);
		List<Filter> respuesta = jdbcTemplate.query(query.toString(), mapParameterSource, filterRowMapper);
		return (Filter) DataAccessUtils.uniqueResult(respuesta);

	}

	@Override
	public List<Filter> getAll(String selector, String user) {

		StringBuilder query = new StringBuilder();

		query.append("SELECT ").append(getSelectFildsName());
		query.append(" FROM ").append(db_filterTableName);
		query.append(" WHERE ").append(col_filterSelector).append("= :selector");
		query.append(" AND ").append(col_filterUser).append("=:user");
		query.append(" ORDER BY ").append(col_filterName);

		MapSqlParameterSource mapParameterSource = new MapSqlParameterSource();
		mapParameterSource.addValue("selector", selector);
		mapParameterSource.addValue("user", user);

		logger.debug("FilterDaoImpl.getAll()");
		logger.debug("\tSQL: " + query.toString());
		logger.debug("\tparams: { selector: " + selector + "}");
		logger.debug("\tparams: { user: " + user + "}");

		return jdbcTemplate.query(query.toString(), mapParameterSource, filterRowMapper);
	}

	public void setFilterDataSource(DataSource dataSource) {
		this.jdbcTemplate = new NamedParameterJdbcTemplate(dataSource);
		this.defaultLobHandler = new DefaultLobHandler();
	}

	private String getSelectFildsName() {
		StringBuilder select = new StringBuilder();
		select.append(col_filterName).append(",").append(col_filterId).append(",").append(col_filterSelector)
				.append(",").append(col_filterUser).append(",").append(col_filterValue).append(",")
				.append(col_filterDefault);
		return select.toString();
	}

	private String getWhereFieldsNameAndSelector() {
		StringBuilder text = new StringBuilder();
		text.append(col_filterSelector).append("=:selector AND ").append(col_filterName).append("=:text AND ")
				.append(col_filterUser).append("=:user");
		return text.toString();
	}

	public String getDb_filterTableName() {
		return db_filterTableName;
	}

	public void setDb_filterTableName(String db_filterTableName) {
		this.db_filterTableName = db_filterTableName;
	}

	public String getCol_filterId() {
		return col_filterId;
	}

	public void setCol_filterId(String col_filterId) {
		this.col_filterId = col_filterId;
	}

	public String getCol_filterSelector() {
		return col_filterSelector;
	}

	public void setCol_filterSelector(String col_filterSelector) {
		this.col_filterSelector = col_filterSelector;
	}

	public String getCol_filterValue() {
		return col_filterValue;
	}

	public void setCol_filterValue(String col_filterValue) {
		this.col_filterValue = col_filterValue;
	}

	public String getCol_filterName() {
		return col_filterName;
	}

	public void setCol_filterName(String col_filterName) {
		this.col_filterName = col_filterName;
	}

	public String getCol_filterDefault() {
		return col_filterDefault;
	}

	public void setCol_filterDefault(String col_filterDefault) {
		this.col_filterDefault = col_filterDefault;
	}

	public String getFilterSeq() {
		return filterSeq;
	}

	public void setFilterSeq(String filterSeq) {
		this.filterSeq = filterSeq;
	}

	public String getCol_filterUser() {
		return col_filterUser;
	}

	public void setCol_filterUser(String col_filterUser) {
		this.col_filterUser = col_filterUser;
	}

	private static boolean isJson(String str) {
		try {
			ObjectMapper objectMapper = new ObjectMapper();
			objectMapper.readTree(str);
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	// Método para convertir un String a formato JSON válido
	private static String convertToValidJson(String inputString) {
		// Dividir el string en pares key:value
		String[] pairs = inputString.split(", ");

		// Crear un mapa para almacenar las claves y valores
		Map<String, String> keyValueMap = new HashMap<String, String>();

		// Expresión regular para identificar pares key:value
		Pattern pattern = Pattern.compile("(\\w+):(\\S+)");
		for (String pair : pairs) {
			Matcher matcher = pattern.matcher(pair);
			if (matcher.matches()) {
				String key = matcher.group(1);
				String value = matcher.group(2);

				// Si la clave contiene la palabra "fecha", intentar identificar el formato y
				// convertir
				if (key.toLowerCase().contains("fecha")) {
					value = convertFecha(value);
				} else {
					// Agregar comillas dobles solo si el valor no está entre comillas
					if (!value.matches("\"[^\"]*\"")) {
						value = "\"" + value + "\"";
					}
				}

				// Almacenar en el mapa
				keyValueMap.put(key, value);
			}
		}

		// Construir el JSON
		StringBuilder jsonStringBuilder = new StringBuilder("{");
		for (Map.Entry<String, String> entry : keyValueMap.entrySet()) {
			jsonStringBuilder.append("\"").append(entry.getKey()).append("\":").append(entry.getValue()).append(",");
		}
		// Eliminar la coma final si hay al menos una entrada
		if (!keyValueMap.isEmpty()) {
			jsonStringBuilder.deleteCharAt(jsonStringBuilder.length() - 1);
		}
		jsonStringBuilder.append("}");

		return jsonStringBuilder.toString();
	}

	// Método para convertir fechas al formato deseado
	private static String convertFecha(String value) {
		try {
			// Convertir el valor directamente a fecha
			long milliseconds = Long.parseLong(value);
			Date date = new Date(milliseconds);
			SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
			return "\"" + sdf.format(date) + "\"";
		} catch (NumberFormatException e) {
			// Si no se puede analizar la fecha, mantener el valor original entre comillas
			return "\"" + value + "\"";
		}
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/src/main/java/com/ejie/x38/rup/table/filter/model/Filter.java
================================================
package com.ejie.x38.rup.table.filter.model;

import com.ejie.x38.generic.model.SelectGeneric;

public class Filter extends SelectGeneric implements java.io.Serializable {

	private static final long serialVersionUID = 1L;

	private String selector;
	private String user;
	private boolean active;
	private String feedback;

	public Filter() {
		super();
	}

	public Filter(String id, String text, String data, String selector, String user, boolean active, String feedback) {
		super(id, text, data, null, null);
		this.selector = selector;
		this.user = user;
		this.active = active;
		this.feedback = feedback;
	}

	public String getSelector() {
		return selector;
	}

	public void setSelector(String selector) {
		this.selector = selector;
	}

	public String getUser() {
		return user;
	}

	public void setUser(String user) {
		this.user = user;
	}

	public boolean isActive() {
		return active;
	}

	public void setActive(boolean active) {
		this.active = active;
	}

	public String getFeedback() {
		return feedback;
	}

	public void setFeedback(String feedback) {
		this.feedback = feedback;
	}

	@Override
	public String toString() {
		StringBuilder result = new StringBuilder();
		result.append(this.getClass().getName()).append(" Object {");
		result.append(" [ id: ").append(this.getId()).append(" ]");
		result.append(" [ text: ").append(this.getText()).append(" ]");
		result.append(" [ data: ").append(this.getData()).append(" ]");
		result.append(" [ selector: ").append(this.selector).append(" ]");
		result.append(" [ user: ").append(this.user).append(" ]");
		result.append(" [ active: ").append(this.active).append(" ]");
		result.append(" [ feedback: ").append(this.feedback).append(" ]");
		result.append("}");
		return result.toString();
	}

}

================================================
File: x38ShLibClasses/x38ShLibClasses-rup/src/main/java/com/ejie/x38/rup/table/filter/service/FilterService.java
================================================
package com.ejie.x38.rup.table.filter.service;

import java.util.List;

import com.ejie.x38.rup.table.filter.model.Filter;

public interface FilterService {

	Filter insert(Filter filter);

	Filter update(Filter filter);

	Filter delete(Filter filter);

	Filter getBySelectorAndName(String selector, String name, String user);

	Filter getById(String id);

	Filter getDefault(String selector, String user);

	List<Filter> getAllFilters(String selector, String user);
}


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/src/main/java/com/ejie/x38/rup/table/filter/service/FilterServiceImpl.java
================================================
package com.ejie.x38.rup.table.filter.service;

import java.util.List;

import org.springframework.stereotype.Service;

import com.ejie.x38.rup.table.filter.dao.FilterDao;
import com.ejie.x38.rup.table.filter.model.Filter;

@Service(value = "filterService")
public class FilterServiceImpl implements FilterService {

	private FilterDao filterDao;

	public FilterDao getFilterDao() {
		return filterDao;
	}

	public void setFilterDao(FilterDao filterDao) {
		this.filterDao = filterDao;
	}

	@Override
	public Filter insert(Filter filter) {
		// comprobar nombreRepetido
		if (!repeatedName(filter.getSelector(), filter.getText(), filter.getUser())) {
			// comprobar predefinido
			if (filter.isActive()) {
				// quitar el filtro predefinido anterior
				removeDeafultPreviousFilter(filter.getSelector(), filter.getUser());
			}

			filterDao.insert(filter);
			filter.setFeedback("ok");
		} else {
			// nombre repetido

			// comprobar predefinido
			if (filter.isActive()) {
				// quitar el filtro predefinido anterior
				removeDeafultPreviousFilter(filter.getSelector(), filter.getUser());
			}
			// Updateo los valores
			// filter.setFeedback("Error, nombre repetido");
			filterDao.update(filter);

		}
		return filter;

	}

	@Override
	public Filter update(Filter filter) {
		// comprobar predefinido
		if (filter.isActive()) {
			// quitar el filtro predefinido anterior
			removeDeafultPreviousFilter(filter.getSelector(), filter.getUser());
		}
		filterDao.update(filter);
		return filter;
	}

	@Override
	public Filter delete(Filter filter) {
		// comprobar existencia
		if (checkFilter(filter)) {

			filterDao.delete(filter);
		} else {
			// no existe el elemento a borrar
			filter.setFeedback("no_records");
		}

		return filter;
	}

	@Override
	public Filter getBySelectorAndName(String selector, String text, String user) {
		return filterDao.getBySelectorAndName(selector, text, user);
	}

	@Override
	public Filter getById(String id) {
		return filterDao.getById(id);
	}

	@Override
	public List<Filter> getAllFilters(String selector, String user) {
		return filterDao.getAll(selector, user);
	}

	private void removeDeafultPreviousFilter(String selector, String user) {
		Filter filter = new Filter();

		filter = filterDao.getDefaultAsigned(selector, user);

		// borro el boolean de predefinido si existe
		// if(filter.size()>0)
		if (filter != null) {
			filterDao.setDefaultAsigned(filter.getSelector(), filter.getText(), false, user);
		}
	}

	private boolean repeatedName(String selector, String name, String user) {
		boolean respuesta = false;

		Filter filter = filterDao.getBySelectorAndName(selector, name, user);

		// if(filter.size()>0)
		if (filter != null) {
			respuesta = true;
		}

		return respuesta;
	}

	@Override
	public Filter getDefault(String selector, String user) {
		return filterDao.getDefaultAsigned(selector, user);
	}

	private boolean checkFilter(Filter filter) {
		boolean existe = false;

		Filter newFilter = filterDao.getBySelectorAndName(filter.getSelector(), filter.getText(), filter.getUser());
		if (newFilter != null) {
			existe = true;
		}
		return existe;
	}

}


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.settings/org.eclipse.core.resources.prefs
================================================
eclipse.preferences.version=1
encoding//src/main/java=UTF-8
encoding//src/main/resources=UTF-8
encoding//src/test/java=UTF-8
encoding//src/test/resources=UTF-8
encoding/<project>=UTF-8
encoding/src=UTF-8


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.settings/org.eclipse.jdt.core.prefs
================================================
eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
org.eclipse.jdt.core.compiler.codegen.targetPlatform=11
org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
org.eclipse.jdt.core.compiler.compliance=11
org.eclipse.jdt.core.compiler.debug.lineNumber=generate
org.eclipse.jdt.core.compiler.debug.localVariable=generate
org.eclipse.jdt.core.compiler.debug.sourceFile=generate
org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
org.eclipse.jdt.core.compiler.release=disabled
org.eclipse.jdt.core.compiler.source=11


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.settings/org.eclipse.m2e.core.prefs
================================================
activeProfiles=
eclipse.preferences.version=1
resolveWorkspaceProjects=true
version=1


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.settings/org.eclipse.wst.common.component
================================================
<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
                    
    
    
    
    <wb-module deploy-name="x38ShLibClasses-rup">
                                
        
        
        <wb-resource deploy-path="/" source-path="/test-integration"/>
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/java"/>
                        
        
        <wb-resource deploy-path="/" source-path="/src/main/resources"/>
                                    
    
    
    
    </wb-module>
                



</project-modules>


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.settings/org.eclipse.wst.common.project.facet.core.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <runtime name="Oracle WebLogic Server 14.1.1.0"/>
  <installed facet="jst.utility" version="1.0"/>
  <installed facet="java" version="11"/>
</faceted-project>


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.settings/org.eclipse.wst.validation.prefs
================================================
disabled=06target
eclipse.preferences.version=1


================================================
File: x38ShLibClasses/x38ShLibClasses-rup/.settings/org.hibernate.eclipse.console.prefs
================================================
default.configuration=x38ShLibClasses-rup
eclipse.preferences.version=1
hibernate3.enabled=true


================================================
File: x38ShLibClasses/.settings/oracle.eclipse.tools.weblogic.syslib.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<system-libraries>
    <library javadoc="http://docs.oracle.com/javaee/5/api/" path="server/lib/api.jar"/>
    <library javadoc="http://docs.oracle.com/cd/E23943_01/apirefs.1111/e13941" path="server/lib/wls-api.jar"/>
    <library path="%MODULES_DIR%/javax.persistence_1.1.0.0_2-0.jar"/>
</system-libraries>

================================================
File: x38ShLibClasses/.settings/org.eclipse.core.resources.prefs
================================================
eclipse.preferences.version=1
encoding//src/com/ejie/x38/dto/JQGridDto.java=UTF-8
encoding/<project>=UTF-8


================================================
File: x38ShLibClasses/.settings/org.eclipse.jdt.core.prefs
================================================
eclipse.preferences.version=1
org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.6
org.eclipse.jdt.core.compiler.compliance=1.6
org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
org.eclipse.jdt.core.compiler.problem.forbiddenReference=warning
org.eclipse.jdt.core.compiler.source=1.6


================================================
File: x38ShLibClasses/.settings/org.eclipse.m2e.core.prefs
================================================
activeProfiles=
eclipse.preferences.version=1
resolveWorkspaceProjects=true
version=1


================================================
File: x38ShLibClasses/.settings/org.eclipse.wst.common.component
================================================
<?xml version="1.0" encoding="UTF-8"?><project-modules id="moduleCoreId" project-version="1.5.0">
    <wb-module deploy-name="x38ShLibClasses">
        <wb-resource deploy-path="/" source-path="/src"/>
        <wb-resource deploy-path="/" source-path="/test-unit"/>
    </wb-module>
</project-modules>


================================================
File: x38ShLibClasses/.settings/org.eclipse.wst.common.project.facet.core.xml
================================================
<?xml version="1.0" encoding="UTF-8"?>
<faceted-project>
  <runtime name="Oracle WebLogic Server 11gR1 (10.3.6)"/>
  <fixed facet="java"/>
  <fixed facet="jst.utility"/>
  <installed facet="jst.utility" version="1.0"/>
  <installed facet="java" version="1.6"/>
</faceted-project>


================================================
File: x38ShLibClasses/.settings/org.eclipse.wst.validation.prefs
================================================
disabled=06target
eclipse.preferences.version=1


================================================
File: x38ShLibClasses/.settings/org.hibernate.eclipse.console.prefs
================================================
#Tue Mar 06 13:34:19 CET 2012
default.configuration=
eclipse.preferences.version=1
hibernate3.enabled=false


